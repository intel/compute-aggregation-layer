/*
 * Copyright (C) 2022-2023 Intel Corporation
 *
 * SPDX-License-Identifier: MIT
 *
 */

#pragma once
// #### Generated code -- begin ####

#include "shared/rpc_message.h"
#include "shared/shmem_transfer_desc.h"

#include "shared/l0_opaque_list_serialization.h"
#include "level_zero/ze_api.h"
#include "level_zero/ze_ddi.h"
#include "level_zero/zes_api.h"
#include "level_zero/zes_ddi.h"
#include "level_zero/zet_api.h"
#include "level_zero/zet_ddi.h"

#include <cassert>
#include <cstring>
#include <memory>
#include <optional>
#include <string>
#include <type_traits>
#include <unordered_map>
#include <utility>
#include <vector>

namespace Cal {
namespace Rpc {
namespace LevelZero {

    inline bool operator==(const ze_ipc_event_pool_handle_t& lhs, const ze_ipc_event_pool_handle_t& rhs) {
        return 0 == std::memcmp(lhs.data, rhs.data, ZE_MAX_IPC_HANDLE_SIZE);
    }

    inline bool operator==(const ze_ipc_mem_handle_t& lhs, const ze_ipc_mem_handle_t& rhs) {
        return 0 == std::memcmp(lhs.data, rhs.data, ZE_MAX_IPC_HANDLE_SIZE);
    }

template <typename Ptr>
inline void forcePointerWrite(Ptr& p, void* value) {
    static_assert(std::is_pointer_v<Ptr>, "forcePointerWrite() must be used with pointers!");
    using WritablePtr = std::remove_cv_t<Ptr>;

    const_cast<WritablePtr&>(p) = static_cast<WritablePtr>(value);
}

typedef struct _model_t {
    char model[ZE_MAX_FABRIC_EDGE_MODEL_EXP_SIZE];
} model_t;

struct DynamicArgTraits {
    uint32_t offset;
    uint32_t count;
    uint32_t size;
    std::vector<DynamicArgTraits> nested;
};

template <typename DynamicStructT>
struct DynamicStructTraits {
    int32_t offset;
    int32_t count;
};

template <>
struct DynamicStructTraits<ze_module_constants_t> {
    int32_t pConstantIdsOffset{-1};
    int32_t pConstantIdsCount{-1};
    int32_t pConstantValuesOffset{-1};
    int32_t pConstantValuesCount{-1};
};

template <>
struct DynamicStructTraits<ze_module_desc_t> {
    int32_t pNextOffset{-1};
    int32_t pNextCount{-1};
    const void* pNextFirstOriginalElement{nullptr};
    int32_t pInputModuleOffset{-1};
    int32_t pInputModuleCount{-1};
    int32_t pBuildFlagsOffset{-1};
    int32_t pBuildFlagsCount{-1};
    int32_t pConstantsOffset{-1};
    int32_t pConstantsCount{-1};
};

template <>
struct DynamicStructTraits<ze_kernel_desc_t> {
    int32_t pKernelNameOffset{-1};
    int32_t pKernelNameCount{-1};
};

template <>
struct DynamicStructTraits<ze_context_desc_t> {
    int32_t pNextOffset{-1};
    int32_t pNextCount{-1};
    const void* pNextFirstOriginalElement{nullptr};
};

template <>
struct DynamicStructTraits<ze_device_properties_t> {
    int32_t pNextOffset{-1};
    int32_t pNextCount{-1};
    void* pNextFirstOriginalElement{nullptr};
};

template <>
struct DynamicStructTraits<ze_device_module_properties_t> {
    int32_t pNextOffset{-1};
    int32_t pNextCount{-1};
    void* pNextFirstOriginalElement{nullptr};
};

template <>
struct DynamicStructTraits<ze_device_memory_properties_t> {
    int32_t pNextOffset{-1};
    int32_t pNextCount{-1};
    void* pNextFirstOriginalElement{nullptr};
};

template <>
struct DynamicStructTraits<ze_device_cache_properties_t> {
    int32_t pNextOffset{-1};
    int32_t pNextCount{-1};
    void* pNextFirstOriginalElement{nullptr};
};

template <>
struct DynamicStructTraits<ze_device_mem_alloc_desc_t> {
    int32_t pNextOffset{-1};
    int32_t pNextCount{-1};
    const void* pNextFirstOriginalElement{nullptr};
};

template <>
struct DynamicStructTraits<ze_host_mem_alloc_desc_t> {
    int32_t pNextOffset{-1};
    int32_t pNextCount{-1};
    const void* pNextFirstOriginalElement{nullptr};
};

template <>
struct DynamicStructTraits<ze_memory_allocation_properties_t> {
    int32_t pNextOffset{-1};
    int32_t pNextCount{-1};
    void* pNextFirstOriginalElement{nullptr};
};

template <>
struct DynamicStructTraits<ze_memory_free_ext_desc_t> {
    int32_t pNextOffset{-1};
    int32_t pNextCount{-1};
    const void* pNextFirstOriginalElement{nullptr};
};

template <>
struct DynamicStructTraits<ze_kernel_properties_t> {
    int32_t pNextOffset{-1};
    int32_t pNextCount{-1};
    void* pNextFirstOriginalElement{nullptr};
};

template <>
struct DynamicStructTraits<ze_device_p2p_properties_t> {
    int32_t pNextOffset{-1};
    int32_t pNextCount{-1};
    void* pNextFirstOriginalElement{nullptr};
};

template <>
struct DynamicStructTraits<ze_image_desc_t> {
    int32_t pNextOffset{-1};
    int32_t pNextCount{-1};
    const void* pNextFirstOriginalElement{nullptr};
};

template <>
struct DynamicStructTraits<ze_module_program_exp_desc_t> {
    int32_t inputSizesOffset{-1};
    int32_t inputSizesCount{-1};
    int32_t pInputModulesOffset{-1};
    int32_t pInputModulesCount{-1};
    int32_t pBuildFlagsOffset{-1};
    int32_t pBuildFlagsCount{-1};
    int32_t pConstantsOffset{-1};
    int32_t pConstantsCount{-1};
};

template <>
struct DynamicStructTraits<zes_power_ext_properties_t> {
    int32_t defaultLimitOffset{-1};
    int32_t defaultLimitCount{-1};
};

template <>
struct DynamicStructTraits<zes_power_properties_t> {
    int32_t pNextOffset{-1};
    int32_t pNextCount{-1};
    void* pNextFirstOriginalElement{nullptr};
};

template <>
struct DynamicStructTraits<zes_ras_state_t> {
    int32_t categoryOffset{-1};
    int32_t categoryCount{-1};
};

template <>
struct DynamicStructTraits<zet_tracer_exp_desc_t> {
    int32_t pNextOffset{-1};
    int32_t pNextCount{-1};
    const void* pNextFirstOriginalElement{nullptr};
};

template <>
struct DynamicStructTraits<ze_uuid_t> {
    int32_t idOffset{-1};
    int32_t idCount{-1};
};

template <>
struct DynamicStructTraits<model_t> {
    int32_t modelOffset{-1};
    int32_t modelCount{-1};
};

template <>
struct DynamicStructTraits<ze_fabric_vertex_exp_properties_t> {
    int32_t pNextOffset{-1};
    int32_t pNextCount{-1};
    void* pNextFirstOriginalElement{nullptr};
};

template <>
struct DynamicStructTraits<ze_fabric_edge_exp_properties_t> {
    int32_t pNextOffset{-1};
    int32_t pNextCount{-1};
    void* pNextFirstOriginalElement{nullptr};
};


template<typename T>
inline char *asMemcpyDstT(T * ptr) {
    static_assert(std::is_standard_layout_v<T>);
    return reinterpret_cast<char*>(const_cast<std::remove_const_t<T>*>(ptr));
};

inline char *asMemcpyDstT(const void * ptr) {
    return reinterpret_cast<char*>(const_cast<void*>(ptr));
};

inline char *asMemcpyDstT(void * ptr) {
    return reinterpret_cast<char*>(const_cast<void*>(ptr));
};

 // zetTracerExpCreate ignored in generator - based on dont_generate_rpc_message flag
 // zetTracerExpDestroy ignored in generator - based on dont_generate_rpc_message flag
 // zetTracerExpSetPrologues ignored in generator - based on dont_generate_rpc_message flag
 // zetTracerExpSetEpilogues ignored in generator - based on dont_generate_rpc_message flag
 // zetTracerExpSetEnabled ignored in generator - based on dont_generate_rpc_message flag
struct ZesDeviceResetRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 0;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_device_handle_t hDevice = {};
        ze_bool_t force = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->force == rhs.force;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesDeviceResetRpcM() = default;

    ZesDeviceResetRpcM(zes_device_handle_t hDevice, ze_bool_t force) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.force = force;
    }
    
    static void fillWithoutCapture(ZesDeviceResetRpcM &message, zes_device_handle_t hDevice, ze_bool_t force) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.force = force;
    }
    
};
static_assert(std::is_standard_layout_v<ZesDeviceResetRpcM>);
struct ZesDeviceResetExtRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 1;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_device_handle_t hDevice = {};
        zes_reset_properties_t* pProperties = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->pProperties == rhs.pProperties;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesDeviceResetExtRpcM() = default;

    ZesDeviceResetExtRpcM(zes_device_handle_t hDevice, zes_reset_properties_t* pProperties) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.pProperties = pProperties;
    }
    
    static void fillWithoutCapture(ZesDeviceResetExtRpcM &message, zes_device_handle_t hDevice, zes_reset_properties_t* pProperties) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.pProperties = pProperties;
    }
    
};
static_assert(std::is_standard_layout_v<ZesDeviceResetExtRpcM>);
struct ZesDeviceEnumPowerDomainsRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 2;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_device_handle_t hDevice = {};
        uint32_t* pCount = {};
        zes_pwr_handle_t* phPower = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->pCount == rhs.pCount;
            equal &= this->phPower == rhs.phPower;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(zes_device_handle_t hDevice, uint32_t* pCount, zes_pwr_handle_t* phPower);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phPower = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        uint32_t pCount;
        uint32_t countPhPower = 0;
        zes_pwr_handle_t phPower[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhPower = dynamicTraits.phPower.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesDeviceEnumPowerDomainsRpcM() = default;

    ZesDeviceEnumPowerDomainsRpcM(const Captures::DynamicTraits &dynamicTraits, zes_device_handle_t hDevice, uint32_t* pCount, zes_pwr_handle_t* phPower) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.pCount = pCount;
        args.phPower = phPower;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZesDeviceEnumPowerDomainsRpcM &message, zes_device_handle_t hDevice, uint32_t* pCount, zes_pwr_handle_t* phPower) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.pCount = pCount;
        message.args.phPower = phPower;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            captures.pCount = *args.pCount;
        }
        if(args.phPower){
            memcpy(asMemcpyDstT(captures.phPower), args.phPower, dynMemTraits.phPower.size);
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            *args.pCount = captures.pCount;
        }
        if(args.phPower){
            memcpy(args.phPower, captures.phPower, dynMemTraits.phPower.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZesDeviceEnumPowerDomainsRpcM>);
struct ZesDeviceGetCardPowerDomainRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 3;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_device_handle_t hDevice = {};
        zes_pwr_handle_t* phPower = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->phPower == rhs.phPower;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        zes_pwr_handle_t phPower;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesDeviceGetCardPowerDomainRpcM() = default;

    ZesDeviceGetCardPowerDomainRpcM(zes_device_handle_t hDevice, zes_pwr_handle_t* phPower) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.phPower = phPower;
    }
    
    static void fillWithoutCapture(ZesDeviceGetCardPowerDomainRpcM &message, zes_device_handle_t hDevice, zes_pwr_handle_t* phPower) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.phPower = phPower;
    }
    

    void copyFromCaller(){
        if(args.phPower){
            captures.phPower = *args.phPower;
        }
    }

    void copyToCaller(){
        if(args.phPower){
            *args.phPower = captures.phPower;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesDeviceGetCardPowerDomainRpcM>);
struct ZesPowerGetPropertiesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 4;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_pwr_handle_t hPower = {};
        zes_power_properties_t* pProperties = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hPower == rhs.hPower;
            equal &= this->pProperties == rhs.pProperties;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(zes_pwr_handle_t hPower, zes_power_properties_t* pProperties);
            uint32_t totalDynamicSize = 0;
            uint32_t dynamicStructMembersOffset = 0;
            DynamicArgTraits pPropertiesNestedTraits = {};
        };

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        zes_power_properties_t pProperties;
        uint32_t dynamicStructMembersOffset = 0;
        uint32_t pPropertiesNestedTraitsOffset = 0;
        uint32_t pPropertiesNestedTraitsCount = 0;

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
            dynamicStructMembersOffset = dynamicTraits.dynamicStructMembersOffset;
            pPropertiesNestedTraitsOffset = dynamicTraits.pPropertiesNestedTraits.offset;
            pPropertiesNestedTraitsCount = dynamicTraits.pPropertiesNestedTraits.count;
            dynMemSize = dynamicTraits.totalDynamicSize;
        }
        
        uint32_t dynMemSize = 0;
        alignas(8) char dynMem[];
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;
        void reassembleNestedStructs() {
            using Cal::Utils::alignUpPow2;

            uint32_t currentOffset = dynamicStructMembersOffset;

            if(pPropertiesNestedTraitsCount > 0){
                assert(currentOffset == pPropertiesNestedTraitsOffset);
                auto* pPropertiesTraits = reinterpret_cast<DynamicStructTraits<zes_power_properties_t>*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(pPropertiesNestedTraitsCount * sizeof(DynamicStructTraits<zes_power_properties_t>));
                auto* destPProperties = &pProperties;

                for (uint32_t i = 0; i < pPropertiesNestedTraitsCount; ++i) {
                    if(pPropertiesTraits[i].pNextOffset == -1){
                        forcePointerWrite(destPProperties[i].pNext, nullptr);
                        continue;
                    }

                    auto pPropertiesPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                    currentOffset += alignUpPow2<8>(pPropertiesTraits[i].pNextCount * sizeof(NestedPNextTraits));

                    assert(currentOffset == static_cast<uint32_t>(pPropertiesPNextListElementTraits[0].extensionOffset));
                    forcePointerWrite(destPProperties[i].pNext, dynMem + pPropertiesPNextListElementTraits[0].extensionOffset);
                    currentOffset += alignUpPow2<8>(getUnderlyingSize(static_cast<const ze_base_desc_t*>(destPProperties[i].pNext)));

                    auto pPropertiesPNextListElement = static_cast<const ze_base_desc_t*>(destPProperties[i].pNext);
                    for(int32_t j = 1; j <= pPropertiesTraits[i].pNextCount; ++j){
                        if (j < pPropertiesTraits[i].pNextCount) {
                            const auto extensionOffset = pPropertiesPNextListElementTraits[j].extensionOffset;
                            forcePointerWrite(getNextField(*pPropertiesPNextListElement), dynMem + extensionOffset);
                        }

                        const auto extensionType = static_cast<int>(pPropertiesPNextListElementTraits[j - 1].extensionType);
                        if (extensionType == ZES_STRUCTURE_TYPE_POWER_EXT_PROPERTIES) {
                            auto& extension = *reinterpret_cast<const zes_power_ext_properties_t*>(pPropertiesPNextListElement);
                            auto* extensionTraits = reinterpret_cast<DynamicStructTraits<zes_power_ext_properties_t>*>(dynMem + currentOffset);
                            currentOffset += alignUpPow2<8>(sizeof(DynamicStructTraits<zes_power_ext_properties_t>));

                            for(int32_t k = 0; k < 1; ++k) {
                                if(extensionTraits[k].defaultLimitOffset == -1){
                                    forcePointerWrite(extension.defaultLimit, nullptr);
                                    continue;
                                }

                                forcePointerWrite(extension.defaultLimit, dynMem + extensionTraits[k].defaultLimitOffset);
                                currentOffset += alignUpPow2<8>(extensionTraits[k].defaultLimitCount * sizeof(zes_power_limit_ext_desc_t));
                            }
                        }
                        if (j < pPropertiesTraits[i].pNextCount) {
                            const auto pNextElement = getNext(pPropertiesPNextListElement);
                            const auto sizeInBytes = getUnderlyingSize(pNextElement);
                            currentOffset += alignUpPow2<8>(sizeInBytes);

                            pPropertiesPNextListElement = pNextElement;
                        }

                    }

                }
        }
    }

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesPowerGetPropertiesRpcM() = default;

    ZesPowerGetPropertiesRpcM(const Captures::DynamicTraits &dynamicTraits, zes_pwr_handle_t hPower, zes_power_properties_t* pProperties) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hPower = hPower;
        args.pProperties = pProperties;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZesPowerGetPropertiesRpcM &message, zes_pwr_handle_t hPower, zes_power_properties_t* pProperties) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hPower = hPower;
        message.args.pProperties = pProperties;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pProperties){
            captures.pProperties = *args.pProperties;
        }
        using Cal::Utils::alignUpPow2;

        auto& dynMem = captures.dynMem;
        uint32_t currentOffset = captures.dynamicStructMembersOffset;
        if(args.pProperties){
            assert(currentOffset == captures.pPropertiesNestedTraitsOffset);
            auto* pPropertiesTraits = reinterpret_cast<DynamicStructTraits<zes_power_properties_t>*>(dynMem + currentOffset);
            currentOffset += alignUpPow2<8>(captures.pPropertiesNestedTraitsCount * sizeof(DynamicStructTraits<zes_power_properties_t>));

            for (uint32_t i = 0; i < captures.pPropertiesNestedTraitsCount; ++i) {
                const auto& pPropertiesPNext = args.pProperties[i].pNext;
                if(!pPropertiesPNext){
                    pPropertiesTraits[i].pNextOffset = -1;
                    pPropertiesTraits[i].pNextCount = -1;
                    continue;
                }

                const auto pPropertiesPNextCount = static_cast<int32_t>(countOpaqueList(static_cast<const ze_base_desc_t*>(args.pProperties[i].pNext)));
                if(!pPropertiesPNextCount){
                    pPropertiesTraits[i].pNextOffset = -1;
                    pPropertiesTraits[i].pNextCount = -1;
                    continue;
                }

                pPropertiesTraits[i].pNextOffset = currentOffset;
                pPropertiesTraits[i].pNextCount = pPropertiesPNextCount;
                pPropertiesTraits[i].pNextFirstOriginalElement = args.pProperties[i].pNext;

                auto pPropertiesPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(pPropertiesPNextCount * sizeof(NestedPNextTraits));

                auto pPropertiesPNextListElement = static_cast<const ze_base_desc_t*>(args.pProperties[i].pNext);
                for(int32_t j = 0; j < pPropertiesPNextCount; ++j){
                    pPropertiesPNextListElementTraits[j].extensionType = getExtensionType(pPropertiesPNextListElement);
                    pPropertiesPNextListElementTraits[j].extensionOffset = currentOffset;

                    const auto sizeInBytes = getUnderlyingSize(pPropertiesPNextListElement);
                    std::memcpy(dynMem + currentOffset, pPropertiesPNextListElement, sizeInBytes);
                    currentOffset += alignUpPow2<8>(sizeInBytes);


                    const auto extensionType = static_cast<int>(getExtensionType(pPropertiesPNextListElement));
                    if (extensionType == ZES_STRUCTURE_TYPE_POWER_EXT_PROPERTIES) {
                        auto& extension = *reinterpret_cast<const zes_power_ext_properties_t*>(pPropertiesPNextListElement);
                        auto* extensionTraits = reinterpret_cast<DynamicStructTraits<zes_power_ext_properties_t>*>(dynMem + currentOffset);
                        currentOffset += alignUpPow2<8>(sizeof(DynamicStructTraits<zes_power_ext_properties_t>));

                        for(int32_t k = 0; k < 1; ++k) {
                            const auto& pPropertiesPNextDefaultLimit = extension.defaultLimit;
                            if(!pPropertiesPNextDefaultLimit){
                                extensionTraits[k].defaultLimitOffset = -1;
                                extensionTraits[k].defaultLimitCount = -1;
                                continue;
                            }

                            const auto pPropertiesPNextDefaultLimitCount = static_cast<int32_t>(1);
                            if(!pPropertiesPNextDefaultLimitCount){
                                extensionTraits[k].defaultLimitOffset = -1;
                                extensionTraits[k].defaultLimitCount = -1;
                                continue;
                            }

                            extensionTraits[k].defaultLimitOffset = currentOffset;
                            extensionTraits[k].defaultLimitCount = pPropertiesPNextDefaultLimitCount;

                            std::memcpy(dynMem + currentOffset, pPropertiesPNextDefaultLimit, pPropertiesPNextDefaultLimitCount * sizeof(zes_power_limit_ext_desc_t));
                            currentOffset += alignUpPow2<8>(pPropertiesPNextDefaultLimitCount * sizeof(zes_power_limit_ext_desc_t));
                        }
                    }
                    pPropertiesPNextListElement = getNext(pPropertiesPNextListElement);
                }

            }
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pProperties){
            *args.pProperties = captures.pProperties;
        }
        using Cal::Utils::alignUpPow2;

        auto& dynMem = captures.dynMem;
        uint32_t currentOffset = captures.dynamicStructMembersOffset;
        if(args.pProperties) {
            assert(currentOffset == captures.pPropertiesNestedTraitsOffset);
            auto* pPropertiesTraits = reinterpret_cast<DynamicStructTraits<zes_power_properties_t>*>(dynMem + currentOffset);
            currentOffset += alignUpPow2<8>(captures.pPropertiesNestedTraitsCount * sizeof(DynamicStructTraits<zes_power_properties_t>));

            auto* destPProperties = args.pProperties;

            for (uint32_t i = 0; i < captures.pPropertiesNestedTraitsCount; ++i) {
                if(pPropertiesTraits[i].pNextOffset == -1){
                    continue;
                }

                destPProperties[i].pNext = pPropertiesTraits[i].pNextFirstOriginalElement;

                auto pPropertiesPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(pPropertiesTraits[i].pNextCount * sizeof(NestedPNextTraits));

                auto pPropertiesPNextListElement = static_cast<const ze_base_desc_t*>(destPProperties[i].pNext);
                for(int32_t j = 0; j < pPropertiesTraits[i].pNextCount; ++j){
                    const auto sizeInBytes = getUnderlyingSize(pPropertiesPNextListElement);
                    currentOffset += alignUpPow2<8>(sizeInBytes);

                    const auto extensionType = getExtensionType(pPropertiesPNextListElement);
                    if (!isReadOnly(extensionType)) {
                        if (extensionType == static_cast<int>(ZES_STRUCTURE_TYPE_POWER_EXT_PROPERTIES)) {
                            auto& extension = *reinterpret_cast<const zes_power_ext_properties_t*>(pPropertiesPNextListElement);
                            auto* extensionTraits = reinterpret_cast<DynamicStructTraits<zes_power_ext_properties_t>*>(dynMem + currentOffset);
                            currentOffset += alignUpPow2<8>(sizeof(DynamicStructTraits<zes_power_ext_properties_t>));

                            for(int32_t k = 0; k < 1; ++k) {
                                const auto& pPropertiesPNextDefaultLimit = extension.defaultLimit;
                                if(!pPropertiesPNextDefaultLimit){
                                    extensionTraits[k].defaultLimitOffset = -1;
                                    extensionTraits[k].defaultLimitCount = -1;
                                    continue;
                                }

                                const auto pPropertiesPNextDefaultLimitCount = static_cast<int32_t>(1);
                                if(!pPropertiesPNextDefaultLimitCount){
                                    extensionTraits[k].defaultLimitOffset = -1;
                                    extensionTraits[k].defaultLimitCount = -1;
                                    continue;
                                }

                                extensionTraits[k].defaultLimitOffset = currentOffset;
                                extensionTraits[k].defaultLimitCount = pPropertiesPNextDefaultLimitCount;

                                std::memcpy(dynMem + currentOffset, pPropertiesPNextDefaultLimit, pPropertiesPNextDefaultLimitCount * sizeof(zes_power_limit_ext_desc_t));
                                currentOffset += alignUpPow2<8>(pPropertiesPNextDefaultLimitCount * sizeof(zes_power_limit_ext_desc_t));
                            }
                        }
                        else
                        {
                            auto originalNextOpaqueElement = getNext(pPropertiesPNextListElement);
                            const auto extensionOffset = pPropertiesPNextListElementTraits[j].extensionOffset;
                            auto destination = const_cast<ze_base_desc_t*>(pPropertiesPNextListElement);
                            std::memcpy(destination, dynMem + extensionOffset, sizeInBytes);

                            getNextField(*destination) = originalNextOpaqueElement;
                        }

                    }

                    pPropertiesPNextListElement = getNext(pPropertiesPNextListElement);
                }

            }
        }
    }
};
static_assert(std::is_standard_layout_v<ZesPowerGetPropertiesRpcM>);
struct ZesPowerGetEnergyCounterRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 5;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_pwr_handle_t hPower = {};
        zes_power_energy_counter_t* pEnergy = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hPower == rhs.hPower;
            equal &= this->pEnergy == rhs.pEnergy;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        zes_power_energy_counter_t pEnergy;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesPowerGetEnergyCounterRpcM() = default;

    ZesPowerGetEnergyCounterRpcM(zes_pwr_handle_t hPower, zes_power_energy_counter_t* pEnergy) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hPower = hPower;
        args.pEnergy = pEnergy;
    }
    
    static void fillWithoutCapture(ZesPowerGetEnergyCounterRpcM &message, zes_pwr_handle_t hPower, zes_power_energy_counter_t* pEnergy) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hPower = hPower;
        message.args.pEnergy = pEnergy;
    }
    

    void copyFromCaller(){
        if(args.pEnergy){
            captures.pEnergy = *args.pEnergy;
        }
    }

    void copyToCaller(){
        if(args.pEnergy){
            *args.pEnergy = captures.pEnergy;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesPowerGetEnergyCounterRpcM>);
struct ZesPowerGetLimitsRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 6;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_pwr_handle_t hPower = {};
        zes_power_sustained_limit_t* pSustained = {};
        zes_power_burst_limit_t* pBurst = {};
        zes_power_peak_limit_t* pPeak = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hPower == rhs.hPower;
            equal &= this->pSustained == rhs.pSustained;
            equal &= this->pBurst == rhs.pBurst;
            equal &= this->pPeak == rhs.pPeak;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        zes_power_sustained_limit_t pSustained;
        zes_power_burst_limit_t pBurst;
        zes_power_peak_limit_t pPeak;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesPowerGetLimitsRpcM() = default;

    ZesPowerGetLimitsRpcM(zes_pwr_handle_t hPower, zes_power_sustained_limit_t* pSustained, zes_power_burst_limit_t* pBurst, zes_power_peak_limit_t* pPeak) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hPower = hPower;
        args.pSustained = pSustained;
        args.pBurst = pBurst;
        args.pPeak = pPeak;
    }
    
    static void fillWithoutCapture(ZesPowerGetLimitsRpcM &message, zes_pwr_handle_t hPower, zes_power_sustained_limit_t* pSustained, zes_power_burst_limit_t* pBurst, zes_power_peak_limit_t* pPeak) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hPower = hPower;
        message.args.pSustained = pSustained;
        message.args.pBurst = pBurst;
        message.args.pPeak = pPeak;
    }
    

    void copyFromCaller(){
        if(args.pSustained){
            captures.pSustained = *args.pSustained;
        }
        if(args.pBurst){
            captures.pBurst = *args.pBurst;
        }
        if(args.pPeak){
            captures.pPeak = *args.pPeak;
        }
    }

    void copyToCaller(){
        if(args.pSustained){
            *args.pSustained = captures.pSustained;
        }
        if(args.pBurst){
            *args.pBurst = captures.pBurst;
        }
        if(args.pPeak){
            *args.pPeak = captures.pPeak;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesPowerGetLimitsRpcM>);
struct ZesPowerSetLimitsRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 7;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_pwr_handle_t hPower = {};
        const zes_power_sustained_limit_t* pSustained = {};
        const zes_power_burst_limit_t* pBurst = {};
        const zes_power_peak_limit_t* pPeak = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hPower == rhs.hPower;
            equal &= this->pSustained == rhs.pSustained;
            equal &= this->pBurst == rhs.pBurst;
            equal &= this->pPeak == rhs.pPeak;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        zes_power_sustained_limit_t pSustained;
        zes_power_burst_limit_t pBurst;
        zes_power_peak_limit_t pPeak;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesPowerSetLimitsRpcM() = default;

    ZesPowerSetLimitsRpcM(zes_pwr_handle_t hPower, const zes_power_sustained_limit_t* pSustained, const zes_power_burst_limit_t* pBurst, const zes_power_peak_limit_t* pPeak) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hPower = hPower;
        args.pSustained = pSustained;
        args.pBurst = pBurst;
        args.pPeak = pPeak;
    }
    
    static void fillWithoutCapture(ZesPowerSetLimitsRpcM &message, zes_pwr_handle_t hPower, const zes_power_sustained_limit_t* pSustained, const zes_power_burst_limit_t* pBurst, const zes_power_peak_limit_t* pPeak) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hPower = hPower;
        message.args.pSustained = pSustained;
        message.args.pBurst = pBurst;
        message.args.pPeak = pPeak;
    }
    

    void copyFromCaller(){
        if(args.pSustained){
            captures.pSustained = *args.pSustained;
        }
        if(args.pBurst){
            captures.pBurst = *args.pBurst;
        }
        if(args.pPeak){
            captures.pPeak = *args.pPeak;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesPowerSetLimitsRpcM>);
struct ZesPowerGetLimitsExtRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 8;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_pwr_handle_t hPower = {};
        uint32_t* pCount = {};
        zes_power_limit_ext_desc_t* pSustained = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hPower == rhs.hPower;
            equal &= this->pCount == rhs.pCount;
            equal &= this->pSustained == rhs.pSustained;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(zes_pwr_handle_t hPower, uint32_t* pCount, zes_power_limit_ext_desc_t* pSustained);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits pSustained = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        uint32_t pCount;
        uint32_t countPSustained = 0;
        zes_power_limit_ext_desc_t pSustained[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPSustained = dynamicTraits.pSustained.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesPowerGetLimitsExtRpcM() = default;

    ZesPowerGetLimitsExtRpcM(const Captures::DynamicTraits &dynamicTraits, zes_pwr_handle_t hPower, uint32_t* pCount, zes_power_limit_ext_desc_t* pSustained) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hPower = hPower;
        args.pCount = pCount;
        args.pSustained = pSustained;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZesPowerGetLimitsExtRpcM &message, zes_pwr_handle_t hPower, uint32_t* pCount, zes_power_limit_ext_desc_t* pSustained) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hPower = hPower;
        message.args.pCount = pCount;
        message.args.pSustained = pSustained;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            captures.pCount = *args.pCount;
        }
        if(args.pSustained){
            memcpy(asMemcpyDstT(captures.pSustained), args.pSustained, dynMemTraits.pSustained.size);
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            *args.pCount = captures.pCount;
        }
        if(args.pSustained){
            memcpy(args.pSustained, captures.pSustained, dynMemTraits.pSustained.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZesPowerGetLimitsExtRpcM>);
struct ZesPowerSetLimitsExtRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 9;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_pwr_handle_t hPower = {};
        uint32_t* pCount = {};
        zes_power_limit_ext_desc_t* pSustained = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hPower == rhs.hPower;
            equal &= this->pCount == rhs.pCount;
            equal &= this->pSustained == rhs.pSustained;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(zes_pwr_handle_t hPower, uint32_t* pCount, zes_power_limit_ext_desc_t* pSustained);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits pSustained = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        uint32_t pCount;
        uint32_t countPSustained = 0;
        zes_power_limit_ext_desc_t pSustained[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPSustained = dynamicTraits.pSustained.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesPowerSetLimitsExtRpcM() = default;

    ZesPowerSetLimitsExtRpcM(const Captures::DynamicTraits &dynamicTraits, zes_pwr_handle_t hPower, uint32_t* pCount, zes_power_limit_ext_desc_t* pSustained) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hPower = hPower;
        args.pCount = pCount;
        args.pSustained = pSustained;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZesPowerSetLimitsExtRpcM &message, zes_pwr_handle_t hPower, uint32_t* pCount, zes_power_limit_ext_desc_t* pSustained) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hPower = hPower;
        message.args.pCount = pCount;
        message.args.pSustained = pSustained;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            captures.pCount = *args.pCount;
        }
        if(args.pSustained){
            memcpy(asMemcpyDstT(captures.pSustained), args.pSustained, dynMemTraits.pSustained.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZesPowerSetLimitsExtRpcM>);
struct ZesPowerGetEnergyThresholdRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 10;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_pwr_handle_t hPower = {};
        zes_energy_threshold_t * pThreshold = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hPower == rhs.hPower;
            equal &= this->pThreshold == rhs.pThreshold;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        zes_energy_threshold_t pThreshold;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesPowerGetEnergyThresholdRpcM() = default;

    ZesPowerGetEnergyThresholdRpcM(zes_pwr_handle_t hPower, zes_energy_threshold_t * pThreshold) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hPower = hPower;
        args.pThreshold = pThreshold;
    }
    
    static void fillWithoutCapture(ZesPowerGetEnergyThresholdRpcM &message, zes_pwr_handle_t hPower, zes_energy_threshold_t * pThreshold) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hPower = hPower;
        message.args.pThreshold = pThreshold;
    }
    

    void copyFromCaller(){
        if(args.pThreshold){
            captures.pThreshold = *args.pThreshold;
        }
    }

    void copyToCaller(){
        if(args.pThreshold){
            *args.pThreshold = captures.pThreshold;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesPowerGetEnergyThresholdRpcM>);
struct ZesPowerSetEnergyThresholdRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 11;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_pwr_handle_t hPower = {};
        double pThreshold = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hPower == rhs.hPower;
            equal &= this->pThreshold == rhs.pThreshold;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesPowerSetEnergyThresholdRpcM() = default;

    ZesPowerSetEnergyThresholdRpcM(zes_pwr_handle_t hPower, double pThreshold) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hPower = hPower;
        args.pThreshold = pThreshold;
    }
    
    static void fillWithoutCapture(ZesPowerSetEnergyThresholdRpcM &message, zes_pwr_handle_t hPower, double pThreshold) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hPower = hPower;
        message.args.pThreshold = pThreshold;
    }
    
};
static_assert(std::is_standard_layout_v<ZesPowerSetEnergyThresholdRpcM>);
struct ZesDeviceEventRegisterRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 12;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_device_handle_t hDevice = {};
        zes_event_type_flags_t events = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->events == rhs.events;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesDeviceEventRegisterRpcM() = default;

    ZesDeviceEventRegisterRpcM(zes_device_handle_t hDevice, zes_event_type_flags_t events) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.events = events;
    }
    
    static void fillWithoutCapture(ZesDeviceEventRegisterRpcM &message, zes_device_handle_t hDevice, zes_event_type_flags_t events) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.events = events;
    }
    
};
static_assert(std::is_standard_layout_v<ZesDeviceEventRegisterRpcM>);
struct ZesDriverEventListenRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 13;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_driver_handle_t hDriver = {};
        uint32_t timeout = {};
        uint32_t count = {};
        ze_device_handle_t* phDevices = {};
        uint32_t* pNumDeviceEvents = {};
        zes_event_type_flags_t* pEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDriver == rhs.hDriver;
            equal &= this->timeout == rhs.timeout;
            equal &= this->count == rhs.count;
            equal &= this->phDevices == rhs.phDevices;
            equal &= this->pNumDeviceEvents == rhs.pNumDeviceEvents;
            equal &= this->pEvents == rhs.pEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_driver_handle_t hDriver, uint32_t timeout, uint32_t count, ze_device_handle_t* phDevices, uint32_t* pNumDeviceEvents, zes_event_type_flags_t* pEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phDevices = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        uint32_t pNumDeviceEvents;
        zes_event_type_flags_t pEvents;
        uint32_t countPhDevices = 0;
        zes_device_handle_t phDevices[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhDevices = dynamicTraits.phDevices.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesDriverEventListenRpcM() = default;

    ZesDriverEventListenRpcM(const Captures::DynamicTraits &dynamicTraits, ze_driver_handle_t hDriver, uint32_t timeout, uint32_t count, ze_device_handle_t* phDevices, uint32_t* pNumDeviceEvents, zes_event_type_flags_t* pEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDriver = hDriver;
        args.timeout = timeout;
        args.count = count;
        args.phDevices = phDevices;
        args.pNumDeviceEvents = pNumDeviceEvents;
        args.pEvents = pEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZesDriverEventListenRpcM &message, ze_driver_handle_t hDriver, uint32_t timeout, uint32_t count, ze_device_handle_t* phDevices, uint32_t* pNumDeviceEvents, zes_event_type_flags_t* pEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDriver = hDriver;
        message.args.timeout = timeout;
        message.args.count = count;
        message.args.phDevices = phDevices;
        message.args.pNumDeviceEvents = pNumDeviceEvents;
        message.args.pEvents = pEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phDevices){
            memcpy(asMemcpyDstT(captures.phDevices), args.phDevices, dynMemTraits.phDevices.size);
        }
        if(args.pNumDeviceEvents){
            captures.pNumDeviceEvents = *args.pNumDeviceEvents;
        }
        if(args.pEvents){
            captures.pEvents = *args.pEvents;
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pNumDeviceEvents){
            *args.pNumDeviceEvents = captures.pNumDeviceEvents;
        }
        if(args.pEvents){
            *args.pEvents = captures.pEvents;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesDriverEventListenRpcM>);
struct ZesDriverEventListenExRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 14;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_driver_handle_t hDriver = {};
        uint64_t timeout = {};
        uint32_t count = {};
        zes_device_handle_t* phDevices = {};
        uint32_t* pNumDeviceEvents = {};
        zes_event_type_flags_t* pEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDriver == rhs.hDriver;
            equal &= this->timeout == rhs.timeout;
            equal &= this->count == rhs.count;
            equal &= this->phDevices == rhs.phDevices;
            equal &= this->pNumDeviceEvents == rhs.pNumDeviceEvents;
            equal &= this->pEvents == rhs.pEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_driver_handle_t hDriver, uint64_t timeout, uint32_t count, zes_device_handle_t* phDevices, uint32_t* pNumDeviceEvents, zes_event_type_flags_t* pEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phDevices = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        uint32_t pNumDeviceEvents;
        zes_event_type_flags_t pEvents;
        uint32_t countPhDevices = 0;
        ze_device_handle_t phDevices[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhDevices = dynamicTraits.phDevices.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesDriverEventListenExRpcM() = default;

    ZesDriverEventListenExRpcM(const Captures::DynamicTraits &dynamicTraits, ze_driver_handle_t hDriver, uint64_t timeout, uint32_t count, zes_device_handle_t* phDevices, uint32_t* pNumDeviceEvents, zes_event_type_flags_t* pEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDriver = hDriver;
        args.timeout = timeout;
        args.count = count;
        args.phDevices = phDevices;
        args.pNumDeviceEvents = pNumDeviceEvents;
        args.pEvents = pEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZesDriverEventListenExRpcM &message, ze_driver_handle_t hDriver, uint64_t timeout, uint32_t count, zes_device_handle_t* phDevices, uint32_t* pNumDeviceEvents, zes_event_type_flags_t* pEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDriver = hDriver;
        message.args.timeout = timeout;
        message.args.count = count;
        message.args.phDevices = phDevices;
        message.args.pNumDeviceEvents = pNumDeviceEvents;
        message.args.pEvents = pEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phDevices){
            memcpy(asMemcpyDstT(captures.phDevices), args.phDevices, dynMemTraits.phDevices.size);
        }
        if(args.pNumDeviceEvents){
            captures.pNumDeviceEvents = *args.pNumDeviceEvents;
        }
        if(args.pEvents){
            captures.pEvents = *args.pEvents;
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pNumDeviceEvents){
            *args.pNumDeviceEvents = captures.pNumDeviceEvents;
        }
        if(args.pEvents){
            *args.pEvents = captures.pEvents;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesDriverEventListenExRpcM>);
struct ZesDeviceEnumTemperatureSensorsRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 15;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_device_handle_t hDevice = {};
        uint32_t* pCount = {};
        zes_temp_handle_t* phTemperature = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->pCount == rhs.pCount;
            equal &= this->phTemperature == rhs.phTemperature;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(zes_device_handle_t hDevice, uint32_t* pCount, zes_temp_handle_t* phTemperature);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phTemperature = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        uint32_t pCount;
        uint32_t countPhTemperature = 0;
        zes_temp_handle_t phTemperature[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhTemperature = dynamicTraits.phTemperature.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesDeviceEnumTemperatureSensorsRpcM() = default;

    ZesDeviceEnumTemperatureSensorsRpcM(const Captures::DynamicTraits &dynamicTraits, zes_device_handle_t hDevice, uint32_t* pCount, zes_temp_handle_t* phTemperature) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.pCount = pCount;
        args.phTemperature = phTemperature;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZesDeviceEnumTemperatureSensorsRpcM &message, zes_device_handle_t hDevice, uint32_t* pCount, zes_temp_handle_t* phTemperature) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.pCount = pCount;
        message.args.phTemperature = phTemperature;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            captures.pCount = *args.pCount;
        }
        if(args.phTemperature){
            memcpy(asMemcpyDstT(captures.phTemperature), args.phTemperature, dynMemTraits.phTemperature.size);
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            *args.pCount = captures.pCount;
        }
        if(args.phTemperature){
            memcpy(args.phTemperature, captures.phTemperature, dynMemTraits.phTemperature.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZesDeviceEnumTemperatureSensorsRpcM>);
struct ZesTemperatureGetPropertiesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 16;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_temp_handle_t hTemperature = {};
        zes_temp_properties_t* pProperties = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hTemperature == rhs.hTemperature;
            equal &= this->pProperties == rhs.pProperties;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        zes_temp_properties_t pProperties;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesTemperatureGetPropertiesRpcM() = default;

    ZesTemperatureGetPropertiesRpcM(zes_temp_handle_t hTemperature, zes_temp_properties_t* pProperties) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hTemperature = hTemperature;
        args.pProperties = pProperties;
    }
    
    static void fillWithoutCapture(ZesTemperatureGetPropertiesRpcM &message, zes_temp_handle_t hTemperature, zes_temp_properties_t* pProperties) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hTemperature = hTemperature;
        message.args.pProperties = pProperties;
    }
    

    void copyFromCaller(){
        if(args.pProperties){
            captures.pProperties = *args.pProperties;
        }
    }

    void copyToCaller(){
        if(args.pProperties){
            *args.pProperties = captures.pProperties;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesTemperatureGetPropertiesRpcM>);
struct ZesTemperatureGetConfigRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 17;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_temp_handle_t hTemperature = {};
        zes_temp_config_t * pConfig = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hTemperature == rhs.hTemperature;
            equal &= this->pConfig == rhs.pConfig;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        zes_temp_config_t pConfig;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesTemperatureGetConfigRpcM() = default;

    ZesTemperatureGetConfigRpcM(zes_temp_handle_t hTemperature, zes_temp_config_t * pConfig) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hTemperature = hTemperature;
        args.pConfig = pConfig;
    }
    
    static void fillWithoutCapture(ZesTemperatureGetConfigRpcM &message, zes_temp_handle_t hTemperature, zes_temp_config_t * pConfig) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hTemperature = hTemperature;
        message.args.pConfig = pConfig;
    }
    

    void copyFromCaller(){
        if(args.pConfig){
            captures.pConfig = *args.pConfig;
        }
    }

    void copyToCaller(){
        if(args.pConfig){
            *args.pConfig = captures.pConfig;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesTemperatureGetConfigRpcM>);
struct ZesTemperatureSetConfigRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 18;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_temp_handle_t hTemperature = {};
        const zes_temp_config_t* pConfig = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hTemperature == rhs.hTemperature;
            equal &= this->pConfig == rhs.pConfig;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        zes_temp_config_t pConfig;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesTemperatureSetConfigRpcM() = default;

    ZesTemperatureSetConfigRpcM(zes_temp_handle_t hTemperature, const zes_temp_config_t* pConfig) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hTemperature = hTemperature;
        args.pConfig = pConfig;
    }
    
    static void fillWithoutCapture(ZesTemperatureSetConfigRpcM &message, zes_temp_handle_t hTemperature, const zes_temp_config_t* pConfig) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hTemperature = hTemperature;
        message.args.pConfig = pConfig;
    }
    

    void copyFromCaller(){
        if(args.pConfig){
            captures.pConfig = *args.pConfig;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesTemperatureSetConfigRpcM>);
struct ZesTemperatureGetStateRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 19;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_temp_handle_t hTemperature = {};
        double* pTemperature = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hTemperature == rhs.hTemperature;
            equal &= this->pTemperature == rhs.pTemperature;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        double pTemperature;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesTemperatureGetStateRpcM() = default;

    ZesTemperatureGetStateRpcM(zes_temp_handle_t hTemperature, double* pTemperature) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hTemperature = hTemperature;
        args.pTemperature = pTemperature;
    }
    
    static void fillWithoutCapture(ZesTemperatureGetStateRpcM &message, zes_temp_handle_t hTemperature, double* pTemperature) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hTemperature = hTemperature;
        message.args.pTemperature = pTemperature;
    }
    

    void copyFromCaller(){
        if(args.pTemperature){
            captures.pTemperature = *args.pTemperature;
        }
    }

    void copyToCaller(){
        if(args.pTemperature){
            *args.pTemperature = captures.pTemperature;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesTemperatureGetStateRpcM>);
struct ZesDeviceEnumRasErrorSetsRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 20;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_device_handle_t hDevice = {};
        uint32_t* pCount = {};
        zes_ras_handle_t* phRas = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->pCount == rhs.pCount;
            equal &= this->phRas == rhs.phRas;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(zes_device_handle_t hDevice, uint32_t* pCount, zes_ras_handle_t* phRas);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phRas = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        uint32_t pCount;
        uint32_t countPhRas = 0;
        zes_ras_handle_t phRas[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhRas = dynamicTraits.phRas.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesDeviceEnumRasErrorSetsRpcM() = default;

    ZesDeviceEnumRasErrorSetsRpcM(const Captures::DynamicTraits &dynamicTraits, zes_device_handle_t hDevice, uint32_t* pCount, zes_ras_handle_t* phRas) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.pCount = pCount;
        args.phRas = phRas;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZesDeviceEnumRasErrorSetsRpcM &message, zes_device_handle_t hDevice, uint32_t* pCount, zes_ras_handle_t* phRas) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.pCount = pCount;
        message.args.phRas = phRas;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            captures.pCount = *args.pCount;
        }
        if(args.phRas){
            memcpy(asMemcpyDstT(captures.phRas), args.phRas, dynMemTraits.phRas.size);
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            *args.pCount = captures.pCount;
        }
        if(args.phRas){
            memcpy(args.phRas, captures.phRas, dynMemTraits.phRas.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZesDeviceEnumRasErrorSetsRpcM>);
struct ZesRasGetPropertiesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 21;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_ras_handle_t hRas = {};
        zes_ras_properties_t* pProperties = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hRas == rhs.hRas;
            equal &= this->pProperties == rhs.pProperties;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        zes_ras_properties_t pProperties;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesRasGetPropertiesRpcM() = default;

    ZesRasGetPropertiesRpcM(zes_ras_handle_t hRas, zes_ras_properties_t* pProperties) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hRas = hRas;
        args.pProperties = pProperties;
    }
    
    static void fillWithoutCapture(ZesRasGetPropertiesRpcM &message, zes_ras_handle_t hRas, zes_ras_properties_t* pProperties) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hRas = hRas;
        message.args.pProperties = pProperties;
    }
    

    void copyFromCaller(){
        if(args.pProperties){
            captures.pProperties = *args.pProperties;
        }
    }

    void copyToCaller(){
        if(args.pProperties){
            *args.pProperties = captures.pProperties;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesRasGetPropertiesRpcM>);
struct ZesRasGetConfigRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 22;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_ras_handle_t hRas = {};
        zes_ras_config_t * pConfig = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hRas == rhs.hRas;
            equal &= this->pConfig == rhs.pConfig;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        zes_ras_config_t pConfig;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesRasGetConfigRpcM() = default;

    ZesRasGetConfigRpcM(zes_ras_handle_t hRas, zes_ras_config_t * pConfig) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hRas = hRas;
        args.pConfig = pConfig;
    }
    
    static void fillWithoutCapture(ZesRasGetConfigRpcM &message, zes_ras_handle_t hRas, zes_ras_config_t * pConfig) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hRas = hRas;
        message.args.pConfig = pConfig;
    }
    

    void copyFromCaller(){
        if(args.pConfig){
            captures.pConfig = *args.pConfig;
        }
    }

    void copyToCaller(){
        if(args.pConfig){
            *args.pConfig = captures.pConfig;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesRasGetConfigRpcM>);
struct ZesRasSetConfigRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 23;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_ras_handle_t hRas = {};
        const zes_ras_config_t* pConfig = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hRas == rhs.hRas;
            equal &= this->pConfig == rhs.pConfig;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        zes_ras_config_t pConfig;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesRasSetConfigRpcM() = default;

    ZesRasSetConfigRpcM(zes_ras_handle_t hRas, const zes_ras_config_t* pConfig) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hRas = hRas;
        args.pConfig = pConfig;
    }
    
    static void fillWithoutCapture(ZesRasSetConfigRpcM &message, zes_ras_handle_t hRas, const zes_ras_config_t* pConfig) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hRas = hRas;
        message.args.pConfig = pConfig;
    }
    

    void copyFromCaller(){
        if(args.pConfig){
            captures.pConfig = *args.pConfig;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesRasSetConfigRpcM>);
struct ZesRasGetStateRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 24;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_ras_handle_t hRas = {};
        ze_bool_t clear = {};
        zes_ras_state_t* pState = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hRas == rhs.hRas;
            equal &= this->clear == rhs.clear;
            equal &= this->pState == rhs.pState;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesRasGetStateRpcM() = default;

    ZesRasGetStateRpcM(zes_ras_handle_t hRas, ze_bool_t clear, zes_ras_state_t* pState) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hRas = hRas;
        args.clear = clear;
        args.pState = pState;
    }
    
    static void fillWithoutCapture(ZesRasGetStateRpcM &message, zes_ras_handle_t hRas, ze_bool_t clear, zes_ras_state_t* pState) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hRas = hRas;
        message.args.clear = clear;
        message.args.pState = pState;
    }
    
};
static_assert(std::is_standard_layout_v<ZesRasGetStateRpcM>);
struct ZesDeviceEnumFrequencyDomainsRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 25;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_device_handle_t hDevice = {};
        uint32_t* pCount = {};
        zes_freq_handle_t* phFrequency = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->pCount == rhs.pCount;
            equal &= this->phFrequency == rhs.phFrequency;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(zes_device_handle_t hDevice, uint32_t* pCount, zes_freq_handle_t* phFrequency);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phFrequency = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        uint32_t pCount;
        uint32_t countPhFrequency = 0;
        zes_freq_handle_t phFrequency[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhFrequency = dynamicTraits.phFrequency.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesDeviceEnumFrequencyDomainsRpcM() = default;

    ZesDeviceEnumFrequencyDomainsRpcM(const Captures::DynamicTraits &dynamicTraits, zes_device_handle_t hDevice, uint32_t* pCount, zes_freq_handle_t* phFrequency) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.pCount = pCount;
        args.phFrequency = phFrequency;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZesDeviceEnumFrequencyDomainsRpcM &message, zes_device_handle_t hDevice, uint32_t* pCount, zes_freq_handle_t* phFrequency) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.pCount = pCount;
        message.args.phFrequency = phFrequency;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            captures.pCount = *args.pCount;
        }
        if(args.phFrequency){
            memcpy(asMemcpyDstT(captures.phFrequency), args.phFrequency, dynMemTraits.phFrequency.size);
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            *args.pCount = captures.pCount;
        }
        if(args.phFrequency){
            memcpy(args.phFrequency, captures.phFrequency, dynMemTraits.phFrequency.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZesDeviceEnumFrequencyDomainsRpcM>);
struct ZesFrequencyGetPropertiesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 26;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_freq_handle_t hFrequency = {};
        zes_freq_properties_t* pProperties = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hFrequency == rhs.hFrequency;
            equal &= this->pProperties == rhs.pProperties;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        zes_freq_properties_t pProperties;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesFrequencyGetPropertiesRpcM() = default;

    ZesFrequencyGetPropertiesRpcM(zes_freq_handle_t hFrequency, zes_freq_properties_t* pProperties) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hFrequency = hFrequency;
        args.pProperties = pProperties;
    }
    
    static void fillWithoutCapture(ZesFrequencyGetPropertiesRpcM &message, zes_freq_handle_t hFrequency, zes_freq_properties_t* pProperties) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hFrequency = hFrequency;
        message.args.pProperties = pProperties;
    }
    

    void copyFromCaller(){
        if(args.pProperties){
            captures.pProperties = *args.pProperties;
        }
    }

    void copyToCaller(){
        if(args.pProperties){
            *args.pProperties = captures.pProperties;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesFrequencyGetPropertiesRpcM>);
struct ZesFrequencyGetAvailableClocksRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 27;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_freq_handle_t hFrequency = {};
        uint32_t* pCount = {};
        double* phFrequency = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hFrequency == rhs.hFrequency;
            equal &= this->pCount == rhs.pCount;
            equal &= this->phFrequency == rhs.phFrequency;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(zes_freq_handle_t hFrequency, uint32_t* pCount, double* phFrequency);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phFrequency = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        uint32_t pCount;
        uint32_t countPhFrequency = 0;
        double phFrequency[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhFrequency = dynamicTraits.phFrequency.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesFrequencyGetAvailableClocksRpcM() = default;

    ZesFrequencyGetAvailableClocksRpcM(const Captures::DynamicTraits &dynamicTraits, zes_freq_handle_t hFrequency, uint32_t* pCount, double* phFrequency) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hFrequency = hFrequency;
        args.pCount = pCount;
        args.phFrequency = phFrequency;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZesFrequencyGetAvailableClocksRpcM &message, zes_freq_handle_t hFrequency, uint32_t* pCount, double* phFrequency) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hFrequency = hFrequency;
        message.args.pCount = pCount;
        message.args.phFrequency = phFrequency;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            captures.pCount = *args.pCount;
        }
        if(args.phFrequency){
            memcpy(asMemcpyDstT(captures.phFrequency), args.phFrequency, dynMemTraits.phFrequency.size);
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            *args.pCount = captures.pCount;
        }
        if(args.phFrequency){
            memcpy(args.phFrequency, captures.phFrequency, dynMemTraits.phFrequency.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZesFrequencyGetAvailableClocksRpcM>);
struct ZesFrequencyGetRangeRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 28;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_freq_handle_t hFrequency = {};
        zes_freq_range_t* pConfig = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hFrequency == rhs.hFrequency;
            equal &= this->pConfig == rhs.pConfig;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        zes_freq_range_t pConfig;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesFrequencyGetRangeRpcM() = default;

    ZesFrequencyGetRangeRpcM(zes_freq_handle_t hFrequency, zes_freq_range_t* pConfig) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hFrequency = hFrequency;
        args.pConfig = pConfig;
    }
    
    static void fillWithoutCapture(ZesFrequencyGetRangeRpcM &message, zes_freq_handle_t hFrequency, zes_freq_range_t* pConfig) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hFrequency = hFrequency;
        message.args.pConfig = pConfig;
    }
    

    void copyFromCaller(){
        if(args.pConfig){
            captures.pConfig = *args.pConfig;
        }
    }

    void copyToCaller(){
        if(args.pConfig){
            *args.pConfig = captures.pConfig;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesFrequencyGetRangeRpcM>);
struct ZesFrequencySetRangeRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 29;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_freq_handle_t hFrequency = {};
        const zes_freq_range_t* pLimits = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hFrequency == rhs.hFrequency;
            equal &= this->pLimits == rhs.pLimits;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        zes_freq_range_t pLimits;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesFrequencySetRangeRpcM() = default;

    ZesFrequencySetRangeRpcM(zes_freq_handle_t hFrequency, const zes_freq_range_t* pLimits) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hFrequency = hFrequency;
        args.pLimits = pLimits;
    }
    
    static void fillWithoutCapture(ZesFrequencySetRangeRpcM &message, zes_freq_handle_t hFrequency, const zes_freq_range_t* pLimits) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hFrequency = hFrequency;
        message.args.pLimits = pLimits;
    }
    

    void copyFromCaller(){
        if(args.pLimits){
            captures.pLimits = *args.pLimits;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesFrequencySetRangeRpcM>);
struct ZesFrequencyGetStateRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 30;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_freq_handle_t hFrequency = {};
        zes_freq_state_t* pState = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hFrequency == rhs.hFrequency;
            equal &= this->pState == rhs.pState;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        zes_freq_state_t pState;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesFrequencyGetStateRpcM() = default;

    ZesFrequencyGetStateRpcM(zes_freq_handle_t hFrequency, zes_freq_state_t* pState) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hFrequency = hFrequency;
        args.pState = pState;
    }
    
    static void fillWithoutCapture(ZesFrequencyGetStateRpcM &message, zes_freq_handle_t hFrequency, zes_freq_state_t* pState) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hFrequency = hFrequency;
        message.args.pState = pState;
    }
    

    void copyFromCaller(){
        if(args.pState){
            captures.pState = *args.pState;
        }
    }

    void copyToCaller(){
        if(args.pState){
            *args.pState = captures.pState;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesFrequencyGetStateRpcM>);
struct ZesFrequencyGetThrottleTimeRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 31;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_freq_handle_t hFrequency = {};
        zes_freq_throttle_time_t* pThrottleTime = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hFrequency == rhs.hFrequency;
            equal &= this->pThrottleTime == rhs.pThrottleTime;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        zes_freq_throttle_time_t pThrottleTime;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesFrequencyGetThrottleTimeRpcM() = default;

    ZesFrequencyGetThrottleTimeRpcM(zes_freq_handle_t hFrequency, zes_freq_throttle_time_t* pThrottleTime) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hFrequency = hFrequency;
        args.pThrottleTime = pThrottleTime;
    }
    
    static void fillWithoutCapture(ZesFrequencyGetThrottleTimeRpcM &message, zes_freq_handle_t hFrequency, zes_freq_throttle_time_t* pThrottleTime) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hFrequency = hFrequency;
        message.args.pThrottleTime = pThrottleTime;
    }
    

    void copyFromCaller(){
        if(args.pThrottleTime){
            captures.pThrottleTime = *args.pThrottleTime;
        }
    }

    void copyToCaller(){
        if(args.pThrottleTime){
            *args.pThrottleTime = captures.pThrottleTime;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesFrequencyGetThrottleTimeRpcM>);
struct ZesFrequencyOcGetCapabilitiesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 32;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_freq_handle_t hFrequency = {};
        zes_oc_capabilities_t* pOcCapabilities = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hFrequency == rhs.hFrequency;
            equal &= this->pOcCapabilities == rhs.pOcCapabilities;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        zes_oc_capabilities_t pOcCapabilities;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesFrequencyOcGetCapabilitiesRpcM() = default;

    ZesFrequencyOcGetCapabilitiesRpcM(zes_freq_handle_t hFrequency, zes_oc_capabilities_t* pOcCapabilities) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hFrequency = hFrequency;
        args.pOcCapabilities = pOcCapabilities;
    }
    
    static void fillWithoutCapture(ZesFrequencyOcGetCapabilitiesRpcM &message, zes_freq_handle_t hFrequency, zes_oc_capabilities_t* pOcCapabilities) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hFrequency = hFrequency;
        message.args.pOcCapabilities = pOcCapabilities;
    }
    

    void copyFromCaller(){
        if(args.pOcCapabilities){
            captures.pOcCapabilities = *args.pOcCapabilities;
        }
    }

    void copyToCaller(){
        if(args.pOcCapabilities){
            *args.pOcCapabilities = captures.pOcCapabilities;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesFrequencyOcGetCapabilitiesRpcM>);
struct ZesFrequencyOcGetVoltageTargetRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 33;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_freq_handle_t hFrequency = {};
        double* pCurrentVoltageTarget = {};
        double* pCurrentVoltageOffset = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hFrequency == rhs.hFrequency;
            equal &= this->pCurrentVoltageTarget == rhs.pCurrentVoltageTarget;
            equal &= this->pCurrentVoltageOffset == rhs.pCurrentVoltageOffset;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesFrequencyOcGetVoltageTargetRpcM() = default;

    ZesFrequencyOcGetVoltageTargetRpcM(zes_freq_handle_t hFrequency, double* pCurrentVoltageTarget, double* pCurrentVoltageOffset) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hFrequency = hFrequency;
        args.pCurrentVoltageTarget = pCurrentVoltageTarget;
        args.pCurrentVoltageOffset = pCurrentVoltageOffset;
    }
    
    static void fillWithoutCapture(ZesFrequencyOcGetVoltageTargetRpcM &message, zes_freq_handle_t hFrequency, double* pCurrentVoltageTarget, double* pCurrentVoltageOffset) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hFrequency = hFrequency;
        message.args.pCurrentVoltageTarget = pCurrentVoltageTarget;
        message.args.pCurrentVoltageOffset = pCurrentVoltageOffset;
    }
    
};
static_assert(std::is_standard_layout_v<ZesFrequencyOcGetVoltageTargetRpcM>);
struct ZesFrequencyOcSetVoltageTargetRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 34;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_freq_handle_t hFrequency = {};
        double CurrentVoltageTarget = {};
        double CurrentVoltageOffset = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hFrequency == rhs.hFrequency;
            equal &= this->CurrentVoltageTarget == rhs.CurrentVoltageTarget;
            equal &= this->CurrentVoltageOffset == rhs.CurrentVoltageOffset;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesFrequencyOcSetVoltageTargetRpcM() = default;

    ZesFrequencyOcSetVoltageTargetRpcM(zes_freq_handle_t hFrequency, double CurrentVoltageTarget, double CurrentVoltageOffset) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hFrequency = hFrequency;
        args.CurrentVoltageTarget = CurrentVoltageTarget;
        args.CurrentVoltageOffset = CurrentVoltageOffset;
    }
    
    static void fillWithoutCapture(ZesFrequencyOcSetVoltageTargetRpcM &message, zes_freq_handle_t hFrequency, double CurrentVoltageTarget, double CurrentVoltageOffset) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hFrequency = hFrequency;
        message.args.CurrentVoltageTarget = CurrentVoltageTarget;
        message.args.CurrentVoltageOffset = CurrentVoltageOffset;
    }
    
};
static_assert(std::is_standard_layout_v<ZesFrequencyOcSetVoltageTargetRpcM>);
struct ZesFrequencyOcSetModeRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 35;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_freq_handle_t hFrequency = {};
        zes_oc_mode_t CurrentOcMode = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hFrequency == rhs.hFrequency;
            equal &= this->CurrentOcMode == rhs.CurrentOcMode;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesFrequencyOcSetModeRpcM() = default;

    ZesFrequencyOcSetModeRpcM(zes_freq_handle_t hFrequency, zes_oc_mode_t CurrentOcMode) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hFrequency = hFrequency;
        args.CurrentOcMode = CurrentOcMode;
    }
    
    static void fillWithoutCapture(ZesFrequencyOcSetModeRpcM &message, zes_freq_handle_t hFrequency, zes_oc_mode_t CurrentOcMode) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hFrequency = hFrequency;
        message.args.CurrentOcMode = CurrentOcMode;
    }
    
};
static_assert(std::is_standard_layout_v<ZesFrequencyOcSetModeRpcM>);
struct ZesFrequencyOcGetModeRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 36;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_freq_handle_t hFrequency = {};
        zes_oc_mode_t* pCurrentOcMode = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hFrequency == rhs.hFrequency;
            equal &= this->pCurrentOcMode == rhs.pCurrentOcMode;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesFrequencyOcGetModeRpcM() = default;

    ZesFrequencyOcGetModeRpcM(zes_freq_handle_t hFrequency, zes_oc_mode_t* pCurrentOcMode) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hFrequency = hFrequency;
        args.pCurrentOcMode = pCurrentOcMode;
    }
    
    static void fillWithoutCapture(ZesFrequencyOcGetModeRpcM &message, zes_freq_handle_t hFrequency, zes_oc_mode_t* pCurrentOcMode) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hFrequency = hFrequency;
        message.args.pCurrentOcMode = pCurrentOcMode;
    }
    
};
static_assert(std::is_standard_layout_v<ZesFrequencyOcGetModeRpcM>);
struct ZesFrequencyOcGetIccMaxRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 37;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_freq_handle_t hFrequency = {};
        double* pOcIccMax = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hFrequency == rhs.hFrequency;
            equal &= this->pOcIccMax == rhs.pOcIccMax;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesFrequencyOcGetIccMaxRpcM() = default;

    ZesFrequencyOcGetIccMaxRpcM(zes_freq_handle_t hFrequency, double* pOcIccMax) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hFrequency = hFrequency;
        args.pOcIccMax = pOcIccMax;
    }
    
    static void fillWithoutCapture(ZesFrequencyOcGetIccMaxRpcM &message, zes_freq_handle_t hFrequency, double* pOcIccMax) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hFrequency = hFrequency;
        message.args.pOcIccMax = pOcIccMax;
    }
    
};
static_assert(std::is_standard_layout_v<ZesFrequencyOcGetIccMaxRpcM>);
struct ZesFrequencyOcSetIccMaxRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 38;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_freq_handle_t hFrequency = {};
        double ocIccMax = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hFrequency == rhs.hFrequency;
            equal &= this->ocIccMax == rhs.ocIccMax;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesFrequencyOcSetIccMaxRpcM() = default;

    ZesFrequencyOcSetIccMaxRpcM(zes_freq_handle_t hFrequency, double ocIccMax) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hFrequency = hFrequency;
        args.ocIccMax = ocIccMax;
    }
    
    static void fillWithoutCapture(ZesFrequencyOcSetIccMaxRpcM &message, zes_freq_handle_t hFrequency, double ocIccMax) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hFrequency = hFrequency;
        message.args.ocIccMax = ocIccMax;
    }
    
};
static_assert(std::is_standard_layout_v<ZesFrequencyOcSetIccMaxRpcM>);
struct ZesFrequencyOcGetTjMaxRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 39;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_freq_handle_t hFrequency = {};
        double* pOcTjMax = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hFrequency == rhs.hFrequency;
            equal &= this->pOcTjMax == rhs.pOcTjMax;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesFrequencyOcGetTjMaxRpcM() = default;

    ZesFrequencyOcGetTjMaxRpcM(zes_freq_handle_t hFrequency, double* pOcTjMax) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hFrequency = hFrequency;
        args.pOcTjMax = pOcTjMax;
    }
    
    static void fillWithoutCapture(ZesFrequencyOcGetTjMaxRpcM &message, zes_freq_handle_t hFrequency, double* pOcTjMax) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hFrequency = hFrequency;
        message.args.pOcTjMax = pOcTjMax;
    }
    
};
static_assert(std::is_standard_layout_v<ZesFrequencyOcGetTjMaxRpcM>);
struct ZesFrequencyOcSetTjMaxRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 40;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_freq_handle_t hFrequency = {};
        double ocTjMax = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hFrequency == rhs.hFrequency;
            equal &= this->ocTjMax == rhs.ocTjMax;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesFrequencyOcSetTjMaxRpcM() = default;

    ZesFrequencyOcSetTjMaxRpcM(zes_freq_handle_t hFrequency, double ocTjMax) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hFrequency = hFrequency;
        args.ocTjMax = ocTjMax;
    }
    
    static void fillWithoutCapture(ZesFrequencyOcSetTjMaxRpcM &message, zes_freq_handle_t hFrequency, double ocTjMax) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hFrequency = hFrequency;
        message.args.ocTjMax = ocTjMax;
    }
    
};
static_assert(std::is_standard_layout_v<ZesFrequencyOcSetTjMaxRpcM>);
struct ZesDeviceEnumEngineGroupsRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 41;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_device_handle_t hDevice = {};
        uint32_t* pCount = {};
        zes_engine_handle_t* phEngine = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->pCount == rhs.pCount;
            equal &= this->phEngine == rhs.phEngine;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(zes_device_handle_t hDevice, uint32_t* pCount, zes_engine_handle_t* phEngine);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phEngine = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        uint32_t pCount;
        uint32_t countPhEngine = 0;
        zes_engine_handle_t phEngine[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhEngine = dynamicTraits.phEngine.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesDeviceEnumEngineGroupsRpcM() = default;

    ZesDeviceEnumEngineGroupsRpcM(const Captures::DynamicTraits &dynamicTraits, zes_device_handle_t hDevice, uint32_t* pCount, zes_engine_handle_t* phEngine) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.pCount = pCount;
        args.phEngine = phEngine;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZesDeviceEnumEngineGroupsRpcM &message, zes_device_handle_t hDevice, uint32_t* pCount, zes_engine_handle_t* phEngine) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.pCount = pCount;
        message.args.phEngine = phEngine;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            captures.pCount = *args.pCount;
        }
        if(args.phEngine){
            memcpy(asMemcpyDstT(captures.phEngine), args.phEngine, dynMemTraits.phEngine.size);
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            *args.pCount = captures.pCount;
        }
        if(args.phEngine){
            memcpy(args.phEngine, captures.phEngine, dynMemTraits.phEngine.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZesDeviceEnumEngineGroupsRpcM>);
struct ZesDeviceEnumSchedulersRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 42;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_device_handle_t hDevice = {};
        uint32_t* pCount = {};
        zes_sched_handle_t* phScheduler = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->pCount == rhs.pCount;
            equal &= this->phScheduler == rhs.phScheduler;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(zes_device_handle_t hDevice, uint32_t* pCount, zes_sched_handle_t* phScheduler);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phScheduler = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        uint32_t pCount;
        uint32_t countPhScheduler = 0;
        zes_sched_handle_t phScheduler[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhScheduler = dynamicTraits.phScheduler.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesDeviceEnumSchedulersRpcM() = default;

    ZesDeviceEnumSchedulersRpcM(const Captures::DynamicTraits &dynamicTraits, zes_device_handle_t hDevice, uint32_t* pCount, zes_sched_handle_t* phScheduler) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.pCount = pCount;
        args.phScheduler = phScheduler;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZesDeviceEnumSchedulersRpcM &message, zes_device_handle_t hDevice, uint32_t* pCount, zes_sched_handle_t* phScheduler) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.pCount = pCount;
        message.args.phScheduler = phScheduler;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            captures.pCount = *args.pCount;
        }
        if(args.phScheduler){
            memcpy(asMemcpyDstT(captures.phScheduler), args.phScheduler, dynMemTraits.phScheduler.size);
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            *args.pCount = captures.pCount;
        }
        if(args.phScheduler){
            memcpy(args.phScheduler, captures.phScheduler, dynMemTraits.phScheduler.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZesDeviceEnumSchedulersRpcM>);
struct ZesSchedulerGetPropertiesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 43;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_sched_handle_t hScheduler = {};
        zes_sched_properties_t* pProperties = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hScheduler == rhs.hScheduler;
            equal &= this->pProperties == rhs.pProperties;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        zes_sched_properties_t pProperties;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesSchedulerGetPropertiesRpcM() = default;

    ZesSchedulerGetPropertiesRpcM(zes_sched_handle_t hScheduler, zes_sched_properties_t* pProperties) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hScheduler = hScheduler;
        args.pProperties = pProperties;
    }
    
    static void fillWithoutCapture(ZesSchedulerGetPropertiesRpcM &message, zes_sched_handle_t hScheduler, zes_sched_properties_t* pProperties) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hScheduler = hScheduler;
        message.args.pProperties = pProperties;
    }
    

    void copyFromCaller(){
        if(args.pProperties){
            captures.pProperties = *args.pProperties;
        }
    }

    void copyToCaller(){
        if(args.pProperties){
            *args.pProperties = captures.pProperties;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesSchedulerGetPropertiesRpcM>);
struct ZesSchedulerGetCurrentModeRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 44;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_sched_handle_t hScheduler = {};
        zes_sched_mode_t* pMode = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hScheduler == rhs.hScheduler;
            equal &= this->pMode == rhs.pMode;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        zes_sched_mode_t pMode;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesSchedulerGetCurrentModeRpcM() = default;

    ZesSchedulerGetCurrentModeRpcM(zes_sched_handle_t hScheduler, zes_sched_mode_t* pMode) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hScheduler = hScheduler;
        args.pMode = pMode;
    }
    
    static void fillWithoutCapture(ZesSchedulerGetCurrentModeRpcM &message, zes_sched_handle_t hScheduler, zes_sched_mode_t* pMode) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hScheduler = hScheduler;
        message.args.pMode = pMode;
    }
    

    void copyFromCaller(){
        if(args.pMode){
            captures.pMode = *args.pMode;
        }
    }

    void copyToCaller(){
        if(args.pMode){
            *args.pMode = captures.pMode;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesSchedulerGetCurrentModeRpcM>);
struct ZesSchedulerGetTimeoutModePropertiesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 45;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_sched_handle_t hScheduler = {};
        ze_bool_t getDefaults = {};
        zes_sched_timeout_properties_t* pConfig = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hScheduler == rhs.hScheduler;
            equal &= this->getDefaults == rhs.getDefaults;
            equal &= this->pConfig == rhs.pConfig;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        zes_sched_timeout_properties_t pConfig;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesSchedulerGetTimeoutModePropertiesRpcM() = default;

    ZesSchedulerGetTimeoutModePropertiesRpcM(zes_sched_handle_t hScheduler, ze_bool_t getDefaults, zes_sched_timeout_properties_t* pConfig) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hScheduler = hScheduler;
        args.getDefaults = getDefaults;
        args.pConfig = pConfig;
    }
    
    static void fillWithoutCapture(ZesSchedulerGetTimeoutModePropertiesRpcM &message, zes_sched_handle_t hScheduler, ze_bool_t getDefaults, zes_sched_timeout_properties_t* pConfig) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hScheduler = hScheduler;
        message.args.getDefaults = getDefaults;
        message.args.pConfig = pConfig;
    }
    

    void copyFromCaller(){
        if(args.pConfig){
            captures.pConfig = *args.pConfig;
        }
    }

    void copyToCaller(){
        if(args.pConfig){
            *args.pConfig = captures.pConfig;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesSchedulerGetTimeoutModePropertiesRpcM>);
struct ZesSchedulerGetTimesliceModePropertiesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 46;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_sched_handle_t hScheduler = {};
        ze_bool_t getDefaults = {};
        zes_sched_timeslice_properties_t* pConfig = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hScheduler == rhs.hScheduler;
            equal &= this->getDefaults == rhs.getDefaults;
            equal &= this->pConfig == rhs.pConfig;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        zes_sched_timeslice_properties_t pConfig;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesSchedulerGetTimesliceModePropertiesRpcM() = default;

    ZesSchedulerGetTimesliceModePropertiesRpcM(zes_sched_handle_t hScheduler, ze_bool_t getDefaults, zes_sched_timeslice_properties_t* pConfig) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hScheduler = hScheduler;
        args.getDefaults = getDefaults;
        args.pConfig = pConfig;
    }
    
    static void fillWithoutCapture(ZesSchedulerGetTimesliceModePropertiesRpcM &message, zes_sched_handle_t hScheduler, ze_bool_t getDefaults, zes_sched_timeslice_properties_t* pConfig) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hScheduler = hScheduler;
        message.args.getDefaults = getDefaults;
        message.args.pConfig = pConfig;
    }
    

    void copyFromCaller(){
        if(args.pConfig){
            captures.pConfig = *args.pConfig;
        }
    }

    void copyToCaller(){
        if(args.pConfig){
            *args.pConfig = captures.pConfig;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesSchedulerGetTimesliceModePropertiesRpcM>);
struct ZesSchedulerSetTimeoutModeRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 47;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_sched_handle_t hScheduler = {};
        zes_sched_timeout_properties_t* pProperties = {};
        ze_bool_t* pNeedReload = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hScheduler == rhs.hScheduler;
            equal &= this->pProperties == rhs.pProperties;
            equal &= this->pNeedReload == rhs.pNeedReload;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        zes_sched_timeout_properties_t pProperties;
        ze_bool_t pNeedReload;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesSchedulerSetTimeoutModeRpcM() = default;

    ZesSchedulerSetTimeoutModeRpcM(zes_sched_handle_t hScheduler, zes_sched_timeout_properties_t* pProperties, ze_bool_t* pNeedReload) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hScheduler = hScheduler;
        args.pProperties = pProperties;
        args.pNeedReload = pNeedReload;
    }
    
    static void fillWithoutCapture(ZesSchedulerSetTimeoutModeRpcM &message, zes_sched_handle_t hScheduler, zes_sched_timeout_properties_t* pProperties, ze_bool_t* pNeedReload) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hScheduler = hScheduler;
        message.args.pProperties = pProperties;
        message.args.pNeedReload = pNeedReload;
    }
    

    void copyFromCaller(){
        if(args.pProperties){
            captures.pProperties = *args.pProperties;
        }
        if(args.pNeedReload){
            captures.pNeedReload = *args.pNeedReload;
        }
    }

    void copyToCaller(){
        if(args.pNeedReload){
            *args.pNeedReload = captures.pNeedReload;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesSchedulerSetTimeoutModeRpcM>);
struct ZesSchedulerSetTimesliceModeRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 48;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_sched_handle_t hScheduler = {};
        zes_sched_timeslice_properties_t* pProperties = {};
        ze_bool_t* pNeedReload = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hScheduler == rhs.hScheduler;
            equal &= this->pProperties == rhs.pProperties;
            equal &= this->pNeedReload == rhs.pNeedReload;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        zes_sched_timeslice_properties_t pProperties;
        ze_bool_t pNeedReload;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesSchedulerSetTimesliceModeRpcM() = default;

    ZesSchedulerSetTimesliceModeRpcM(zes_sched_handle_t hScheduler, zes_sched_timeslice_properties_t* pProperties, ze_bool_t* pNeedReload) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hScheduler = hScheduler;
        args.pProperties = pProperties;
        args.pNeedReload = pNeedReload;
    }
    
    static void fillWithoutCapture(ZesSchedulerSetTimesliceModeRpcM &message, zes_sched_handle_t hScheduler, zes_sched_timeslice_properties_t* pProperties, ze_bool_t* pNeedReload) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hScheduler = hScheduler;
        message.args.pProperties = pProperties;
        message.args.pNeedReload = pNeedReload;
    }
    

    void copyFromCaller(){
        if(args.pProperties){
            captures.pProperties = *args.pProperties;
        }
        if(args.pNeedReload){
            captures.pNeedReload = *args.pNeedReload;
        }
    }

    void copyToCaller(){
        if(args.pNeedReload){
            *args.pNeedReload = captures.pNeedReload;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesSchedulerSetTimesliceModeRpcM>);
struct ZesSchedulerSetExclusiveModeRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 49;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_sched_handle_t hScheduler = {};
        ze_bool_t* pNeedReload = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hScheduler == rhs.hScheduler;
            equal &= this->pNeedReload == rhs.pNeedReload;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        ze_bool_t pNeedReload;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesSchedulerSetExclusiveModeRpcM() = default;

    ZesSchedulerSetExclusiveModeRpcM(zes_sched_handle_t hScheduler, ze_bool_t* pNeedReload) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hScheduler = hScheduler;
        args.pNeedReload = pNeedReload;
    }
    
    static void fillWithoutCapture(ZesSchedulerSetExclusiveModeRpcM &message, zes_sched_handle_t hScheduler, ze_bool_t* pNeedReload) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hScheduler = hScheduler;
        message.args.pNeedReload = pNeedReload;
    }
    

    void copyFromCaller(){
        if(args.pNeedReload){
            captures.pNeedReload = *args.pNeedReload;
        }
    }

    void copyToCaller(){
        if(args.pNeedReload){
            *args.pNeedReload = captures.pNeedReload;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesSchedulerSetExclusiveModeRpcM>);
struct ZesSchedulerSetComputeUnitDebugModeRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 50;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_sched_handle_t hScheduler = {};
        ze_bool_t* pNeedReload = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hScheduler == rhs.hScheduler;
            equal &= this->pNeedReload == rhs.pNeedReload;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        ze_bool_t pNeedReload;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesSchedulerSetComputeUnitDebugModeRpcM() = default;

    ZesSchedulerSetComputeUnitDebugModeRpcM(zes_sched_handle_t hScheduler, ze_bool_t* pNeedReload) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hScheduler = hScheduler;
        args.pNeedReload = pNeedReload;
    }
    
    static void fillWithoutCapture(ZesSchedulerSetComputeUnitDebugModeRpcM &message, zes_sched_handle_t hScheduler, ze_bool_t* pNeedReload) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hScheduler = hScheduler;
        message.args.pNeedReload = pNeedReload;
    }
    

    void copyFromCaller(){
        if(args.pNeedReload){
            captures.pNeedReload = *args.pNeedReload;
        }
    }

    void copyToCaller(){
        if(args.pNeedReload){
            *args.pNeedReload = captures.pNeedReload;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesSchedulerSetComputeUnitDebugModeRpcM>);
struct ZesEngineGetPropertiesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 51;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_engine_handle_t hEngine = {};
        zes_engine_properties_t* pProperties = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hEngine == rhs.hEngine;
            equal &= this->pProperties == rhs.pProperties;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        zes_engine_properties_t pProperties;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesEngineGetPropertiesRpcM() = default;

    ZesEngineGetPropertiesRpcM(zes_engine_handle_t hEngine, zes_engine_properties_t* pProperties) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hEngine = hEngine;
        args.pProperties = pProperties;
    }
    
    static void fillWithoutCapture(ZesEngineGetPropertiesRpcM &message, zes_engine_handle_t hEngine, zes_engine_properties_t* pProperties) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hEngine = hEngine;
        message.args.pProperties = pProperties;
    }
    

    void copyFromCaller(){
        if(args.pProperties){
            captures.pProperties = *args.pProperties;
        }
    }

    void copyToCaller(){
        if(args.pProperties){
            *args.pProperties = captures.pProperties;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesEngineGetPropertiesRpcM>);
struct ZesEngineGetActivityRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 52;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_engine_handle_t hEngine = {};
        zes_engine_stats_t* pStats = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hEngine == rhs.hEngine;
            equal &= this->pStats == rhs.pStats;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        zes_engine_stats_t pStats;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesEngineGetActivityRpcM() = default;

    ZesEngineGetActivityRpcM(zes_engine_handle_t hEngine, zes_engine_stats_t* pStats) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hEngine = hEngine;
        args.pStats = pStats;
    }
    
    static void fillWithoutCapture(ZesEngineGetActivityRpcM &message, zes_engine_handle_t hEngine, zes_engine_stats_t* pStats) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hEngine = hEngine;
        message.args.pStats = pStats;
    }
    

    void copyFromCaller(){
        if(args.pStats){
            captures.pStats = *args.pStats;
        }
    }

    void copyToCaller(){
        if(args.pStats){
            *args.pStats = captures.pStats;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesEngineGetActivityRpcM>);
struct ZesDeviceGetStateRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 53;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_device_handle_t hDevice = {};
        zes_device_state_t* pState = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->pState == rhs.pState;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        zes_device_state_t pState;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesDeviceGetStateRpcM() = default;

    ZesDeviceGetStateRpcM(zes_device_handle_t hDevice, zes_device_state_t* pState) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.pState = pState;
    }
    
    static void fillWithoutCapture(ZesDeviceGetStateRpcM &message, zes_device_handle_t hDevice, zes_device_state_t* pState) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.pState = pState;
    }
    

    void copyToCaller(){
        if(args.pState){
            *args.pState = captures.pState;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesDeviceGetStateRpcM>);
struct ZesDeviceProcessesGetStateRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 54;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_device_handle_t hDevice = {};
        uint32_t* pCount = {};
        zes_process_state_t* pProcesses = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->pCount == rhs.pCount;
            equal &= this->pProcesses == rhs.pProcesses;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(zes_device_handle_t hDevice, uint32_t* pCount, zes_process_state_t* pProcesses);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits pProcesses = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPProcesses = 0;
        zes_process_state_t pProcesses[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPProcesses = dynamicTraits.pProcesses.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesDeviceProcessesGetStateRpcM() = default;

    ZesDeviceProcessesGetStateRpcM(const Captures::DynamicTraits &dynamicTraits, zes_device_handle_t hDevice, uint32_t* pCount, zes_process_state_t* pProcesses) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.pCount = pCount;
        args.pProcesses = pProcesses;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZesDeviceProcessesGetStateRpcM &message, zes_device_handle_t hDevice, uint32_t* pCount, zes_process_state_t* pProcesses) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.pCount = pCount;
        message.args.pProcesses = pProcesses;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pProcesses){
            memcpy(asMemcpyDstT(captures.pProcesses), args.pProcesses, dynMemTraits.pProcesses.size);
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pProcesses){
            memcpy(args.pProcesses, captures.pProcesses, dynMemTraits.pProcesses.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZesDeviceProcessesGetStateRpcM>);
struct ZesDevicePciGetPropertiesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 55;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_device_handle_t hDevice = {};
        zes_pci_properties_t* pProperties = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->pProperties == rhs.pProperties;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        zes_pci_properties_t pProperties;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesDevicePciGetPropertiesRpcM() = default;

    ZesDevicePciGetPropertiesRpcM(zes_device_handle_t hDevice, zes_pci_properties_t* pProperties) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.pProperties = pProperties;
    }
    
    static void fillWithoutCapture(ZesDevicePciGetPropertiesRpcM &message, zes_device_handle_t hDevice, zes_pci_properties_t* pProperties) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.pProperties = pProperties;
    }
    

    void copyToCaller(){
        if(args.pProperties){
            *args.pProperties = captures.pProperties;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesDevicePciGetPropertiesRpcM>);
struct ZesDevicePciGetStateRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 56;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_device_handle_t hDevice = {};
        zes_pci_state_t* pState = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->pState == rhs.pState;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        zes_pci_state_t pState;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesDevicePciGetStateRpcM() = default;

    ZesDevicePciGetStateRpcM(zes_device_handle_t hDevice, zes_pci_state_t* pState) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.pState = pState;
    }
    
    static void fillWithoutCapture(ZesDevicePciGetStateRpcM &message, zes_device_handle_t hDevice, zes_pci_state_t* pState) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.pState = pState;
    }
    

    void copyToCaller(){
        if(args.pState){
            *args.pState = captures.pState;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesDevicePciGetStateRpcM>);
struct ZesDevicePciGetBarsRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 57;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_device_handle_t hDevice = {};
        uint32_t* pCount = {};
        zes_pci_bar_properties_t* pProperties = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->pCount == rhs.pCount;
            equal &= this->pProperties == rhs.pProperties;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        zes_pci_bar_properties_t pProperties;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesDevicePciGetBarsRpcM() = default;

    ZesDevicePciGetBarsRpcM(zes_device_handle_t hDevice, uint32_t* pCount, zes_pci_bar_properties_t* pProperties) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.pCount = pCount;
        args.pProperties = pProperties;
    }
    
    static void fillWithoutCapture(ZesDevicePciGetBarsRpcM &message, zes_device_handle_t hDevice, uint32_t* pCount, zes_pci_bar_properties_t* pProperties) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.pCount = pCount;
        message.args.pProperties = pProperties;
    }
    

    void copyToCaller(){
        if(args.pProperties){
            *args.pProperties = captures.pProperties;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesDevicePciGetBarsRpcM>);
struct ZesDevicePciGetStatsRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 58;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_device_handle_t hDevice = {};
        zes_pci_stats_t* pStats = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->pStats == rhs.pStats;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        zes_pci_stats_t pStats;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesDevicePciGetStatsRpcM() = default;

    ZesDevicePciGetStatsRpcM(zes_device_handle_t hDevice, zes_pci_stats_t* pStats) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.pStats = pStats;
    }
    
    static void fillWithoutCapture(ZesDevicePciGetStatsRpcM &message, zes_device_handle_t hDevice, zes_pci_stats_t* pStats) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.pStats = pStats;
    }
    

    void copyToCaller(){
        if(args.pStats){
            *args.pStats = captures.pStats;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesDevicePciGetStatsRpcM>);
struct ZesDeviceGetPropertiesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 59;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_device_handle_t hDevice = {};
        zes_device_properties_t* pProperties = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->pProperties == rhs.pProperties;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        zes_device_properties_t pProperties;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesDeviceGetPropertiesRpcM() = default;

    ZesDeviceGetPropertiesRpcM(zes_device_handle_t hDevice, zes_device_properties_t* pProperties) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.pProperties = pProperties;
    }
    
    static void fillWithoutCapture(ZesDeviceGetPropertiesRpcM &message, zes_device_handle_t hDevice, zes_device_properties_t* pProperties) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.pProperties = pProperties;
    }
    

    void copyFromCaller(){
        if(args.pProperties){
            captures.pProperties = *args.pProperties;
        }
    }

    void copyToCaller(){
        if(args.pProperties){
            *args.pProperties = captures.pProperties;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesDeviceGetPropertiesRpcM>);
struct ZesDeviceEnumMemoryModulesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 60;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_device_handle_t hDevice = {};
        uint32_t* pCount = {};
        zes_mem_handle_t* phMemory = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->pCount == rhs.pCount;
            equal &= this->phMemory == rhs.phMemory;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(zes_device_handle_t hDevice, uint32_t* pCount, zes_mem_handle_t* phMemory);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phMemory = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhMemory = 0;
        zes_mem_handle_t phMemory[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhMemory = dynamicTraits.phMemory.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesDeviceEnumMemoryModulesRpcM() = default;

    ZesDeviceEnumMemoryModulesRpcM(const Captures::DynamicTraits &dynamicTraits, zes_device_handle_t hDevice, uint32_t* pCount, zes_mem_handle_t* phMemory) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.pCount = pCount;
        args.phMemory = phMemory;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZesDeviceEnumMemoryModulesRpcM &message, zes_device_handle_t hDevice, uint32_t* pCount, zes_mem_handle_t* phMemory) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.pCount = pCount;
        message.args.phMemory = phMemory;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phMemory){
            memcpy(asMemcpyDstT(captures.phMemory), args.phMemory, dynMemTraits.phMemory.size);
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phMemory){
            memcpy(args.phMemory, captures.phMemory, dynMemTraits.phMemory.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZesDeviceEnumMemoryModulesRpcM>);
struct ZesDeviceEnumPerformanceFactorDomainsRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 61;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_device_handle_t hDevice = {};
        uint32_t* pCount = {};
        zes_perf_handle_t* phPerf = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->pCount == rhs.pCount;
            equal &= this->phPerf == rhs.phPerf;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(zes_device_handle_t hDevice, uint32_t* pCount, zes_perf_handle_t* phPerf);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phPerf = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        uint32_t pCount;
        uint32_t countPhPerf = 0;
        zes_perf_handle_t phPerf[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhPerf = dynamicTraits.phPerf.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesDeviceEnumPerformanceFactorDomainsRpcM() = default;

    ZesDeviceEnumPerformanceFactorDomainsRpcM(const Captures::DynamicTraits &dynamicTraits, zes_device_handle_t hDevice, uint32_t* pCount, zes_perf_handle_t* phPerf) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.pCount = pCount;
        args.phPerf = phPerf;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZesDeviceEnumPerformanceFactorDomainsRpcM &message, zes_device_handle_t hDevice, uint32_t* pCount, zes_perf_handle_t* phPerf) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.pCount = pCount;
        message.args.phPerf = phPerf;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            captures.pCount = *args.pCount;
        }
        if(args.phPerf){
            memcpy(asMemcpyDstT(captures.phPerf), args.phPerf, dynMemTraits.phPerf.size);
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            *args.pCount = captures.pCount;
        }
        if(args.phPerf){
            memcpy(args.phPerf, captures.phPerf, dynMemTraits.phPerf.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZesDeviceEnumPerformanceFactorDomainsRpcM>);
struct ZesPerformanceFactorGetPropertiesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 62;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_perf_handle_t hPerf = {};
        zes_perf_properties_t* pProperties = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hPerf == rhs.hPerf;
            equal &= this->pProperties == rhs.pProperties;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        zes_perf_properties_t pProperties;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesPerformanceFactorGetPropertiesRpcM() = default;

    ZesPerformanceFactorGetPropertiesRpcM(zes_perf_handle_t hPerf, zes_perf_properties_t* pProperties) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hPerf = hPerf;
        args.pProperties = pProperties;
    }
    
    static void fillWithoutCapture(ZesPerformanceFactorGetPropertiesRpcM &message, zes_perf_handle_t hPerf, zes_perf_properties_t* pProperties) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hPerf = hPerf;
        message.args.pProperties = pProperties;
    }
    

    void copyFromCaller(){
        if(args.pProperties){
            captures.pProperties = *args.pProperties;
        }
    }

    void copyToCaller(){
        if(args.pProperties){
            *args.pProperties = captures.pProperties;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesPerformanceFactorGetPropertiesRpcM>);
struct ZesPerformanceFactorGetConfigRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 63;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_perf_handle_t hPerf = {};
        double* pFactor = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hPerf == rhs.hPerf;
            equal &= this->pFactor == rhs.pFactor;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        double pFactor;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesPerformanceFactorGetConfigRpcM() = default;

    ZesPerformanceFactorGetConfigRpcM(zes_perf_handle_t hPerf, double* pFactor) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hPerf = hPerf;
        args.pFactor = pFactor;
    }
    
    static void fillWithoutCapture(ZesPerformanceFactorGetConfigRpcM &message, zes_perf_handle_t hPerf, double* pFactor) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hPerf = hPerf;
        message.args.pFactor = pFactor;
    }
    

    void copyFromCaller(){
        if(args.pFactor){
            captures.pFactor = *args.pFactor;
        }
    }

    void copyToCaller(){
        if(args.pFactor){
            *args.pFactor = captures.pFactor;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesPerformanceFactorGetConfigRpcM>);
struct ZesPerformanceFactorSetConfigRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 64;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_perf_handle_t hPerf = {};
        double pFactor = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hPerf == rhs.hPerf;
            equal &= this->pFactor == rhs.pFactor;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesPerformanceFactorSetConfigRpcM() = default;

    ZesPerformanceFactorSetConfigRpcM(zes_perf_handle_t hPerf, double pFactor) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hPerf = hPerf;
        args.pFactor = pFactor;
    }
    
    static void fillWithoutCapture(ZesPerformanceFactorSetConfigRpcM &message, zes_perf_handle_t hPerf, double pFactor) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hPerf = hPerf;
        message.args.pFactor = pFactor;
    }
    
};
static_assert(std::is_standard_layout_v<ZesPerformanceFactorSetConfigRpcM>);
struct ZesDeviceEnumStandbyDomainsRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 65;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_device_handle_t hDevice = {};
        uint32_t* pCount = {};
        zes_standby_handle_t* phStandby = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->pCount == rhs.pCount;
            equal &= this->phStandby == rhs.phStandby;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(zes_device_handle_t hDevice, uint32_t* pCount, zes_standby_handle_t* phStandby);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phStandby = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t pCount;
        uint32_t countPhStandby = 0;
        zes_standby_handle_t phStandby[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhStandby = dynamicTraits.phStandby.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesDeviceEnumStandbyDomainsRpcM() = default;

    ZesDeviceEnumStandbyDomainsRpcM(const Captures::DynamicTraits &dynamicTraits, zes_device_handle_t hDevice, uint32_t* pCount, zes_standby_handle_t* phStandby) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.pCount = pCount;
        args.phStandby = phStandby;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZesDeviceEnumStandbyDomainsRpcM &message, zes_device_handle_t hDevice, uint32_t* pCount, zes_standby_handle_t* phStandby) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.pCount = pCount;
        message.args.phStandby = phStandby;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            captures.pCount = *args.pCount;
        }
        if(args.phStandby){
            memcpy(asMemcpyDstT(captures.phStandby), args.phStandby, dynMemTraits.phStandby.size);
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            *args.pCount = captures.pCount;
        }
        if(args.phStandby){
            memcpy(args.phStandby, captures.phStandby, dynMemTraits.phStandby.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZesDeviceEnumStandbyDomainsRpcM>);
struct ZesStandbyGetPropertiesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 66;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_standby_handle_t hStandby = {};
        zes_standby_properties_t* pProperties = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hStandby == rhs.hStandby;
            equal &= this->pProperties == rhs.pProperties;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        zes_standby_properties_t pProperties;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesStandbyGetPropertiesRpcM() = default;

    ZesStandbyGetPropertiesRpcM(zes_standby_handle_t hStandby, zes_standby_properties_t* pProperties) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hStandby = hStandby;
        args.pProperties = pProperties;
    }
    
    static void fillWithoutCapture(ZesStandbyGetPropertiesRpcM &message, zes_standby_handle_t hStandby, zes_standby_properties_t* pProperties) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hStandby = hStandby;
        message.args.pProperties = pProperties;
    }
    

    void copyFromCaller(){
        if(args.pProperties){
            captures.pProperties = *args.pProperties;
        }
    }

    void copyToCaller(){
        if(args.pProperties){
            *args.pProperties = captures.pProperties;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesStandbyGetPropertiesRpcM>);
struct ZesStandbyGetModeRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 67;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_standby_handle_t hStandby = {};
        zes_standby_promo_mode_t* pMode = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hStandby == rhs.hStandby;
            equal &= this->pMode == rhs.pMode;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;
        zes_standby_promo_mode_t pMode;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesStandbyGetModeRpcM() = default;

    ZesStandbyGetModeRpcM(zes_standby_handle_t hStandby, zes_standby_promo_mode_t* pMode) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hStandby = hStandby;
        args.pMode = pMode;
    }
    
    static void fillWithoutCapture(ZesStandbyGetModeRpcM &message, zes_standby_handle_t hStandby, zes_standby_promo_mode_t* pMode) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hStandby = hStandby;
        message.args.pMode = pMode;
    }
    

    void copyToCaller(){
        if(args.pMode){
            *args.pMode = captures.pMode;
        }
    }
};
static_assert(std::is_standard_layout_v<ZesStandbyGetModeRpcM>);
struct ZesStandbySetModeRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 68;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        zes_standby_handle_t hStandby = {};
        zes_standby_promo_mode_t mode = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hStandby == rhs.hStandby;
            equal &= this->mode == rhs.mode;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_UNINITIALIZED;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZesStandbySetModeRpcM() = default;

    ZesStandbySetModeRpcM(zes_standby_handle_t hStandby, zes_standby_promo_mode_t mode) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hStandby = hStandby;
        args.mode = mode;
    }
    
    static void fillWithoutCapture(ZesStandbySetModeRpcM &message, zes_standby_handle_t hStandby, zes_standby_promo_mode_t mode) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hStandby = hStandby;
        message.args.mode = mode;
    }
    
};
static_assert(std::is_standard_layout_v<ZesStandbySetModeRpcM>);
struct ZeInitRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 69;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_init_flags_t flags = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->flags == rhs.flags;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeInitRpcM() = default;

    ZeInitRpcM(ze_init_flags_t flags) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.flags = flags;
    }
    
    static void fillWithoutCapture(ZeInitRpcM &message, ze_init_flags_t flags) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.flags = flags;
    }
    
};
static_assert(std::is_standard_layout_v<ZeInitRpcM>);
struct ZeCommandListAppendMemoryRangesBarrierRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 70;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        uint32_t numRanges = {};
        const size_t* pRangeSizes = {};
        const void** pRanges = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->numRanges == rhs.numRanges;
            equal &= this->pRangeSizes == rhs.pRangeSizes;
            equal &= this->pRanges == rhs.pRanges;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, uint32_t numRanges, const size_t* pRangeSizes, const void** pRanges, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits pRangeSizes = {};          
            DynamicArgTraits pRanges = {};          
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t offsetPRanges = 0;
        uint32_t offsetPhWaitEvents = 0;
        uint32_t countPRangeSizes = 0;
        uint32_t countPRanges = 0;
        uint32_t countPhWaitEvents = 0;
        const size_t* getPRangeSizes() {
            auto offset = 0;
            return reinterpret_cast<const size_t*>(dynMem + offset);
        }

        const void** getPRanges() {
            auto offset = offsetPRanges;
            return reinterpret_cast<const void**>(dynMem + offset);
        }

        ze_event_handle_t* getPhWaitEvents() {
            auto offset = offsetPhWaitEvents;
            return reinterpret_cast<ze_event_handle_t*>(dynMem + offset);
        }


        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        offsetPRanges = dynamicTraits.pRanges.offset;
        offsetPhWaitEvents = dynamicTraits.phWaitEvents.offset;
        countPRangeSizes = dynamicTraits.pRangeSizes.count;
        countPRanges = dynamicTraits.pRanges.count;
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        alignas(8) char dynMem[];
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryRangesBarrierRpcM() = default;

    ZeCommandListAppendMemoryRangesBarrierRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, uint32_t numRanges, const size_t* pRangeSizes, const void** pRanges, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.numRanges = numRanges;
        args.pRangeSizes = pRangeSizes;
        args.pRanges = pRanges;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryRangesBarrierRpcM &message, ze_command_list_handle_t hCommandList, uint32_t numRanges, const size_t* pRangeSizes, const void** pRanges, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.numRanges = numRanges;
        message.args.pRangeSizes = pRangeSizes;
        message.args.pRanges = pRanges;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pRangeSizes){
            memcpy(asMemcpyDstT(captures.getPRangeSizes()), args.pRangeSizes, dynMemTraits.pRangeSizes.size);
        }
        if(args.pRanges){
            memcpy(asMemcpyDstT(captures.getPRanges()), args.pRanges, dynMemTraits.pRanges.size);
        }
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.getPhWaitEvents()), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryRangesBarrierRpcM>);
struct ZeContextSystemBarrierRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 71;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_context_handle_t hContext = {};
        ze_device_handle_t hDevice = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hContext == rhs.hContext;
            equal &= this->hDevice == rhs.hDevice;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeContextSystemBarrierRpcM() = default;

    ZeContextSystemBarrierRpcM(ze_context_handle_t hContext, ze_device_handle_t hDevice) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hContext = hContext;
        args.hDevice = hDevice;
    }
    
    static void fillWithoutCapture(ZeContextSystemBarrierRpcM &message, ze_context_handle_t hContext, ze_device_handle_t hDevice) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hContext = hContext;
        message.args.hDevice = hDevice;
    }
    
};
static_assert(std::is_standard_layout_v<ZeContextSystemBarrierRpcM>);
struct ZeCommandListCreateRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 72;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_context_handle_t hContext = {};
        ze_device_handle_t hDevice = {};
        const ze_command_list_desc_t* desc = {};
        ze_command_list_handle_t* phCommandList = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hContext == rhs.hContext;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->desc == rhs.desc;
            equal &= this->phCommandList == rhs.phCommandList;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_command_list_desc_t desc;
        ze_command_list_handle_t phCommandList;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListCreateRpcM() = default;

    ZeCommandListCreateRpcM(ze_context_handle_t hContext, ze_device_handle_t hDevice, const ze_command_list_desc_t* desc, ze_command_list_handle_t* phCommandList) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hContext = hContext;
        args.hDevice = hDevice;
        args.desc = desc;
        args.phCommandList = phCommandList;
    }
    
    static void fillWithoutCapture(ZeCommandListCreateRpcM &message, ze_context_handle_t hContext, ze_device_handle_t hDevice, const ze_command_list_desc_t* desc, ze_command_list_handle_t* phCommandList) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hContext = hContext;
        message.args.hDevice = hDevice;
        message.args.desc = desc;
        message.args.phCommandList = phCommandList;
    }
    

    void copyFromCaller(){
        if(args.desc){
            captures.desc = *args.desc;
        }
    }

    void copyToCaller(){
        if(args.phCommandList){
            *args.phCommandList = captures.phCommandList;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListCreateRpcM>);
struct ZeCommandListCreateImmediateRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 73;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_context_handle_t hContext = {};
        ze_device_handle_t hDevice = {};
        const ze_command_queue_desc_t* altdesc = {};
        ze_command_list_handle_t* phCommandList = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hContext == rhs.hContext;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->altdesc == rhs.altdesc;
            equal &= this->phCommandList == rhs.phCommandList;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_command_queue_desc_t altdesc;
        ze_command_list_handle_t phCommandList;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListCreateImmediateRpcM() = default;

    ZeCommandListCreateImmediateRpcM(ze_context_handle_t hContext, ze_device_handle_t hDevice, const ze_command_queue_desc_t* altdesc, ze_command_list_handle_t* phCommandList) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hContext = hContext;
        args.hDevice = hDevice;
        args.altdesc = altdesc;
        args.phCommandList = phCommandList;
    }
    
    static void fillWithoutCapture(ZeCommandListCreateImmediateRpcM &message, ze_context_handle_t hContext, ze_device_handle_t hDevice, const ze_command_queue_desc_t* altdesc, ze_command_list_handle_t* phCommandList) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hContext = hContext;
        message.args.hDevice = hDevice;
        message.args.altdesc = altdesc;
        message.args.phCommandList = phCommandList;
    }
    

    void copyFromCaller(){
        if(args.altdesc){
            captures.altdesc = *args.altdesc;
        }
    }

    void copyToCaller(){
        if(args.phCommandList){
            *args.phCommandList = captures.phCommandList;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListCreateImmediateRpcM>);
struct ZeCommandListDestroyRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 74;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListDestroyRpcM() = default;

    ZeCommandListDestroyRpcM(ze_command_list_handle_t hCommandList) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
    }
    
    static void fillWithoutCapture(ZeCommandListDestroyRpcM &message, ze_command_list_handle_t hCommandList) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
    }
    
};
static_assert(std::is_standard_layout_v<ZeCommandListDestroyRpcM>);
struct ZeCommandListCloseRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 75;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListCloseRpcM() = default;

    ZeCommandListCloseRpcM(ze_command_list_handle_t hCommandList) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
    }
    
    static void fillWithoutCapture(ZeCommandListCloseRpcM &message, ze_command_list_handle_t hCommandList) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
    }
    
};
static_assert(std::is_standard_layout_v<ZeCommandListCloseRpcM>);
struct ZeCommandListResetRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 76;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListResetRpcM() = default;

    ZeCommandListResetRpcM(ze_command_list_handle_t hCommandList) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
    }
    
    static void fillWithoutCapture(ZeCommandListResetRpcM &message, ze_command_list_handle_t hCommandList) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
    }
    
};
static_assert(std::is_standard_layout_v<ZeCommandListResetRpcM>);
struct ZeCommandListAppendWriteGlobalTimestampRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 77;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        uint64_t* dstptr = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, uint64_t* dstptr, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendWriteGlobalTimestampRpcM() = default;

    ZeCommandListAppendWriteGlobalTimestampRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, uint64_t* dstptr, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendWriteGlobalTimestampRpcM &message, ze_command_list_handle_t hCommandList, uint64_t* dstptr, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(args.phWaitEvents, captures.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendWriteGlobalTimestampRpcM>);
struct ZeCommandQueueCreateRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 78;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_context_handle_t hContext = {};
        ze_device_handle_t hDevice = {};
        const ze_command_queue_desc_t* desc = {};
        ze_command_queue_handle_t* phCommandQueue = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hContext == rhs.hContext;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->desc == rhs.desc;
            equal &= this->phCommandQueue == rhs.phCommandQueue;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_command_queue_desc_t desc;
        ze_command_queue_handle_t phCommandQueue;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandQueueCreateRpcM() = default;

    ZeCommandQueueCreateRpcM(ze_context_handle_t hContext, ze_device_handle_t hDevice, const ze_command_queue_desc_t* desc, ze_command_queue_handle_t* phCommandQueue) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hContext = hContext;
        args.hDevice = hDevice;
        args.desc = desc;
        args.phCommandQueue = phCommandQueue;
    }
    
    static void fillWithoutCapture(ZeCommandQueueCreateRpcM &message, ze_context_handle_t hContext, ze_device_handle_t hDevice, const ze_command_queue_desc_t* desc, ze_command_queue_handle_t* phCommandQueue) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hContext = hContext;
        message.args.hDevice = hDevice;
        message.args.desc = desc;
        message.args.phCommandQueue = phCommandQueue;
    }
    

    void copyFromCaller(){
        if(args.desc){
            captures.desc = *args.desc;
        }
    }

    void copyToCaller(){
        if(args.phCommandQueue){
            *args.phCommandQueue = captures.phCommandQueue;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandQueueCreateRpcM>);
struct ZeCommandQueueDestroyRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 79;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_queue_handle_t hCommandQueue = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandQueue == rhs.hCommandQueue;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandQueueDestroyRpcM() = default;

    ZeCommandQueueDestroyRpcM(ze_command_queue_handle_t hCommandQueue) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandQueue = hCommandQueue;
    }
    
    static void fillWithoutCapture(ZeCommandQueueDestroyRpcM &message, ze_command_queue_handle_t hCommandQueue) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandQueue = hCommandQueue;
    }
    
};
static_assert(std::is_standard_layout_v<ZeCommandQueueDestroyRpcM>);
struct ZeCommandQueueExecuteCommandListsRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 80;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_queue_handle_t hCommandQueue = {};
        uint32_t numCommandLists = {};
        ze_command_list_handle_t* phCommandLists = {};
        ze_fence_handle_t hFence = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandQueue == rhs.hCommandQueue;
            equal &= this->numCommandLists == rhs.numCommandLists;
            equal &= this->phCommandLists == rhs.phCommandLists;
            equal &= this->hFence == rhs.hFence;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_queue_handle_t hCommandQueue, uint32_t numCommandLists, ze_command_list_handle_t* phCommandLists, ze_fence_handle_t hFence);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phCommandLists = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhCommandLists = 0;
        ze_command_list_handle_t phCommandLists[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhCommandLists = dynamicTraits.phCommandLists.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandQueueExecuteCommandListsRpcM() = default;

    ZeCommandQueueExecuteCommandListsRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_queue_handle_t hCommandQueue, uint32_t numCommandLists, ze_command_list_handle_t* phCommandLists, ze_fence_handle_t hFence) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandQueue = hCommandQueue;
        args.numCommandLists = numCommandLists;
        args.phCommandLists = phCommandLists;
        args.hFence = hFence;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandQueueExecuteCommandListsRpcM &message, ze_command_queue_handle_t hCommandQueue, uint32_t numCommandLists, ze_command_list_handle_t* phCommandLists, ze_fence_handle_t hFence) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandQueue = hCommandQueue;
        message.args.numCommandLists = numCommandLists;
        message.args.phCommandLists = phCommandLists;
        message.args.hFence = hFence;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phCommandLists){
            memcpy(asMemcpyDstT(captures.phCommandLists), args.phCommandLists, dynMemTraits.phCommandLists.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandQueueExecuteCommandListsRpcM>);
struct ZeCommandQueueExecuteCommandListsCopyMemoryRpcHelperRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 81;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        uint32_t chunksCount = {};
        const Cal::Rpc::MemChunk* chunks = {};
        uint32_t* transferDescsCount = {};
        Cal::Rpc::TransferDesc* transferDescs = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->chunksCount == rhs.chunksCount;
            equal &= this->chunks == rhs.chunks;
            equal &= this->transferDescsCount == rhs.transferDescsCount;
            equal &= this->transferDescs == rhs.transferDescs;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(uint32_t chunksCount, const Cal::Rpc::MemChunk* chunks, uint32_t* transferDescsCount, Cal::Rpc::TransferDesc* transferDescs);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits chunks = {};          
            DynamicArgTraits transferDescs = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t transferDescsCount;
        uint32_t offsetTransferDescs = 0;
        uint32_t countChunks = 0;
        uint32_t countTransferDescs = 0;
        const Cal::Rpc::MemChunk* getChunks() {
            auto offset = 0;
            return reinterpret_cast<const Cal::Rpc::MemChunk*>(dynMem + offset);
        }

        Cal::Rpc::TransferDesc* getTransferDescs() {
            auto offset = offsetTransferDescs;
            return reinterpret_cast<Cal::Rpc::TransferDesc*>(dynMem + offset);
        }


        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        offsetTransferDescs = dynamicTraits.transferDescs.offset;
        countChunks = dynamicTraits.chunks.count;
        countTransferDescs = dynamicTraits.transferDescs.count;
        }
        
        alignas(8) char dynMem[];
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandQueueExecuteCommandListsCopyMemoryRpcHelperRpcM() = default;

    ZeCommandQueueExecuteCommandListsCopyMemoryRpcHelperRpcM(const Captures::DynamicTraits &dynamicTraits, uint32_t chunksCount, const Cal::Rpc::MemChunk* chunks, uint32_t* transferDescsCount, Cal::Rpc::TransferDesc* transferDescs) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.chunksCount = chunksCount;
        args.chunks = chunks;
        args.transferDescsCount = transferDescsCount;
        args.transferDescs = transferDescs;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandQueueExecuteCommandListsCopyMemoryRpcHelperRpcM &message, uint32_t chunksCount, const Cal::Rpc::MemChunk* chunks, uint32_t* transferDescsCount, Cal::Rpc::TransferDesc* transferDescs) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.chunksCount = chunksCount;
        message.args.chunks = chunks;
        message.args.transferDescsCount = transferDescsCount;
        message.args.transferDescs = transferDescs;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.chunks){
            memcpy(asMemcpyDstT(captures.getChunks()), args.chunks, dynMemTraits.chunks.size);
        }
        if(args.transferDescsCount){
            captures.transferDescsCount = *args.transferDescsCount;
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.transferDescsCount){
            *args.transferDescsCount = captures.transferDescsCount;
        }
        if(args.transferDescs){
            memcpy(args.transferDescs, captures.getTransferDescs(), dynMemTraits.transferDescs.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandQueueExecuteCommandListsCopyMemoryRpcHelperRpcM>);
struct ZeCommandQueueSynchronizeRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 82;
    static constexpr float latency = 2.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_queue_handle_t hCommandQueue = {};
        uint64_t timeout = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandQueue == rhs.hCommandQueue;
            equal &= this->timeout == rhs.timeout;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandQueueSynchronizeRpcM() = default;

    ZeCommandQueueSynchronizeRpcM(ze_command_queue_handle_t hCommandQueue, uint64_t timeout) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandQueue = hCommandQueue;
        args.timeout = timeout;
    }
    
    static void fillWithoutCapture(ZeCommandQueueSynchronizeRpcM &message, ze_command_queue_handle_t hCommandQueue, uint64_t timeout) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandQueue = hCommandQueue;
        message.args.timeout = timeout;
    }
    
};
static_assert(std::is_standard_layout_v<ZeCommandQueueSynchronizeRpcM>);
struct ZeContextCreateRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 83;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_driver_handle_t hDriver = {};
        const ze_context_desc_t* desc = {};
        ze_context_handle_t* phContext = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDriver == rhs.hDriver;
            equal &= this->desc == rhs.desc;
            equal &= this->phContext == rhs.phContext;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_driver_handle_t hDriver, const ze_context_desc_t* desc, ze_context_handle_t* phContext);
            uint32_t totalDynamicSize = 0;
            uint32_t dynamicStructMembersOffset = 0;
            DynamicArgTraits descNestedTraits = {};
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_context_desc_t desc;
        ze_context_handle_t phContext;
        uint32_t dynamicStructMembersOffset = 0;
        uint32_t descNestedTraitsOffset = 0;
        uint32_t descNestedTraitsCount = 0;

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
            dynamicStructMembersOffset = dynamicTraits.dynamicStructMembersOffset;
            descNestedTraitsOffset = dynamicTraits.descNestedTraits.offset;
            descNestedTraitsCount = dynamicTraits.descNestedTraits.count;
            dynMemSize = dynamicTraits.totalDynamicSize;
        }
        
        uint32_t dynMemSize = 0;
        alignas(8) char dynMem[];
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;
        void reassembleNestedStructs() {
            using Cal::Utils::alignUpPow2;

            uint32_t currentOffset = dynamicStructMembersOffset;

            if(descNestedTraitsCount > 0){
                assert(currentOffset == descNestedTraitsOffset);
                auto* descTraits = reinterpret_cast<DynamicStructTraits<ze_context_desc_t>*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(descNestedTraitsCount * sizeof(DynamicStructTraits<ze_context_desc_t>));
                auto* destDesc = &desc;

                for (uint32_t i = 0; i < descNestedTraitsCount; ++i) {
                    if(descTraits[i].pNextOffset == -1){
                        forcePointerWrite(destDesc[i].pNext, nullptr);
                        continue;
                    }

                    auto descPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                    currentOffset += alignUpPow2<8>(descTraits[i].pNextCount * sizeof(NestedPNextTraits));

                    assert(currentOffset == static_cast<uint32_t>(descPNextListElementTraits[0].extensionOffset));
                    forcePointerWrite(destDesc[i].pNext, dynMem + descPNextListElementTraits[0].extensionOffset);
                    currentOffset += alignUpPow2<8>(getUnderlyingSize(static_cast<const ze_base_desc_t*>(destDesc[i].pNext)));

                    auto descPNextListElement = static_cast<const ze_base_desc_t*>(destDesc[i].pNext);
                    for(int32_t j = 1; j <= descTraits[i].pNextCount; ++j){
                        if (j < descTraits[i].pNextCount) {
                            const auto extensionOffset = descPNextListElementTraits[j].extensionOffset;
                            forcePointerWrite(getNextField(*descPNextListElement), dynMem + extensionOffset);
                        }

                        if (j < descTraits[i].pNextCount) {
                            const auto pNextElement = getNext(descPNextListElement);
                            const auto sizeInBytes = getUnderlyingSize(pNextElement);
                            currentOffset += alignUpPow2<8>(sizeInBytes);

                            descPNextListElement = pNextElement;
                        }

                    }

                }
        }
    }

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeContextCreateRpcM() = default;

    ZeContextCreateRpcM(const Captures::DynamicTraits &dynamicTraits, ze_driver_handle_t hDriver, const ze_context_desc_t* desc, ze_context_handle_t* phContext) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDriver = hDriver;
        args.desc = desc;
        args.phContext = phContext;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeContextCreateRpcM &message, ze_driver_handle_t hDriver, const ze_context_desc_t* desc, ze_context_handle_t* phContext) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDriver = hDriver;
        message.args.desc = desc;
        message.args.phContext = phContext;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.desc){
            captures.desc = *args.desc;
        }
        using Cal::Utils::alignUpPow2;

        auto& dynMem = captures.dynMem;
        uint32_t currentOffset = captures.dynamicStructMembersOffset;
        if(args.desc){
            assert(currentOffset == captures.descNestedTraitsOffset);
            auto* descTraits = reinterpret_cast<DynamicStructTraits<ze_context_desc_t>*>(dynMem + currentOffset);
            currentOffset += alignUpPow2<8>(captures.descNestedTraitsCount * sizeof(DynamicStructTraits<ze_context_desc_t>));

            for (uint32_t i = 0; i < captures.descNestedTraitsCount; ++i) {
                const auto& descPNext = args.desc[i].pNext;
                if(!descPNext){
                    descTraits[i].pNextOffset = -1;
                    descTraits[i].pNextCount = -1;
                    continue;
                }

                const auto descPNextCount = static_cast<int32_t>(countOpaqueList(static_cast<const ze_base_desc_t*>(args.desc[i].pNext)));
                if(!descPNextCount){
                    descTraits[i].pNextOffset = -1;
                    descTraits[i].pNextCount = -1;
                    continue;
                }

                descTraits[i].pNextOffset = currentOffset;
                descTraits[i].pNextCount = descPNextCount;
                descTraits[i].pNextFirstOriginalElement = args.desc[i].pNext;

                auto descPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(descPNextCount * sizeof(NestedPNextTraits));

                auto descPNextListElement = static_cast<const ze_base_desc_t*>(args.desc[i].pNext);
                for(int32_t j = 0; j < descPNextCount; ++j){
                    descPNextListElementTraits[j].extensionType = getExtensionType(descPNextListElement);
                    descPNextListElementTraits[j].extensionOffset = currentOffset;

                    const auto sizeInBytes = getUnderlyingSize(descPNextListElement);
                    std::memcpy(dynMem + currentOffset, descPNextListElement, sizeInBytes);
                    currentOffset += alignUpPow2<8>(sizeInBytes);

                    descPNextListElement = getNext(descPNextListElement);
                }

            }
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phContext){
            *args.phContext = captures.phContext;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeContextCreateRpcM>);
struct ZeContextCreateExRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 84;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_driver_handle_t hDriver = {};
        const ze_context_desc_t* desc = {};
        uint32_t numDevices = {};
        ze_device_handle_t* phDevices = {};
        ze_context_handle_t* phContext = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDriver == rhs.hDriver;
            equal &= this->desc == rhs.desc;
            equal &= this->numDevices == rhs.numDevices;
            equal &= this->phDevices == rhs.phDevices;
            equal &= this->phContext == rhs.phContext;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_driver_handle_t hDriver, const ze_context_desc_t* desc, uint32_t numDevices, ze_device_handle_t* phDevices, ze_context_handle_t* phContext);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phDevices = {};          
            uint32_t dynamicStructMembersOffset = 0;
            DynamicArgTraits descNestedTraits = {};
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_context_desc_t desc;
        ze_context_handle_t phContext;
        uint32_t countPhDevices = 0;
        uint32_t dynamicStructMembersOffset = 0;
        uint32_t descNestedTraitsOffset = 0;
        uint32_t descNestedTraitsCount = 0;
        ze_device_handle_t* getPhDevices() {
            auto offset = 0;
            return reinterpret_cast<ze_device_handle_t*>(dynMem + offset);
        }


        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhDevices = dynamicTraits.phDevices.count;
            dynamicStructMembersOffset = dynamicTraits.dynamicStructMembersOffset;
            descNestedTraitsOffset = dynamicTraits.descNestedTraits.offset;
            descNestedTraitsCount = dynamicTraits.descNestedTraits.count;
            dynMemSize = dynamicTraits.totalDynamicSize;
        }
        
        uint32_t dynMemSize = 0;
        alignas(8) char dynMem[];
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;
        void reassembleNestedStructs() {
            using Cal::Utils::alignUpPow2;

            uint32_t currentOffset = dynamicStructMembersOffset;

            if(descNestedTraitsCount > 0){
                assert(currentOffset == descNestedTraitsOffset);
                auto* descTraits = reinterpret_cast<DynamicStructTraits<ze_context_desc_t>*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(descNestedTraitsCount * sizeof(DynamicStructTraits<ze_context_desc_t>));
                auto* destDesc = &desc;

                for (uint32_t i = 0; i < descNestedTraitsCount; ++i) {
                    if(descTraits[i].pNextOffset == -1){
                        forcePointerWrite(destDesc[i].pNext, nullptr);
                        continue;
                    }

                    auto descPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                    currentOffset += alignUpPow2<8>(descTraits[i].pNextCount * sizeof(NestedPNextTraits));

                    assert(currentOffset == static_cast<uint32_t>(descPNextListElementTraits[0].extensionOffset));
                    forcePointerWrite(destDesc[i].pNext, dynMem + descPNextListElementTraits[0].extensionOffset);
                    currentOffset += alignUpPow2<8>(getUnderlyingSize(static_cast<const ze_base_desc_t*>(destDesc[i].pNext)));

                    auto descPNextListElement = static_cast<const ze_base_desc_t*>(destDesc[i].pNext);
                    for(int32_t j = 1; j <= descTraits[i].pNextCount; ++j){
                        if (j < descTraits[i].pNextCount) {
                            const auto extensionOffset = descPNextListElementTraits[j].extensionOffset;
                            forcePointerWrite(getNextField(*descPNextListElement), dynMem + extensionOffset);
                        }

                        if (j < descTraits[i].pNextCount) {
                            const auto pNextElement = getNext(descPNextListElement);
                            const auto sizeInBytes = getUnderlyingSize(pNextElement);
                            currentOffset += alignUpPow2<8>(sizeInBytes);

                            descPNextListElement = pNextElement;
                        }

                    }

                }
        }
    }

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeContextCreateExRpcM() = default;

    ZeContextCreateExRpcM(const Captures::DynamicTraits &dynamicTraits, ze_driver_handle_t hDriver, const ze_context_desc_t* desc, uint32_t numDevices, ze_device_handle_t* phDevices, ze_context_handle_t* phContext) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDriver = hDriver;
        args.desc = desc;
        args.numDevices = numDevices;
        args.phDevices = phDevices;
        args.phContext = phContext;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeContextCreateExRpcM &message, ze_driver_handle_t hDriver, const ze_context_desc_t* desc, uint32_t numDevices, ze_device_handle_t* phDevices, ze_context_handle_t* phContext) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDriver = hDriver;
        message.args.desc = desc;
        message.args.numDevices = numDevices;
        message.args.phDevices = phDevices;
        message.args.phContext = phContext;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.desc){
            captures.desc = *args.desc;
        }
        if(args.phDevices){
            memcpy(asMemcpyDstT(captures.getPhDevices()), args.phDevices, dynMemTraits.phDevices.size);
        }
        using Cal::Utils::alignUpPow2;

        auto& dynMem = captures.dynMem;
        uint32_t currentOffset = captures.dynamicStructMembersOffset;
        if(args.desc){
            assert(currentOffset == captures.descNestedTraitsOffset);
            auto* descTraits = reinterpret_cast<DynamicStructTraits<ze_context_desc_t>*>(dynMem + currentOffset);
            currentOffset += alignUpPow2<8>(captures.descNestedTraitsCount * sizeof(DynamicStructTraits<ze_context_desc_t>));

            for (uint32_t i = 0; i < captures.descNestedTraitsCount; ++i) {
                const auto& descPNext = args.desc[i].pNext;
                if(!descPNext){
                    descTraits[i].pNextOffset = -1;
                    descTraits[i].pNextCount = -1;
                    continue;
                }

                const auto descPNextCount = static_cast<int32_t>(countOpaqueList(static_cast<const ze_base_desc_t*>(args.desc[i].pNext)));
                if(!descPNextCount){
                    descTraits[i].pNextOffset = -1;
                    descTraits[i].pNextCount = -1;
                    continue;
                }

                descTraits[i].pNextOffset = currentOffset;
                descTraits[i].pNextCount = descPNextCount;
                descTraits[i].pNextFirstOriginalElement = args.desc[i].pNext;

                auto descPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(descPNextCount * sizeof(NestedPNextTraits));

                auto descPNextListElement = static_cast<const ze_base_desc_t*>(args.desc[i].pNext);
                for(int32_t j = 0; j < descPNextCount; ++j){
                    descPNextListElementTraits[j].extensionType = getExtensionType(descPNextListElement);
                    descPNextListElementTraits[j].extensionOffset = currentOffset;

                    const auto sizeInBytes = getUnderlyingSize(descPNextListElement);
                    std::memcpy(dynMem + currentOffset, descPNextListElement, sizeInBytes);
                    currentOffset += alignUpPow2<8>(sizeInBytes);

                    descPNextListElement = getNext(descPNextListElement);
                }

            }
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phContext){
            *args.phContext = captures.phContext;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeContextCreateExRpcM>);
struct ZeContextDestroyRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 85;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_context_handle_t hContext = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hContext == rhs.hContext;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeContextDestroyRpcM() = default;

    ZeContextDestroyRpcM(ze_context_handle_t hContext) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hContext = hContext;
    }
    
    static void fillWithoutCapture(ZeContextDestroyRpcM &message, ze_context_handle_t hContext) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hContext = hContext;
    }
    
};
static_assert(std::is_standard_layout_v<ZeContextDestroyRpcM>);
struct ZeContextGetStatusRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 86;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_context_handle_t hContext = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hContext == rhs.hContext;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeContextGetStatusRpcM() = default;

    ZeContextGetStatusRpcM(ze_context_handle_t hContext) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hContext = hContext;
    }
    
    static void fillWithoutCapture(ZeContextGetStatusRpcM &message, ze_context_handle_t hContext) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hContext = hContext;
    }
    
};
static_assert(std::is_standard_layout_v<ZeContextGetStatusRpcM>);
 // zeCommandListAppendMemoryCopy ignored in generator - based on dont_generate_rpc_message flag
 // zeCommandListAppendMemoryCopyDeferred ignored in generator - based on dont_generate_rpc_message flag
 // zeCommandListAppendMemoryCopyImmediate ignored in generator - based on dont_generate_rpc_message flag
 // zeCommandListAppendMemoryCopyImmediateSynchronous ignored in generator - based on dont_generate_rpc_message flag
 // zeCommandListAppendMemoryFill ignored in generator - based on dont_generate_rpc_message flag
struct ZeCommandListAppendMemoryFillRpcHelperUsm2UsmRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 87;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* ptr = {};
        const void* pattern = {};
        size_t pattern_size = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->ptr == rhs.ptr;
            equal &= this->pattern == rhs.pattern;
            equal &= this->pattern_size == rhs.pattern_size;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* ptr, const void* pattern, size_t pattern_size, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryFillRpcHelperUsm2UsmRpcM() = default;

    ZeCommandListAppendMemoryFillRpcHelperUsm2UsmRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* ptr, const void* pattern, size_t pattern_size, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.ptr = ptr;
        args.pattern = pattern;
        args.pattern_size = pattern_size;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryFillRpcHelperUsm2UsmRpcM &message, ze_command_list_handle_t hCommandList, void* ptr, const void* pattern, size_t pattern_size, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.ptr = ptr;
        message.args.pattern = pattern;
        message.args.pattern_size = pattern_size;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryFillRpcHelperUsm2UsmRpcM>);
struct ZeCommandListAppendMemoryFillRpcHelperUsm2MallocRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 88;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* ptr = {};
        const void* pattern = {};
        size_t pattern_size = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->ptr == rhs.ptr;
            equal &= this->pattern == rhs.pattern;
            equal &= this->pattern_size == rhs.pattern_size;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* ptr, const void* pattern, size_t pattern_size, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryFillRpcHelperUsm2MallocRpcM() = default;

    ZeCommandListAppendMemoryFillRpcHelperUsm2MallocRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* ptr, const void* pattern, size_t pattern_size, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.ptr = ptr;
        args.pattern = pattern;
        args.pattern_size = pattern_size;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryFillRpcHelperUsm2MallocRpcM &message, ze_command_list_handle_t hCommandList, void* ptr, const void* pattern, size_t pattern_size, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.ptr = ptr;
        message.args.pattern = pattern;
        message.args.pattern_size = pattern_size;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryFillRpcHelperUsm2MallocRpcM>);
struct ZeCommandListAppendMemoryFillRpcHelperMalloc2UsmRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 89;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* ptr = {};
        const void* pattern = {};
        size_t pattern_size = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->ptr == rhs.ptr;
            equal &= this->pattern == rhs.pattern;
            equal &= this->pattern_size == rhs.pattern_size;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* ptr, const void* pattern, size_t pattern_size, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits pattern = {};          
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t offsetPhWaitEvents = 0;
        uint32_t countPattern = 0;
        uint32_t countPhWaitEvents = 0;
        const void* getPattern() {
            auto offset = 0;
            return reinterpret_cast<const void*>(dynMem + offset);
        }

        ze_event_handle_t* getPhWaitEvents() {
            auto offset = offsetPhWaitEvents;
            return reinterpret_cast<ze_event_handle_t*>(dynMem + offset);
        }


        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        offsetPhWaitEvents = dynamicTraits.phWaitEvents.offset;
        countPattern = dynamicTraits.pattern.count;
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        alignas(8) char dynMem[];
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryFillRpcHelperMalloc2UsmRpcM() = default;

    ZeCommandListAppendMemoryFillRpcHelperMalloc2UsmRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* ptr, const void* pattern, size_t pattern_size, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.ptr = ptr;
        args.pattern = pattern;
        args.pattern_size = pattern_size;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryFillRpcHelperMalloc2UsmRpcM &message, ze_command_list_handle_t hCommandList, void* ptr, const void* pattern, size_t pattern_size, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.ptr = ptr;
        message.args.pattern = pattern;
        message.args.pattern_size = pattern_size;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pattern){
            memcpy(asMemcpyDstT(captures.getPattern()), args.pattern, dynMemTraits.pattern.size);
        }
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.getPhWaitEvents()), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryFillRpcHelperMalloc2UsmRpcM>);
struct ZeCommandListAppendMemoryFillRpcHelperMalloc2MallocRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 90;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* ptr = {};
        const void* pattern = {};
        size_t pattern_size = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->ptr == rhs.ptr;
            equal &= this->pattern == rhs.pattern;
            equal &= this->pattern_size == rhs.pattern_size;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* ptr, const void* pattern, size_t pattern_size, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits pattern = {};          
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t offsetPhWaitEvents = 0;
        uint32_t countPattern = 0;
        uint32_t countPhWaitEvents = 0;
        const void* getPattern() {
            auto offset = 0;
            return reinterpret_cast<const void*>(dynMem + offset);
        }

        ze_event_handle_t* getPhWaitEvents() {
            auto offset = offsetPhWaitEvents;
            return reinterpret_cast<ze_event_handle_t*>(dynMem + offset);
        }


        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        offsetPhWaitEvents = dynamicTraits.phWaitEvents.offset;
        countPattern = dynamicTraits.pattern.count;
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        alignas(8) char dynMem[];
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryFillRpcHelperMalloc2MallocRpcM() = default;

    ZeCommandListAppendMemoryFillRpcHelperMalloc2MallocRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* ptr, const void* pattern, size_t pattern_size, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.ptr = ptr;
        args.pattern = pattern;
        args.pattern_size = pattern_size;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryFillRpcHelperMalloc2MallocRpcM &message, ze_command_list_handle_t hCommandList, void* ptr, const void* pattern, size_t pattern_size, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.ptr = ptr;
        message.args.pattern = pattern;
        message.args.pattern_size = pattern_size;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pattern){
            memcpy(asMemcpyDstT(captures.getPattern()), args.pattern, dynMemTraits.pattern.size);
        }
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.getPhWaitEvents()), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryFillRpcHelperMalloc2MallocRpcM>);
 // zeCommandListAppendMemoryCopyFromContext ignored in generator - based on dont_generate_rpc_message flag
 // zeCommandListAppendMemoryCopyFromContextDeferred ignored in generator - based on dont_generate_rpc_message flag
 // zeCommandListAppendMemoryCopyFromContextImmediateSynchronous ignored in generator - based on dont_generate_rpc_message flag
 // zeCommandListAppendMemoryCopyFromContextImmediateAsynchronous ignored in generator - based on dont_generate_rpc_message flag
struct ZeCommandListAppendMemoryPrefetchRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 91;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        const void* ptr = {};
        size_t size = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->ptr == rhs.ptr;
            equal &= this->size == rhs.size;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryPrefetchRpcM() = default;

    ZeCommandListAppendMemoryPrefetchRpcM(ze_command_list_handle_t hCommandList, const void* ptr, size_t size) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.ptr = ptr;
        args.size = size;
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryPrefetchRpcM &message, ze_command_list_handle_t hCommandList, const void* ptr, size_t size) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.ptr = ptr;
        message.args.size = size;
    }
    
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryPrefetchRpcM>);
 // zeCommandListAppendMemAdvise ignored in generator - based on dont_generate_rpc_message flag
struct ZeDeviceGetRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 92;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_driver_handle_t hDriver = {};
        uint32_t* pCount = {};
        ze_device_handle_t* phDevices = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDriver == rhs.hDriver;
            equal &= this->pCount == rhs.pCount;
            equal &= this->phDevices == rhs.phDevices;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_driver_handle_t hDriver, uint32_t* pCount, ze_device_handle_t* phDevices);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phDevices = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t pCount;
        uint32_t countPhDevices = 0;
        ze_device_handle_t phDevices[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhDevices = dynamicTraits.phDevices.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeDeviceGetRpcM() = default;

    ZeDeviceGetRpcM(const Captures::DynamicTraits &dynamicTraits, ze_driver_handle_t hDriver, uint32_t* pCount, ze_device_handle_t* phDevices) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDriver = hDriver;
        args.pCount = pCount;
        args.phDevices = phDevices;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeDeviceGetRpcM &message, ze_driver_handle_t hDriver, uint32_t* pCount, ze_device_handle_t* phDevices) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDriver = hDriver;
        message.args.pCount = pCount;
        message.args.phDevices = phDevices;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            captures.pCount = *args.pCount;
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            *args.pCount = captures.pCount;
        }
        if(args.phDevices){
            memcpy(args.phDevices, captures.phDevices, dynMemTraits.phDevices.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeDeviceGetRpcM>);
struct ZeDeviceGetSubDevicesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 93;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_device_handle_t hDevice = {};
        uint32_t* pCount = {};
        ze_device_handle_t* phSubdevices = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->pCount == rhs.pCount;
            equal &= this->phSubdevices == rhs.phSubdevices;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_device_handle_t hDevice, uint32_t* pCount, ze_device_handle_t* phSubdevices);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phSubdevices = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t pCount;
        uint32_t countPhSubdevices = 0;
        ze_device_handle_t phSubdevices[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhSubdevices = dynamicTraits.phSubdevices.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeDeviceGetSubDevicesRpcM() = default;

    ZeDeviceGetSubDevicesRpcM(const Captures::DynamicTraits &dynamicTraits, ze_device_handle_t hDevice, uint32_t* pCount, ze_device_handle_t* phSubdevices) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.pCount = pCount;
        args.phSubdevices = phSubdevices;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeDeviceGetSubDevicesRpcM &message, ze_device_handle_t hDevice, uint32_t* pCount, ze_device_handle_t* phSubdevices) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.pCount = pCount;
        message.args.phSubdevices = phSubdevices;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            captures.pCount = *args.pCount;
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            *args.pCount = captures.pCount;
        }
        if(args.phSubdevices){
            memcpy(args.phSubdevices, captures.phSubdevices, dynMemTraits.phSubdevices.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeDeviceGetSubDevicesRpcM>);
struct ZeDeviceGetPropertiesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 94;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_device_handle_t hDevice = {};
        ze_device_properties_t* pDeviceProperties = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->pDeviceProperties == rhs.pDeviceProperties;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_device_handle_t hDevice, ze_device_properties_t* pDeviceProperties);
            uint32_t totalDynamicSize = 0;
            uint32_t dynamicStructMembersOffset = 0;
            DynamicArgTraits pDevicePropertiesNestedTraits = {};
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_device_properties_t pDeviceProperties;
        uint32_t dynamicStructMembersOffset = 0;
        uint32_t pDevicePropertiesNestedTraitsOffset = 0;
        uint32_t pDevicePropertiesNestedTraitsCount = 0;

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
            dynamicStructMembersOffset = dynamicTraits.dynamicStructMembersOffset;
            pDevicePropertiesNestedTraitsOffset = dynamicTraits.pDevicePropertiesNestedTraits.offset;
            pDevicePropertiesNestedTraitsCount = dynamicTraits.pDevicePropertiesNestedTraits.count;
            dynMemSize = dynamicTraits.totalDynamicSize;
        }
        
        uint32_t dynMemSize = 0;
        alignas(8) char dynMem[];
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;
        void reassembleNestedStructs() {
            using Cal::Utils::alignUpPow2;

            uint32_t currentOffset = dynamicStructMembersOffset;

            if(pDevicePropertiesNestedTraitsCount > 0){
                assert(currentOffset == pDevicePropertiesNestedTraitsOffset);
                auto* pDevicePropertiesTraits = reinterpret_cast<DynamicStructTraits<ze_device_properties_t>*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(pDevicePropertiesNestedTraitsCount * sizeof(DynamicStructTraits<ze_device_properties_t>));
                auto* destPDeviceProperties = &pDeviceProperties;

                for (uint32_t i = 0; i < pDevicePropertiesNestedTraitsCount; ++i) {
                    if(pDevicePropertiesTraits[i].pNextOffset == -1){
                        forcePointerWrite(destPDeviceProperties[i].pNext, nullptr);
                        continue;
                    }

                    auto pDevicePropertiesPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                    currentOffset += alignUpPow2<8>(pDevicePropertiesTraits[i].pNextCount * sizeof(NestedPNextTraits));

                    assert(currentOffset == static_cast<uint32_t>(pDevicePropertiesPNextListElementTraits[0].extensionOffset));
                    forcePointerWrite(destPDeviceProperties[i].pNext, dynMem + pDevicePropertiesPNextListElementTraits[0].extensionOffset);
                    currentOffset += alignUpPow2<8>(getUnderlyingSize(static_cast<const ze_base_desc_t*>(destPDeviceProperties[i].pNext)));

                    auto pDevicePropertiesPNextListElement = static_cast<const ze_base_desc_t*>(destPDeviceProperties[i].pNext);
                    for(int32_t j = 1; j <= pDevicePropertiesTraits[i].pNextCount; ++j){
                        if (j < pDevicePropertiesTraits[i].pNextCount) {
                            const auto extensionOffset = pDevicePropertiesPNextListElementTraits[j].extensionOffset;
                            forcePointerWrite(getNextField(*pDevicePropertiesPNextListElement), dynMem + extensionOffset);
                        }

                        if (j < pDevicePropertiesTraits[i].pNextCount) {
                            const auto pNextElement = getNext(pDevicePropertiesPNextListElement);
                            const auto sizeInBytes = getUnderlyingSize(pNextElement);
                            currentOffset += alignUpPow2<8>(sizeInBytes);

                            pDevicePropertiesPNextListElement = pNextElement;
                        }

                    }

                }
        }
    }

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeDeviceGetPropertiesRpcM() = default;

    ZeDeviceGetPropertiesRpcM(const Captures::DynamicTraits &dynamicTraits, ze_device_handle_t hDevice, ze_device_properties_t* pDeviceProperties) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.pDeviceProperties = pDeviceProperties;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeDeviceGetPropertiesRpcM &message, ze_device_handle_t hDevice, ze_device_properties_t* pDeviceProperties) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.pDeviceProperties = pDeviceProperties;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pDeviceProperties){
            captures.pDeviceProperties = *args.pDeviceProperties;
        }
        using Cal::Utils::alignUpPow2;

        auto& dynMem = captures.dynMem;
        uint32_t currentOffset = captures.dynamicStructMembersOffset;
        if(args.pDeviceProperties){
            assert(currentOffset == captures.pDevicePropertiesNestedTraitsOffset);
            auto* pDevicePropertiesTraits = reinterpret_cast<DynamicStructTraits<ze_device_properties_t>*>(dynMem + currentOffset);
            currentOffset += alignUpPow2<8>(captures.pDevicePropertiesNestedTraitsCount * sizeof(DynamicStructTraits<ze_device_properties_t>));

            for (uint32_t i = 0; i < captures.pDevicePropertiesNestedTraitsCount; ++i) {
                const auto& pDevicePropertiesPNext = args.pDeviceProperties[i].pNext;
                if(!pDevicePropertiesPNext){
                    pDevicePropertiesTraits[i].pNextOffset = -1;
                    pDevicePropertiesTraits[i].pNextCount = -1;
                    continue;
                }

                const auto pDevicePropertiesPNextCount = static_cast<int32_t>(countOpaqueList(static_cast<const ze_base_desc_t*>(args.pDeviceProperties[i].pNext)));
                if(!pDevicePropertiesPNextCount){
                    pDevicePropertiesTraits[i].pNextOffset = -1;
                    pDevicePropertiesTraits[i].pNextCount = -1;
                    continue;
                }

                pDevicePropertiesTraits[i].pNextOffset = currentOffset;
                pDevicePropertiesTraits[i].pNextCount = pDevicePropertiesPNextCount;
                pDevicePropertiesTraits[i].pNextFirstOriginalElement = args.pDeviceProperties[i].pNext;

                auto pDevicePropertiesPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(pDevicePropertiesPNextCount * sizeof(NestedPNextTraits));

                auto pDevicePropertiesPNextListElement = static_cast<const ze_base_desc_t*>(args.pDeviceProperties[i].pNext);
                for(int32_t j = 0; j < pDevicePropertiesPNextCount; ++j){
                    pDevicePropertiesPNextListElementTraits[j].extensionType = getExtensionType(pDevicePropertiesPNextListElement);
                    pDevicePropertiesPNextListElementTraits[j].extensionOffset = currentOffset;

                    const auto sizeInBytes = getUnderlyingSize(pDevicePropertiesPNextListElement);
                    std::memcpy(dynMem + currentOffset, pDevicePropertiesPNextListElement, sizeInBytes);
                    currentOffset += alignUpPow2<8>(sizeInBytes);

                    pDevicePropertiesPNextListElement = getNext(pDevicePropertiesPNextListElement);
                }

            }
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pDeviceProperties){
            *args.pDeviceProperties = captures.pDeviceProperties;
        }
        using Cal::Utils::alignUpPow2;

        auto& dynMem = captures.dynMem;
        uint32_t currentOffset = captures.dynamicStructMembersOffset;
        if(args.pDeviceProperties) {
            assert(currentOffset == captures.pDevicePropertiesNestedTraitsOffset);
            auto* pDevicePropertiesTraits = reinterpret_cast<DynamicStructTraits<ze_device_properties_t>*>(dynMem + currentOffset);
            currentOffset += alignUpPow2<8>(captures.pDevicePropertiesNestedTraitsCount * sizeof(DynamicStructTraits<ze_device_properties_t>));

            auto* destPDeviceProperties = args.pDeviceProperties;

            for (uint32_t i = 0; i < captures.pDevicePropertiesNestedTraitsCount; ++i) {
                if(pDevicePropertiesTraits[i].pNextOffset == -1){
                    continue;
                }

                destPDeviceProperties[i].pNext = pDevicePropertiesTraits[i].pNextFirstOriginalElement;

                auto pDevicePropertiesPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(pDevicePropertiesTraits[i].pNextCount * sizeof(NestedPNextTraits));

                auto pDevicePropertiesPNextListElement = static_cast<const ze_base_desc_t*>(destPDeviceProperties[i].pNext);
                for(int32_t j = 0; j < pDevicePropertiesTraits[i].pNextCount; ++j){
                    const auto sizeInBytes = getUnderlyingSize(pDevicePropertiesPNextListElement);
                    currentOffset += alignUpPow2<8>(sizeInBytes);

                    const auto extensionType = getExtensionType(pDevicePropertiesPNextListElement);
                    if (!isReadOnly(extensionType)) {
                        {
                            auto originalNextOpaqueElement = getNext(pDevicePropertiesPNextListElement);
                            const auto extensionOffset = pDevicePropertiesPNextListElementTraits[j].extensionOffset;
                            auto destination = const_cast<ze_base_desc_t*>(pDevicePropertiesPNextListElement);
                            std::memcpy(destination, dynMem + extensionOffset, sizeInBytes);

                            getNextField(*destination) = originalNextOpaqueElement;
                        }

                    }

                    pDevicePropertiesPNextListElement = getNext(pDevicePropertiesPNextListElement);
                }

            }
        }
    }
};
static_assert(std::is_standard_layout_v<ZeDeviceGetPropertiesRpcM>);
struct ZeDeviceGetComputePropertiesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 95;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_device_handle_t hDevice = {};
        ze_device_compute_properties_t* pComputeProperties = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->pComputeProperties == rhs.pComputeProperties;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_device_compute_properties_t pComputeProperties;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeDeviceGetComputePropertiesRpcM() = default;

    ZeDeviceGetComputePropertiesRpcM(ze_device_handle_t hDevice, ze_device_compute_properties_t* pComputeProperties) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.pComputeProperties = pComputeProperties;
    }
    
    static void fillWithoutCapture(ZeDeviceGetComputePropertiesRpcM &message, ze_device_handle_t hDevice, ze_device_compute_properties_t* pComputeProperties) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.pComputeProperties = pComputeProperties;
    }
    

    void copyFromCaller(){
        if(args.pComputeProperties){
            captures.pComputeProperties = *args.pComputeProperties;
        }
    }

    void copyToCaller(){
        if(args.pComputeProperties){
            *args.pComputeProperties = captures.pComputeProperties;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeDeviceGetComputePropertiesRpcM>);
struct ZeDeviceGetModulePropertiesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 96;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_device_handle_t hDevice = {};
        ze_device_module_properties_t* pModuleProperties = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->pModuleProperties == rhs.pModuleProperties;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_device_handle_t hDevice, ze_device_module_properties_t* pModuleProperties);
            uint32_t totalDynamicSize = 0;
            uint32_t dynamicStructMembersOffset = 0;
            DynamicArgTraits pModulePropertiesNestedTraits = {};
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_device_module_properties_t pModuleProperties;
        uint32_t dynamicStructMembersOffset = 0;
        uint32_t pModulePropertiesNestedTraitsOffset = 0;
        uint32_t pModulePropertiesNestedTraitsCount = 0;

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
            dynamicStructMembersOffset = dynamicTraits.dynamicStructMembersOffset;
            pModulePropertiesNestedTraitsOffset = dynamicTraits.pModulePropertiesNestedTraits.offset;
            pModulePropertiesNestedTraitsCount = dynamicTraits.pModulePropertiesNestedTraits.count;
            dynMemSize = dynamicTraits.totalDynamicSize;
        }
        
        uint32_t dynMemSize = 0;
        alignas(8) char dynMem[];
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;
        void reassembleNestedStructs() {
            using Cal::Utils::alignUpPow2;

            uint32_t currentOffset = dynamicStructMembersOffset;

            if(pModulePropertiesNestedTraitsCount > 0){
                assert(currentOffset == pModulePropertiesNestedTraitsOffset);
                auto* pModulePropertiesTraits = reinterpret_cast<DynamicStructTraits<ze_device_module_properties_t>*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(pModulePropertiesNestedTraitsCount * sizeof(DynamicStructTraits<ze_device_module_properties_t>));
                auto* destPModuleProperties = &pModuleProperties;

                for (uint32_t i = 0; i < pModulePropertiesNestedTraitsCount; ++i) {
                    if(pModulePropertiesTraits[i].pNextOffset == -1){
                        forcePointerWrite(destPModuleProperties[i].pNext, nullptr);
                        continue;
                    }

                    auto pModulePropertiesPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                    currentOffset += alignUpPow2<8>(pModulePropertiesTraits[i].pNextCount * sizeof(NestedPNextTraits));

                    assert(currentOffset == static_cast<uint32_t>(pModulePropertiesPNextListElementTraits[0].extensionOffset));
                    forcePointerWrite(destPModuleProperties[i].pNext, dynMem + pModulePropertiesPNextListElementTraits[0].extensionOffset);
                    currentOffset += alignUpPow2<8>(getUnderlyingSize(static_cast<const ze_base_desc_t*>(destPModuleProperties[i].pNext)));

                    auto pModulePropertiesPNextListElement = static_cast<const ze_base_desc_t*>(destPModuleProperties[i].pNext);
                    for(int32_t j = 1; j <= pModulePropertiesTraits[i].pNextCount; ++j){
                        if (j < pModulePropertiesTraits[i].pNextCount) {
                            const auto extensionOffset = pModulePropertiesPNextListElementTraits[j].extensionOffset;
                            forcePointerWrite(getNextField(*pModulePropertiesPNextListElement), dynMem + extensionOffset);
                        }

                        if (j < pModulePropertiesTraits[i].pNextCount) {
                            const auto pNextElement = getNext(pModulePropertiesPNextListElement);
                            const auto sizeInBytes = getUnderlyingSize(pNextElement);
                            currentOffset += alignUpPow2<8>(sizeInBytes);

                            pModulePropertiesPNextListElement = pNextElement;
                        }

                    }

                }
        }
    }

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeDeviceGetModulePropertiesRpcM() = default;

    ZeDeviceGetModulePropertiesRpcM(const Captures::DynamicTraits &dynamicTraits, ze_device_handle_t hDevice, ze_device_module_properties_t* pModuleProperties) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.pModuleProperties = pModuleProperties;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeDeviceGetModulePropertiesRpcM &message, ze_device_handle_t hDevice, ze_device_module_properties_t* pModuleProperties) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.pModuleProperties = pModuleProperties;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pModuleProperties){
            captures.pModuleProperties = *args.pModuleProperties;
        }
        using Cal::Utils::alignUpPow2;

        auto& dynMem = captures.dynMem;
        uint32_t currentOffset = captures.dynamicStructMembersOffset;
        if(args.pModuleProperties){
            assert(currentOffset == captures.pModulePropertiesNestedTraitsOffset);
            auto* pModulePropertiesTraits = reinterpret_cast<DynamicStructTraits<ze_device_module_properties_t>*>(dynMem + currentOffset);
            currentOffset += alignUpPow2<8>(captures.pModulePropertiesNestedTraitsCount * sizeof(DynamicStructTraits<ze_device_module_properties_t>));

            for (uint32_t i = 0; i < captures.pModulePropertiesNestedTraitsCount; ++i) {
                const auto& pModulePropertiesPNext = args.pModuleProperties[i].pNext;
                if(!pModulePropertiesPNext){
                    pModulePropertiesTraits[i].pNextOffset = -1;
                    pModulePropertiesTraits[i].pNextCount = -1;
                    continue;
                }

                const auto pModulePropertiesPNextCount = static_cast<int32_t>(countOpaqueList(static_cast<const ze_base_desc_t*>(args.pModuleProperties[i].pNext)));
                if(!pModulePropertiesPNextCount){
                    pModulePropertiesTraits[i].pNextOffset = -1;
                    pModulePropertiesTraits[i].pNextCount = -1;
                    continue;
                }

                pModulePropertiesTraits[i].pNextOffset = currentOffset;
                pModulePropertiesTraits[i].pNextCount = pModulePropertiesPNextCount;
                pModulePropertiesTraits[i].pNextFirstOriginalElement = args.pModuleProperties[i].pNext;

                auto pModulePropertiesPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(pModulePropertiesPNextCount * sizeof(NestedPNextTraits));

                auto pModulePropertiesPNextListElement = static_cast<const ze_base_desc_t*>(args.pModuleProperties[i].pNext);
                for(int32_t j = 0; j < pModulePropertiesPNextCount; ++j){
                    pModulePropertiesPNextListElementTraits[j].extensionType = getExtensionType(pModulePropertiesPNextListElement);
                    pModulePropertiesPNextListElementTraits[j].extensionOffset = currentOffset;

                    const auto sizeInBytes = getUnderlyingSize(pModulePropertiesPNextListElement);
                    std::memcpy(dynMem + currentOffset, pModulePropertiesPNextListElement, sizeInBytes);
                    currentOffset += alignUpPow2<8>(sizeInBytes);

                    pModulePropertiesPNextListElement = getNext(pModulePropertiesPNextListElement);
                }

            }
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pModuleProperties){
            *args.pModuleProperties = captures.pModuleProperties;
        }
        using Cal::Utils::alignUpPow2;

        auto& dynMem = captures.dynMem;
        uint32_t currentOffset = captures.dynamicStructMembersOffset;
        if(args.pModuleProperties) {
            assert(currentOffset == captures.pModulePropertiesNestedTraitsOffset);
            auto* pModulePropertiesTraits = reinterpret_cast<DynamicStructTraits<ze_device_module_properties_t>*>(dynMem + currentOffset);
            currentOffset += alignUpPow2<8>(captures.pModulePropertiesNestedTraitsCount * sizeof(DynamicStructTraits<ze_device_module_properties_t>));

            auto* destPModuleProperties = args.pModuleProperties;

            for (uint32_t i = 0; i < captures.pModulePropertiesNestedTraitsCount; ++i) {
                if(pModulePropertiesTraits[i].pNextOffset == -1){
                    continue;
                }

                destPModuleProperties[i].pNext = pModulePropertiesTraits[i].pNextFirstOriginalElement;

                auto pModulePropertiesPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(pModulePropertiesTraits[i].pNextCount * sizeof(NestedPNextTraits));

                auto pModulePropertiesPNextListElement = static_cast<const ze_base_desc_t*>(destPModuleProperties[i].pNext);
                for(int32_t j = 0; j < pModulePropertiesTraits[i].pNextCount; ++j){
                    const auto sizeInBytes = getUnderlyingSize(pModulePropertiesPNextListElement);
                    currentOffset += alignUpPow2<8>(sizeInBytes);

                    const auto extensionType = getExtensionType(pModulePropertiesPNextListElement);
                    if (!isReadOnly(extensionType)) {
                        {
                            auto originalNextOpaqueElement = getNext(pModulePropertiesPNextListElement);
                            const auto extensionOffset = pModulePropertiesPNextListElementTraits[j].extensionOffset;
                            auto destination = const_cast<ze_base_desc_t*>(pModulePropertiesPNextListElement);
                            std::memcpy(destination, dynMem + extensionOffset, sizeInBytes);

                            getNextField(*destination) = originalNextOpaqueElement;
                        }

                    }

                    pModulePropertiesPNextListElement = getNext(pModulePropertiesPNextListElement);
                }

            }
        }
    }
};
static_assert(std::is_standard_layout_v<ZeDeviceGetModulePropertiesRpcM>);
struct ZeDeviceGetCommandQueueGroupPropertiesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 97;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_device_handle_t hDevice = {};
        uint32_t* pCount = {};
        ze_command_queue_group_properties_t* pCommandQueueGroupProperties = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->pCount == rhs.pCount;
            equal &= this->pCommandQueueGroupProperties == rhs.pCommandQueueGroupProperties;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_device_handle_t hDevice, uint32_t* pCount, ze_command_queue_group_properties_t* pCommandQueueGroupProperties);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits pCommandQueueGroupProperties = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t pCount;
        uint32_t countPCommandQueueGroupProperties = 0;
        ze_command_queue_group_properties_t pCommandQueueGroupProperties[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPCommandQueueGroupProperties = dynamicTraits.pCommandQueueGroupProperties.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeDeviceGetCommandQueueGroupPropertiesRpcM() = default;

    ZeDeviceGetCommandQueueGroupPropertiesRpcM(const Captures::DynamicTraits &dynamicTraits, ze_device_handle_t hDevice, uint32_t* pCount, ze_command_queue_group_properties_t* pCommandQueueGroupProperties) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.pCount = pCount;
        args.pCommandQueueGroupProperties = pCommandQueueGroupProperties;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeDeviceGetCommandQueueGroupPropertiesRpcM &message, ze_device_handle_t hDevice, uint32_t* pCount, ze_command_queue_group_properties_t* pCommandQueueGroupProperties) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.pCount = pCount;
        message.args.pCommandQueueGroupProperties = pCommandQueueGroupProperties;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            captures.pCount = *args.pCount;
        }
        if(args.pCommandQueueGroupProperties){
            memcpy(asMemcpyDstT(captures.pCommandQueueGroupProperties), args.pCommandQueueGroupProperties, dynMemTraits.pCommandQueueGroupProperties.size);
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            *args.pCount = captures.pCount;
        }
        if(args.pCommandQueueGroupProperties){
            memcpy(args.pCommandQueueGroupProperties, captures.pCommandQueueGroupProperties, dynMemTraits.pCommandQueueGroupProperties.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeDeviceGetCommandQueueGroupPropertiesRpcM>);
struct ZeDeviceGetMemoryPropertiesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 98;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_device_handle_t hDevice = {};
        uint32_t* pCount = {};
        ze_device_memory_properties_t* pMemProperties = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->pCount == rhs.pCount;
            equal &= this->pMemProperties == rhs.pMemProperties;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_device_handle_t hDevice, uint32_t* pCount, ze_device_memory_properties_t* pMemProperties);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits pMemProperties = {};          
            uint32_t dynamicStructMembersOffset = 0;
            DynamicArgTraits pMemPropertiesNestedTraits = {};
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t pCount;
        uint32_t countPMemProperties = 0;
        uint32_t dynamicStructMembersOffset = 0;
        uint32_t pMemPropertiesNestedTraitsOffset = 0;
        uint32_t pMemPropertiesNestedTraitsCount = 0;
        ze_device_memory_properties_t* getPMemProperties() {
            auto offset = 0;
            return reinterpret_cast<ze_device_memory_properties_t*>(dynMem + offset);
        }


        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPMemProperties = dynamicTraits.pMemProperties.count;
            dynamicStructMembersOffset = dynamicTraits.dynamicStructMembersOffset;
            pMemPropertiesNestedTraitsOffset = dynamicTraits.pMemPropertiesNestedTraits.offset;
            pMemPropertiesNestedTraitsCount = dynamicTraits.pMemPropertiesNestedTraits.count;
            dynMemSize = dynamicTraits.totalDynamicSize;
        }
        
        uint32_t dynMemSize = 0;
        alignas(8) char dynMem[];
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;
        void reassembleNestedStructs() {
            using Cal::Utils::alignUpPow2;

            uint32_t currentOffset = dynamicStructMembersOffset;

            if(pMemPropertiesNestedTraitsCount > 0){
                assert(currentOffset == pMemPropertiesNestedTraitsOffset);
                auto* pMemPropertiesTraits = reinterpret_cast<DynamicStructTraits<ze_device_memory_properties_t>*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(pMemPropertiesNestedTraitsCount * sizeof(DynamicStructTraits<ze_device_memory_properties_t>));
                auto *destPMemProperties = getPMemProperties();

                for (uint32_t i = 0; i < pMemPropertiesNestedTraitsCount; ++i) {
                    if(pMemPropertiesTraits[i].pNextOffset == -1){
                        forcePointerWrite(destPMemProperties[i].pNext, nullptr);
                        continue;
                    }

                    auto pMemPropertiesPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                    currentOffset += alignUpPow2<8>(pMemPropertiesTraits[i].pNextCount * sizeof(NestedPNextTraits));

                    assert(currentOffset == static_cast<uint32_t>(pMemPropertiesPNextListElementTraits[0].extensionOffset));
                    forcePointerWrite(destPMemProperties[i].pNext, dynMem + pMemPropertiesPNextListElementTraits[0].extensionOffset);
                    currentOffset += alignUpPow2<8>(getUnderlyingSize(static_cast<const ze_base_desc_t*>(destPMemProperties[i].pNext)));

                    auto pMemPropertiesPNextListElement = static_cast<const ze_base_desc_t*>(destPMemProperties[i].pNext);
                    for(int32_t j = 1; j <= pMemPropertiesTraits[i].pNextCount; ++j){
                        if (j < pMemPropertiesTraits[i].pNextCount) {
                            const auto extensionOffset = pMemPropertiesPNextListElementTraits[j].extensionOffset;
                            forcePointerWrite(getNextField(*pMemPropertiesPNextListElement), dynMem + extensionOffset);
                        }

                        if (j < pMemPropertiesTraits[i].pNextCount) {
                            const auto pNextElement = getNext(pMemPropertiesPNextListElement);
                            const auto sizeInBytes = getUnderlyingSize(pNextElement);
                            currentOffset += alignUpPow2<8>(sizeInBytes);

                            pMemPropertiesPNextListElement = pNextElement;
                        }

                    }

                }
        }
    }

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeDeviceGetMemoryPropertiesRpcM() = default;

    ZeDeviceGetMemoryPropertiesRpcM(const Captures::DynamicTraits &dynamicTraits, ze_device_handle_t hDevice, uint32_t* pCount, ze_device_memory_properties_t* pMemProperties) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.pCount = pCount;
        args.pMemProperties = pMemProperties;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeDeviceGetMemoryPropertiesRpcM &message, ze_device_handle_t hDevice, uint32_t* pCount, ze_device_memory_properties_t* pMemProperties) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.pCount = pCount;
        message.args.pMemProperties = pMemProperties;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            captures.pCount = *args.pCount;
        }
        if(args.pMemProperties){
            memcpy(asMemcpyDstT(captures.getPMemProperties()), args.pMemProperties, dynMemTraits.pMemProperties.size);
        }
        using Cal::Utils::alignUpPow2;

        auto& dynMem = captures.dynMem;
        uint32_t currentOffset = captures.dynamicStructMembersOffset;
        if(args.pMemProperties){
            assert(currentOffset == captures.pMemPropertiesNestedTraitsOffset);
            auto* pMemPropertiesTraits = reinterpret_cast<DynamicStructTraits<ze_device_memory_properties_t>*>(dynMem + currentOffset);
            currentOffset += alignUpPow2<8>(captures.pMemPropertiesNestedTraitsCount * sizeof(DynamicStructTraits<ze_device_memory_properties_t>));

            for (uint32_t i = 0; i < captures.pMemPropertiesNestedTraitsCount; ++i) {
                const auto& pMemPropertiesPNext = args.pMemProperties[i].pNext;
                if(!pMemPropertiesPNext){
                    pMemPropertiesTraits[i].pNextOffset = -1;
                    pMemPropertiesTraits[i].pNextCount = -1;
                    continue;
                }

                const auto pMemPropertiesPNextCount = static_cast<int32_t>(countOpaqueList(static_cast<const ze_base_desc_t*>(args.pMemProperties[i].pNext)));
                if(!pMemPropertiesPNextCount){
                    pMemPropertiesTraits[i].pNextOffset = -1;
                    pMemPropertiesTraits[i].pNextCount = -1;
                    continue;
                }

                pMemPropertiesTraits[i].pNextOffset = currentOffset;
                pMemPropertiesTraits[i].pNextCount = pMemPropertiesPNextCount;
                pMemPropertiesTraits[i].pNextFirstOriginalElement = args.pMemProperties[i].pNext;

                auto pMemPropertiesPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(pMemPropertiesPNextCount * sizeof(NestedPNextTraits));

                auto pMemPropertiesPNextListElement = static_cast<const ze_base_desc_t*>(args.pMemProperties[i].pNext);
                for(int32_t j = 0; j < pMemPropertiesPNextCount; ++j){
                    pMemPropertiesPNextListElementTraits[j].extensionType = getExtensionType(pMemPropertiesPNextListElement);
                    pMemPropertiesPNextListElementTraits[j].extensionOffset = currentOffset;

                    const auto sizeInBytes = getUnderlyingSize(pMemPropertiesPNextListElement);
                    std::memcpy(dynMem + currentOffset, pMemPropertiesPNextListElement, sizeInBytes);
                    currentOffset += alignUpPow2<8>(sizeInBytes);

                    pMemPropertiesPNextListElement = getNext(pMemPropertiesPNextListElement);
                }

            }
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            *args.pCount = captures.pCount;
        }
        if(args.pMemProperties){
            memcpy(args.pMemProperties, captures.getPMemProperties(), dynMemTraits.pMemProperties.size);
        }
        using Cal::Utils::alignUpPow2;

        auto& dynMem = captures.dynMem;
        uint32_t currentOffset = captures.dynamicStructMembersOffset;
        if(args.pMemProperties) {
            assert(currentOffset == captures.pMemPropertiesNestedTraitsOffset);
            auto* pMemPropertiesTraits = reinterpret_cast<DynamicStructTraits<ze_device_memory_properties_t>*>(dynMem + currentOffset);
            currentOffset += alignUpPow2<8>(captures.pMemPropertiesNestedTraitsCount * sizeof(DynamicStructTraits<ze_device_memory_properties_t>));

            auto* destPMemProperties = args.pMemProperties;

            for (uint32_t i = 0; i < captures.pMemPropertiesNestedTraitsCount; ++i) {
                if(pMemPropertiesTraits[i].pNextOffset == -1){
                    continue;
                }

                destPMemProperties[i].pNext = pMemPropertiesTraits[i].pNextFirstOriginalElement;

                auto pMemPropertiesPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(pMemPropertiesTraits[i].pNextCount * sizeof(NestedPNextTraits));

                auto pMemPropertiesPNextListElement = static_cast<const ze_base_desc_t*>(destPMemProperties[i].pNext);
                for(int32_t j = 0; j < pMemPropertiesTraits[i].pNextCount; ++j){
                    const auto sizeInBytes = getUnderlyingSize(pMemPropertiesPNextListElement);
                    currentOffset += alignUpPow2<8>(sizeInBytes);

                    const auto extensionType = getExtensionType(pMemPropertiesPNextListElement);
                    if (!isReadOnly(extensionType)) {
                        {
                            auto originalNextOpaqueElement = getNext(pMemPropertiesPNextListElement);
                            const auto extensionOffset = pMemPropertiesPNextListElementTraits[j].extensionOffset;
                            auto destination = const_cast<ze_base_desc_t*>(pMemPropertiesPNextListElement);
                            std::memcpy(destination, dynMem + extensionOffset, sizeInBytes);

                            getNextField(*destination) = originalNextOpaqueElement;
                        }

                    }

                    pMemPropertiesPNextListElement = getNext(pMemPropertiesPNextListElement);
                }

            }
        }
    }
};
static_assert(std::is_standard_layout_v<ZeDeviceGetMemoryPropertiesRpcM>);
struct ZeDeviceGetMemoryAccessPropertiesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 99;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_device_handle_t hDevice = {};
        ze_device_memory_access_properties_t* pMemAccessProperties = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->pMemAccessProperties == rhs.pMemAccessProperties;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_device_memory_access_properties_t pMemAccessProperties;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeDeviceGetMemoryAccessPropertiesRpcM() = default;

    ZeDeviceGetMemoryAccessPropertiesRpcM(ze_device_handle_t hDevice, ze_device_memory_access_properties_t* pMemAccessProperties) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.pMemAccessProperties = pMemAccessProperties;
    }
    
    static void fillWithoutCapture(ZeDeviceGetMemoryAccessPropertiesRpcM &message, ze_device_handle_t hDevice, ze_device_memory_access_properties_t* pMemAccessProperties) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.pMemAccessProperties = pMemAccessProperties;
    }
    

    void copyFromCaller(){
        if(args.pMemAccessProperties){
            captures.pMemAccessProperties = *args.pMemAccessProperties;
        }
    }

    void copyToCaller(){
        if(args.pMemAccessProperties){
            *args.pMemAccessProperties = captures.pMemAccessProperties;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeDeviceGetMemoryAccessPropertiesRpcM>);
struct ZeDeviceGetCachePropertiesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 100;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_device_handle_t hDevice = {};
        uint32_t* pCount = {};
        ze_device_cache_properties_t* pCacheProperties = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->pCount == rhs.pCount;
            equal &= this->pCacheProperties == rhs.pCacheProperties;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_device_handle_t hDevice, uint32_t* pCount, ze_device_cache_properties_t* pCacheProperties);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits pCacheProperties = {};          
            uint32_t dynamicStructMembersOffset = 0;
            DynamicArgTraits pCachePropertiesNestedTraits = {};
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t pCount;
        uint32_t countPCacheProperties = 0;
        uint32_t dynamicStructMembersOffset = 0;
        uint32_t pCachePropertiesNestedTraitsOffset = 0;
        uint32_t pCachePropertiesNestedTraitsCount = 0;
        ze_device_cache_properties_t* getPCacheProperties() {
            auto offset = 0;
            return reinterpret_cast<ze_device_cache_properties_t*>(dynMem + offset);
        }


        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPCacheProperties = dynamicTraits.pCacheProperties.count;
            dynamicStructMembersOffset = dynamicTraits.dynamicStructMembersOffset;
            pCachePropertiesNestedTraitsOffset = dynamicTraits.pCachePropertiesNestedTraits.offset;
            pCachePropertiesNestedTraitsCount = dynamicTraits.pCachePropertiesNestedTraits.count;
            dynMemSize = dynamicTraits.totalDynamicSize;
        }
        
        uint32_t dynMemSize = 0;
        alignas(8) char dynMem[];
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;
        void reassembleNestedStructs() {
            using Cal::Utils::alignUpPow2;

            uint32_t currentOffset = dynamicStructMembersOffset;

            if(pCachePropertiesNestedTraitsCount > 0){
                assert(currentOffset == pCachePropertiesNestedTraitsOffset);
                auto* pCachePropertiesTraits = reinterpret_cast<DynamicStructTraits<ze_device_cache_properties_t>*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(pCachePropertiesNestedTraitsCount * sizeof(DynamicStructTraits<ze_device_cache_properties_t>));
                auto *destPCacheProperties = getPCacheProperties();

                for (uint32_t i = 0; i < pCachePropertiesNestedTraitsCount; ++i) {
                    if(pCachePropertiesTraits[i].pNextOffset == -1){
                        forcePointerWrite(destPCacheProperties[i].pNext, nullptr);
                        continue;
                    }

                    auto pCachePropertiesPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                    currentOffset += alignUpPow2<8>(pCachePropertiesTraits[i].pNextCount * sizeof(NestedPNextTraits));

                    assert(currentOffset == static_cast<uint32_t>(pCachePropertiesPNextListElementTraits[0].extensionOffset));
                    forcePointerWrite(destPCacheProperties[i].pNext, dynMem + pCachePropertiesPNextListElementTraits[0].extensionOffset);
                    currentOffset += alignUpPow2<8>(getUnderlyingSize(static_cast<const ze_base_desc_t*>(destPCacheProperties[i].pNext)));

                    auto pCachePropertiesPNextListElement = static_cast<const ze_base_desc_t*>(destPCacheProperties[i].pNext);
                    for(int32_t j = 1; j <= pCachePropertiesTraits[i].pNextCount; ++j){
                        if (j < pCachePropertiesTraits[i].pNextCount) {
                            const auto extensionOffset = pCachePropertiesPNextListElementTraits[j].extensionOffset;
                            forcePointerWrite(getNextField(*pCachePropertiesPNextListElement), dynMem + extensionOffset);
                        }

                        if (j < pCachePropertiesTraits[i].pNextCount) {
                            const auto pNextElement = getNext(pCachePropertiesPNextListElement);
                            const auto sizeInBytes = getUnderlyingSize(pNextElement);
                            currentOffset += alignUpPow2<8>(sizeInBytes);

                            pCachePropertiesPNextListElement = pNextElement;
                        }

                    }

                }
        }
    }

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeDeviceGetCachePropertiesRpcM() = default;

    ZeDeviceGetCachePropertiesRpcM(const Captures::DynamicTraits &dynamicTraits, ze_device_handle_t hDevice, uint32_t* pCount, ze_device_cache_properties_t* pCacheProperties) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.pCount = pCount;
        args.pCacheProperties = pCacheProperties;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeDeviceGetCachePropertiesRpcM &message, ze_device_handle_t hDevice, uint32_t* pCount, ze_device_cache_properties_t* pCacheProperties) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.pCount = pCount;
        message.args.pCacheProperties = pCacheProperties;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            captures.pCount = *args.pCount;
        }
        if(args.pCacheProperties){
            memcpy(asMemcpyDstT(captures.getPCacheProperties()), args.pCacheProperties, dynMemTraits.pCacheProperties.size);
        }
        using Cal::Utils::alignUpPow2;

        auto& dynMem = captures.dynMem;
        uint32_t currentOffset = captures.dynamicStructMembersOffset;
        if(args.pCacheProperties){
            assert(currentOffset == captures.pCachePropertiesNestedTraitsOffset);
            auto* pCachePropertiesTraits = reinterpret_cast<DynamicStructTraits<ze_device_cache_properties_t>*>(dynMem + currentOffset);
            currentOffset += alignUpPow2<8>(captures.pCachePropertiesNestedTraitsCount * sizeof(DynamicStructTraits<ze_device_cache_properties_t>));

            for (uint32_t i = 0; i < captures.pCachePropertiesNestedTraitsCount; ++i) {
                const auto& pCachePropertiesPNext = args.pCacheProperties[i].pNext;
                if(!pCachePropertiesPNext){
                    pCachePropertiesTraits[i].pNextOffset = -1;
                    pCachePropertiesTraits[i].pNextCount = -1;
                    continue;
                }

                const auto pCachePropertiesPNextCount = static_cast<int32_t>(countOpaqueList(static_cast<const ze_base_desc_t*>(args.pCacheProperties[i].pNext)));
                if(!pCachePropertiesPNextCount){
                    pCachePropertiesTraits[i].pNextOffset = -1;
                    pCachePropertiesTraits[i].pNextCount = -1;
                    continue;
                }

                pCachePropertiesTraits[i].pNextOffset = currentOffset;
                pCachePropertiesTraits[i].pNextCount = pCachePropertiesPNextCount;
                pCachePropertiesTraits[i].pNextFirstOriginalElement = args.pCacheProperties[i].pNext;

                auto pCachePropertiesPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(pCachePropertiesPNextCount * sizeof(NestedPNextTraits));

                auto pCachePropertiesPNextListElement = static_cast<const ze_base_desc_t*>(args.pCacheProperties[i].pNext);
                for(int32_t j = 0; j < pCachePropertiesPNextCount; ++j){
                    pCachePropertiesPNextListElementTraits[j].extensionType = getExtensionType(pCachePropertiesPNextListElement);
                    pCachePropertiesPNextListElementTraits[j].extensionOffset = currentOffset;

                    const auto sizeInBytes = getUnderlyingSize(pCachePropertiesPNextListElement);
                    std::memcpy(dynMem + currentOffset, pCachePropertiesPNextListElement, sizeInBytes);
                    currentOffset += alignUpPow2<8>(sizeInBytes);

                    pCachePropertiesPNextListElement = getNext(pCachePropertiesPNextListElement);
                }

            }
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            *args.pCount = captures.pCount;
        }
        if(args.pCacheProperties){
            memcpy(args.pCacheProperties, captures.getPCacheProperties(), dynMemTraits.pCacheProperties.size);
        }
        using Cal::Utils::alignUpPow2;

        auto& dynMem = captures.dynMem;
        uint32_t currentOffset = captures.dynamicStructMembersOffset;
        if(args.pCacheProperties) {
            assert(currentOffset == captures.pCachePropertiesNestedTraitsOffset);
            auto* pCachePropertiesTraits = reinterpret_cast<DynamicStructTraits<ze_device_cache_properties_t>*>(dynMem + currentOffset);
            currentOffset += alignUpPow2<8>(captures.pCachePropertiesNestedTraitsCount * sizeof(DynamicStructTraits<ze_device_cache_properties_t>));

            auto* destPCacheProperties = args.pCacheProperties;

            for (uint32_t i = 0; i < captures.pCachePropertiesNestedTraitsCount; ++i) {
                if(pCachePropertiesTraits[i].pNextOffset == -1){
                    continue;
                }

                destPCacheProperties[i].pNext = pCachePropertiesTraits[i].pNextFirstOriginalElement;

                auto pCachePropertiesPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(pCachePropertiesTraits[i].pNextCount * sizeof(NestedPNextTraits));

                auto pCachePropertiesPNextListElement = static_cast<const ze_base_desc_t*>(destPCacheProperties[i].pNext);
                for(int32_t j = 0; j < pCachePropertiesTraits[i].pNextCount; ++j){
                    const auto sizeInBytes = getUnderlyingSize(pCachePropertiesPNextListElement);
                    currentOffset += alignUpPow2<8>(sizeInBytes);

                    const auto extensionType = getExtensionType(pCachePropertiesPNextListElement);
                    if (!isReadOnly(extensionType)) {
                        {
                            auto originalNextOpaqueElement = getNext(pCachePropertiesPNextListElement);
                            const auto extensionOffset = pCachePropertiesPNextListElementTraits[j].extensionOffset;
                            auto destination = const_cast<ze_base_desc_t*>(pCachePropertiesPNextListElement);
                            std::memcpy(destination, dynMem + extensionOffset, sizeInBytes);

                            getNextField(*destination) = originalNextOpaqueElement;
                        }

                    }

                    pCachePropertiesPNextListElement = getNext(pCachePropertiesPNextListElement);
                }

            }
        }
    }
};
static_assert(std::is_standard_layout_v<ZeDeviceGetCachePropertiesRpcM>);
struct ZeDeviceGetImagePropertiesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 101;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_device_handle_t hDevice = {};
        ze_device_image_properties_t* pImageProperties = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->pImageProperties == rhs.pImageProperties;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_device_image_properties_t pImageProperties;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeDeviceGetImagePropertiesRpcM() = default;

    ZeDeviceGetImagePropertiesRpcM(ze_device_handle_t hDevice, ze_device_image_properties_t* pImageProperties) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.pImageProperties = pImageProperties;
    }
    
    static void fillWithoutCapture(ZeDeviceGetImagePropertiesRpcM &message, ze_device_handle_t hDevice, ze_device_image_properties_t* pImageProperties) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.pImageProperties = pImageProperties;
    }
    

    void copyFromCaller(){
        if(args.pImageProperties){
            captures.pImageProperties = *args.pImageProperties;
        }
    }

    void copyToCaller(){
        if(args.pImageProperties){
            *args.pImageProperties = captures.pImageProperties;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeDeviceGetImagePropertiesRpcM>);
struct ZeDeviceGetExternalMemoryPropertiesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 102;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_device_handle_t hDevice = {};
        ze_device_external_memory_properties_t* pExternalMemoryProperties = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->pExternalMemoryProperties == rhs.pExternalMemoryProperties;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_device_external_memory_properties_t pExternalMemoryProperties;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeDeviceGetExternalMemoryPropertiesRpcM() = default;

    ZeDeviceGetExternalMemoryPropertiesRpcM(ze_device_handle_t hDevice, ze_device_external_memory_properties_t* pExternalMemoryProperties) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.pExternalMemoryProperties = pExternalMemoryProperties;
    }
    
    static void fillWithoutCapture(ZeDeviceGetExternalMemoryPropertiesRpcM &message, ze_device_handle_t hDevice, ze_device_external_memory_properties_t* pExternalMemoryProperties) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.pExternalMemoryProperties = pExternalMemoryProperties;
    }
    

    void copyFromCaller(){
        if(args.pExternalMemoryProperties){
            captures.pExternalMemoryProperties = *args.pExternalMemoryProperties;
        }
    }

    void copyToCaller(){
        if(args.pExternalMemoryProperties){
            *args.pExternalMemoryProperties = captures.pExternalMemoryProperties;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeDeviceGetExternalMemoryPropertiesRpcM>);
struct ZeDeviceGetP2PPropertiesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 103;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_device_handle_t hDevice = {};
        ze_device_handle_t hPeerDevice = {};
        ze_device_p2p_properties_t* pP2PProperties = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->hPeerDevice == rhs.hPeerDevice;
            equal &= this->pP2PProperties == rhs.pP2PProperties;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_device_handle_t hDevice, ze_device_handle_t hPeerDevice, ze_device_p2p_properties_t* pP2PProperties);
            uint32_t totalDynamicSize = 0;
            uint32_t dynamicStructMembersOffset = 0;
            DynamicArgTraits pP2PPropertiesNestedTraits = {};
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_device_p2p_properties_t pP2PProperties;
        uint32_t dynamicStructMembersOffset = 0;
        uint32_t pP2PPropertiesNestedTraitsOffset = 0;
        uint32_t pP2PPropertiesNestedTraitsCount = 0;

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
            dynamicStructMembersOffset = dynamicTraits.dynamicStructMembersOffset;
            pP2PPropertiesNestedTraitsOffset = dynamicTraits.pP2PPropertiesNestedTraits.offset;
            pP2PPropertiesNestedTraitsCount = dynamicTraits.pP2PPropertiesNestedTraits.count;
            dynMemSize = dynamicTraits.totalDynamicSize;
        }
        
        uint32_t dynMemSize = 0;
        alignas(8) char dynMem[];
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;
        void reassembleNestedStructs() {
            using Cal::Utils::alignUpPow2;

            uint32_t currentOffset = dynamicStructMembersOffset;

            if(pP2PPropertiesNestedTraitsCount > 0){
                assert(currentOffset == pP2PPropertiesNestedTraitsOffset);
                auto* pP2PPropertiesTraits = reinterpret_cast<DynamicStructTraits<ze_device_p2p_properties_t>*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(pP2PPropertiesNestedTraitsCount * sizeof(DynamicStructTraits<ze_device_p2p_properties_t>));
                auto* destPP2PProperties = &pP2PProperties;

                for (uint32_t i = 0; i < pP2PPropertiesNestedTraitsCount; ++i) {
                    if(pP2PPropertiesTraits[i].pNextOffset == -1){
                        forcePointerWrite(destPP2PProperties[i].pNext, nullptr);
                        continue;
                    }

                    auto pP2PPropertiesPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                    currentOffset += alignUpPow2<8>(pP2PPropertiesTraits[i].pNextCount * sizeof(NestedPNextTraits));

                    assert(currentOffset == static_cast<uint32_t>(pP2PPropertiesPNextListElementTraits[0].extensionOffset));
                    forcePointerWrite(destPP2PProperties[i].pNext, dynMem + pP2PPropertiesPNextListElementTraits[0].extensionOffset);
                    currentOffset += alignUpPow2<8>(getUnderlyingSize(static_cast<const ze_base_desc_t*>(destPP2PProperties[i].pNext)));

                    auto pP2PPropertiesPNextListElement = static_cast<const ze_base_desc_t*>(destPP2PProperties[i].pNext);
                    for(int32_t j = 1; j <= pP2PPropertiesTraits[i].pNextCount; ++j){
                        if (j < pP2PPropertiesTraits[i].pNextCount) {
                            const auto extensionOffset = pP2PPropertiesPNextListElementTraits[j].extensionOffset;
                            forcePointerWrite(getNextField(*pP2PPropertiesPNextListElement), dynMem + extensionOffset);
                        }

                        if (j < pP2PPropertiesTraits[i].pNextCount) {
                            const auto pNextElement = getNext(pP2PPropertiesPNextListElement);
                            const auto sizeInBytes = getUnderlyingSize(pNextElement);
                            currentOffset += alignUpPow2<8>(sizeInBytes);

                            pP2PPropertiesPNextListElement = pNextElement;
                        }

                    }

                }
        }
    }

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeDeviceGetP2PPropertiesRpcM() = default;

    ZeDeviceGetP2PPropertiesRpcM(const Captures::DynamicTraits &dynamicTraits, ze_device_handle_t hDevice, ze_device_handle_t hPeerDevice, ze_device_p2p_properties_t* pP2PProperties) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.hPeerDevice = hPeerDevice;
        args.pP2PProperties = pP2PProperties;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeDeviceGetP2PPropertiesRpcM &message, ze_device_handle_t hDevice, ze_device_handle_t hPeerDevice, ze_device_p2p_properties_t* pP2PProperties) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.hPeerDevice = hPeerDevice;
        message.args.pP2PProperties = pP2PProperties;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pP2PProperties){
            captures.pP2PProperties = *args.pP2PProperties;
        }
        using Cal::Utils::alignUpPow2;

        auto& dynMem = captures.dynMem;
        uint32_t currentOffset = captures.dynamicStructMembersOffset;
        if(args.pP2PProperties){
            assert(currentOffset == captures.pP2PPropertiesNestedTraitsOffset);
            auto* pP2PPropertiesTraits = reinterpret_cast<DynamicStructTraits<ze_device_p2p_properties_t>*>(dynMem + currentOffset);
            currentOffset += alignUpPow2<8>(captures.pP2PPropertiesNestedTraitsCount * sizeof(DynamicStructTraits<ze_device_p2p_properties_t>));

            for (uint32_t i = 0; i < captures.pP2PPropertiesNestedTraitsCount; ++i) {
                const auto& pP2PPropertiesPNext = args.pP2PProperties[i].pNext;
                if(!pP2PPropertiesPNext){
                    pP2PPropertiesTraits[i].pNextOffset = -1;
                    pP2PPropertiesTraits[i].pNextCount = -1;
                    continue;
                }

                const auto pP2PPropertiesPNextCount = static_cast<int32_t>(countOpaqueList(static_cast<const ze_base_desc_t*>(args.pP2PProperties[i].pNext)));
                if(!pP2PPropertiesPNextCount){
                    pP2PPropertiesTraits[i].pNextOffset = -1;
                    pP2PPropertiesTraits[i].pNextCount = -1;
                    continue;
                }

                pP2PPropertiesTraits[i].pNextOffset = currentOffset;
                pP2PPropertiesTraits[i].pNextCount = pP2PPropertiesPNextCount;
                pP2PPropertiesTraits[i].pNextFirstOriginalElement = args.pP2PProperties[i].pNext;

                auto pP2PPropertiesPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(pP2PPropertiesPNextCount * sizeof(NestedPNextTraits));

                auto pP2PPropertiesPNextListElement = static_cast<const ze_base_desc_t*>(args.pP2PProperties[i].pNext);
                for(int32_t j = 0; j < pP2PPropertiesPNextCount; ++j){
                    pP2PPropertiesPNextListElementTraits[j].extensionType = getExtensionType(pP2PPropertiesPNextListElement);
                    pP2PPropertiesPNextListElementTraits[j].extensionOffset = currentOffset;

                    const auto sizeInBytes = getUnderlyingSize(pP2PPropertiesPNextListElement);
                    std::memcpy(dynMem + currentOffset, pP2PPropertiesPNextListElement, sizeInBytes);
                    currentOffset += alignUpPow2<8>(sizeInBytes);

                    pP2PPropertiesPNextListElement = getNext(pP2PPropertiesPNextListElement);
                }

            }
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pP2PProperties){
            *args.pP2PProperties = captures.pP2PProperties;
        }
        using Cal::Utils::alignUpPow2;

        auto& dynMem = captures.dynMem;
        uint32_t currentOffset = captures.dynamicStructMembersOffset;
        if(args.pP2PProperties) {
            assert(currentOffset == captures.pP2PPropertiesNestedTraitsOffset);
            auto* pP2PPropertiesTraits = reinterpret_cast<DynamicStructTraits<ze_device_p2p_properties_t>*>(dynMem + currentOffset);
            currentOffset += alignUpPow2<8>(captures.pP2PPropertiesNestedTraitsCount * sizeof(DynamicStructTraits<ze_device_p2p_properties_t>));

            auto* destPP2PProperties = args.pP2PProperties;

            for (uint32_t i = 0; i < captures.pP2PPropertiesNestedTraitsCount; ++i) {
                if(pP2PPropertiesTraits[i].pNextOffset == -1){
                    continue;
                }

                destPP2PProperties[i].pNext = pP2PPropertiesTraits[i].pNextFirstOriginalElement;

                auto pP2PPropertiesPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(pP2PPropertiesTraits[i].pNextCount * sizeof(NestedPNextTraits));

                auto pP2PPropertiesPNextListElement = static_cast<const ze_base_desc_t*>(destPP2PProperties[i].pNext);
                for(int32_t j = 0; j < pP2PPropertiesTraits[i].pNextCount; ++j){
                    const auto sizeInBytes = getUnderlyingSize(pP2PPropertiesPNextListElement);
                    currentOffset += alignUpPow2<8>(sizeInBytes);

                    const auto extensionType = getExtensionType(pP2PPropertiesPNextListElement);
                    if (!isReadOnly(extensionType)) {
                        {
                            auto originalNextOpaqueElement = getNext(pP2PPropertiesPNextListElement);
                            const auto extensionOffset = pP2PPropertiesPNextListElementTraits[j].extensionOffset;
                            auto destination = const_cast<ze_base_desc_t*>(pP2PPropertiesPNextListElement);
                            std::memcpy(destination, dynMem + extensionOffset, sizeInBytes);

                            getNextField(*destination) = originalNextOpaqueElement;
                        }

                    }

                    pP2PPropertiesPNextListElement = getNext(pP2PPropertiesPNextListElement);
                }

            }
        }
    }
};
static_assert(std::is_standard_layout_v<ZeDeviceGetP2PPropertiesRpcM>);
struct ZeDeviceCanAccessPeerRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 104;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_device_handle_t hDevice = {};
        ze_device_handle_t hPeerDevice = {};
        ze_bool_t* value = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->hPeerDevice == rhs.hPeerDevice;
            equal &= this->value == rhs.value;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_bool_t value;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeDeviceCanAccessPeerRpcM() = default;

    ZeDeviceCanAccessPeerRpcM(ze_device_handle_t hDevice, ze_device_handle_t hPeerDevice, ze_bool_t* value) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.hPeerDevice = hPeerDevice;
        args.value = value;
    }
    
    static void fillWithoutCapture(ZeDeviceCanAccessPeerRpcM &message, ze_device_handle_t hDevice, ze_device_handle_t hPeerDevice, ze_bool_t* value) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.hPeerDevice = hPeerDevice;
        message.args.value = value;
    }
    

    void copyToCaller(){
        if(args.value){
            *args.value = captures.value;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeDeviceCanAccessPeerRpcM>);
struct ZeDeviceGetStatusRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 105;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_device_handle_t hDevice = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeDeviceGetStatusRpcM() = default;

    ZeDeviceGetStatusRpcM(ze_device_handle_t hDevice) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
    }
    
    static void fillWithoutCapture(ZeDeviceGetStatusRpcM &message, ze_device_handle_t hDevice) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
    }
    
};
static_assert(std::is_standard_layout_v<ZeDeviceGetStatusRpcM>);
struct ZeDeviceGetGlobalTimestampsRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 106;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_device_handle_t hDevice = {};
        uint64_t* hostTimestamp = {};
        uint64_t* deviceTimestamp = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->hostTimestamp == rhs.hostTimestamp;
            equal &= this->deviceTimestamp == rhs.deviceTimestamp;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint64_t hostTimestamp;
        uint64_t deviceTimestamp;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeDeviceGetGlobalTimestampsRpcM() = default;

    ZeDeviceGetGlobalTimestampsRpcM(ze_device_handle_t hDevice, uint64_t* hostTimestamp, uint64_t* deviceTimestamp) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.hostTimestamp = hostTimestamp;
        args.deviceTimestamp = deviceTimestamp;
    }
    
    static void fillWithoutCapture(ZeDeviceGetGlobalTimestampsRpcM &message, ze_device_handle_t hDevice, uint64_t* hostTimestamp, uint64_t* deviceTimestamp) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.hostTimestamp = hostTimestamp;
        message.args.deviceTimestamp = deviceTimestamp;
    }
    

    void copyToCaller(){
        if(args.hostTimestamp){
            *args.hostTimestamp = captures.hostTimestamp;
        }
        if(args.deviceTimestamp){
            *args.deviceTimestamp = captures.deviceTimestamp;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeDeviceGetGlobalTimestampsRpcM>);
struct ZeDeviceReserveCacheExtRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 107;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_device_handle_t hDevice = {};
        size_t cacheLevel = {};
        size_t cacheReservationSize = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->cacheLevel == rhs.cacheLevel;
            equal &= this->cacheReservationSize == rhs.cacheReservationSize;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeDeviceReserveCacheExtRpcM() = default;

    ZeDeviceReserveCacheExtRpcM(ze_device_handle_t hDevice, size_t cacheLevel, size_t cacheReservationSize) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.cacheLevel = cacheLevel;
        args.cacheReservationSize = cacheReservationSize;
    }
    
    static void fillWithoutCapture(ZeDeviceReserveCacheExtRpcM &message, ze_device_handle_t hDevice, size_t cacheLevel, size_t cacheReservationSize) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.cacheLevel = cacheLevel;
        message.args.cacheReservationSize = cacheReservationSize;
    }
    
};
static_assert(std::is_standard_layout_v<ZeDeviceReserveCacheExtRpcM>);
struct ZeDeviceSetCacheAdviceExtRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 108;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_device_handle_t hDevice = {};
        void* ptr = {};
        size_t regionSize = {};
        ze_cache_ext_region_t cacheRegion = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->ptr == rhs.ptr;
            equal &= this->regionSize == rhs.regionSize;
            equal &= this->cacheRegion == rhs.cacheRegion;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeDeviceSetCacheAdviceExtRpcM() = default;

    ZeDeviceSetCacheAdviceExtRpcM(ze_device_handle_t hDevice, void* ptr, size_t regionSize, ze_cache_ext_region_t cacheRegion) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.ptr = ptr;
        args.regionSize = regionSize;
        args.cacheRegion = cacheRegion;
    }
    
    static void fillWithoutCapture(ZeDeviceSetCacheAdviceExtRpcM &message, ze_device_handle_t hDevice, void* ptr, size_t regionSize, ze_cache_ext_region_t cacheRegion) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.ptr = ptr;
        message.args.regionSize = regionSize;
        message.args.cacheRegion = cacheRegion;
    }
    
};
static_assert(std::is_standard_layout_v<ZeDeviceSetCacheAdviceExtRpcM>);
struct ZeDriverGetRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 109;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        uint32_t* pCount = {};
        ze_driver_handle_t* phDrivers = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->pCount == rhs.pCount;
            equal &= this->phDrivers == rhs.phDrivers;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(uint32_t* pCount, ze_driver_handle_t* phDrivers);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phDrivers = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t pCount;
        uint32_t countPhDrivers = 0;
        ze_driver_handle_t phDrivers[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhDrivers = dynamicTraits.phDrivers.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeDriverGetRpcM() = default;

    ZeDriverGetRpcM(const Captures::DynamicTraits &dynamicTraits, uint32_t* pCount, ze_driver_handle_t* phDrivers) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.pCount = pCount;
        args.phDrivers = phDrivers;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeDriverGetRpcM &message, uint32_t* pCount, ze_driver_handle_t* phDrivers) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.pCount = pCount;
        message.args.phDrivers = phDrivers;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            captures.pCount = *args.pCount;
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            *args.pCount = captures.pCount;
        }
        if(args.phDrivers){
            memcpy(args.phDrivers, captures.phDrivers, dynMemTraits.phDrivers.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeDriverGetRpcM>);
struct ZeDriverGetApiVersionRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 110;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_driver_handle_t hDriver = {};
        ze_api_version_t* version = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDriver == rhs.hDriver;
            equal &= this->version == rhs.version;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_api_version_t version;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeDriverGetApiVersionRpcM() = default;

    ZeDriverGetApiVersionRpcM(ze_driver_handle_t hDriver, ze_api_version_t* version) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDriver = hDriver;
        args.version = version;
    }
    
    static void fillWithoutCapture(ZeDriverGetApiVersionRpcM &message, ze_driver_handle_t hDriver, ze_api_version_t* version) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDriver = hDriver;
        message.args.version = version;
    }
    

    void copyToCaller(){
        if(args.version){
            *args.version = captures.version;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeDriverGetApiVersionRpcM>);
struct ZeDriverGetPropertiesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 111;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_driver_handle_t hDriver = {};
        ze_driver_properties_t* pDriverProperties = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDriver == rhs.hDriver;
            equal &= this->pDriverProperties == rhs.pDriverProperties;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_driver_properties_t pDriverProperties;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeDriverGetPropertiesRpcM() = default;

    ZeDriverGetPropertiesRpcM(ze_driver_handle_t hDriver, ze_driver_properties_t* pDriverProperties) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDriver = hDriver;
        args.pDriverProperties = pDriverProperties;
    }
    
    static void fillWithoutCapture(ZeDriverGetPropertiesRpcM &message, ze_driver_handle_t hDriver, ze_driver_properties_t* pDriverProperties) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDriver = hDriver;
        message.args.pDriverProperties = pDriverProperties;
    }
    

    void copyFromCaller(){
        if(args.pDriverProperties){
            captures.pDriverProperties = *args.pDriverProperties;
        }
    }

    void copyToCaller(){
        if(args.pDriverProperties){
            *args.pDriverProperties = captures.pDriverProperties;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeDriverGetPropertiesRpcM>);
struct ZeDriverGetIpcPropertiesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 112;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_driver_handle_t hDriver = {};
        ze_driver_ipc_properties_t* pIpcProperties = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDriver == rhs.hDriver;
            equal &= this->pIpcProperties == rhs.pIpcProperties;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_driver_ipc_properties_t pIpcProperties;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeDriverGetIpcPropertiesRpcM() = default;

    ZeDriverGetIpcPropertiesRpcM(ze_driver_handle_t hDriver, ze_driver_ipc_properties_t* pIpcProperties) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDriver = hDriver;
        args.pIpcProperties = pIpcProperties;
    }
    
    static void fillWithoutCapture(ZeDriverGetIpcPropertiesRpcM &message, ze_driver_handle_t hDriver, ze_driver_ipc_properties_t* pIpcProperties) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDriver = hDriver;
        message.args.pIpcProperties = pIpcProperties;
    }
    

    void copyFromCaller(){
        if(args.pIpcProperties){
            captures.pIpcProperties = *args.pIpcProperties;
        }
    }

    void copyToCaller(){
        if(args.pIpcProperties){
            *args.pIpcProperties = captures.pIpcProperties;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeDriverGetIpcPropertiesRpcM>);
struct ZeDriverGetExtensionPropertiesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 113;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_driver_handle_t hDriver = {};
        uint32_t* pCount = {};
        ze_driver_extension_properties_t* pExtensionProperties = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDriver == rhs.hDriver;
            equal &= this->pCount == rhs.pCount;
            equal &= this->pExtensionProperties == rhs.pExtensionProperties;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_driver_handle_t hDriver, uint32_t* pCount, ze_driver_extension_properties_t* pExtensionProperties);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits pExtensionProperties = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t pCount;
        uint32_t countPExtensionProperties = 0;
        ze_driver_extension_properties_t pExtensionProperties[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPExtensionProperties = dynamicTraits.pExtensionProperties.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeDriverGetExtensionPropertiesRpcM() = default;

    ZeDriverGetExtensionPropertiesRpcM(const Captures::DynamicTraits &dynamicTraits, ze_driver_handle_t hDriver, uint32_t* pCount, ze_driver_extension_properties_t* pExtensionProperties) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDriver = hDriver;
        args.pCount = pCount;
        args.pExtensionProperties = pExtensionProperties;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeDriverGetExtensionPropertiesRpcM &message, ze_driver_handle_t hDriver, uint32_t* pCount, ze_driver_extension_properties_t* pExtensionProperties) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDriver = hDriver;
        message.args.pCount = pCount;
        message.args.pExtensionProperties = pExtensionProperties;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            captures.pCount = *args.pCount;
        }
        if(args.pExtensionProperties){
            memcpy(asMemcpyDstT(captures.pExtensionProperties), args.pExtensionProperties, dynMemTraits.pExtensionProperties.size);
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            *args.pCount = captures.pCount;
        }
        if(args.pExtensionProperties){
            memcpy(args.pExtensionProperties, captures.pExtensionProperties, dynMemTraits.pExtensionProperties.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeDriverGetExtensionPropertiesRpcM>);
 // zeDriverGetExtensionFunctionAddress ignored in generator - based on dont_generate_rpc_message flag
struct ZeEventPoolCreateRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 114;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_context_handle_t hContext = {};
        const ze_event_pool_desc_t* desc = {};
        uint32_t numDevices = {};
        ze_device_handle_t* phDevices = {};
        ze_event_pool_handle_t* phEventPool = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hContext == rhs.hContext;
            equal &= this->desc == rhs.desc;
            equal &= this->numDevices == rhs.numDevices;
            equal &= this->phDevices == rhs.phDevices;
            equal &= this->phEventPool == rhs.phEventPool;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_context_handle_t hContext, const ze_event_pool_desc_t* desc, uint32_t numDevices, ze_device_handle_t* phDevices, ze_event_pool_handle_t* phEventPool);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phDevices = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_event_pool_desc_t desc;
        ze_event_pool_handle_t phEventPool;
        uint32_t countPhDevices = 0;
        ze_device_handle_t phDevices[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhDevices = dynamicTraits.phDevices.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeEventPoolCreateRpcM() = default;

    ZeEventPoolCreateRpcM(const Captures::DynamicTraits &dynamicTraits, ze_context_handle_t hContext, const ze_event_pool_desc_t* desc, uint32_t numDevices, ze_device_handle_t* phDevices, ze_event_pool_handle_t* phEventPool) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hContext = hContext;
        args.desc = desc;
        args.numDevices = numDevices;
        args.phDevices = phDevices;
        args.phEventPool = phEventPool;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeEventPoolCreateRpcM &message, ze_context_handle_t hContext, const ze_event_pool_desc_t* desc, uint32_t numDevices, ze_device_handle_t* phDevices, ze_event_pool_handle_t* phEventPool) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hContext = hContext;
        message.args.desc = desc;
        message.args.numDevices = numDevices;
        message.args.phDevices = phDevices;
        message.args.phEventPool = phEventPool;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.desc){
            captures.desc = *args.desc;
        }
        if(args.phDevices){
            memcpy(asMemcpyDstT(captures.phDevices), args.phDevices, dynMemTraits.phDevices.size);
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phEventPool){
            *args.phEventPool = captures.phEventPool;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeEventPoolCreateRpcM>);
struct ZeEventPoolDestroyRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 115;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_event_pool_handle_t hEventPool = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hEventPool == rhs.hEventPool;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeEventPoolDestroyRpcM() = default;

    ZeEventPoolDestroyRpcM(ze_event_pool_handle_t hEventPool) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hEventPool = hEventPool;
    }
    
    static void fillWithoutCapture(ZeEventPoolDestroyRpcM &message, ze_event_pool_handle_t hEventPool) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hEventPool = hEventPool;
    }
    
};
static_assert(std::is_standard_layout_v<ZeEventPoolDestroyRpcM>);
struct ZeEventCreateRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 116;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_event_pool_handle_t hEventPool = {};
        const ze_event_desc_t* desc = {};
        ze_event_handle_t* phEvent = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hEventPool == rhs.hEventPool;
            equal &= this->desc == rhs.desc;
            equal &= this->phEvent == rhs.phEvent;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_event_desc_t desc;
        ze_event_handle_t phEvent;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeEventCreateRpcM() = default;

    ZeEventCreateRpcM(ze_event_pool_handle_t hEventPool, const ze_event_desc_t* desc, ze_event_handle_t* phEvent) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hEventPool = hEventPool;
        args.desc = desc;
        args.phEvent = phEvent;
    }
    
    static void fillWithoutCapture(ZeEventCreateRpcM &message, ze_event_pool_handle_t hEventPool, const ze_event_desc_t* desc, ze_event_handle_t* phEvent) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hEventPool = hEventPool;
        message.args.desc = desc;
        message.args.phEvent = phEvent;
    }
    

    void copyFromCaller(){
        if(args.desc){
            captures.desc = *args.desc;
        }
    }

    void copyToCaller(){
        if(args.phEvent){
            *args.phEvent = captures.phEvent;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeEventCreateRpcM>);
struct ZeEventDestroyRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 117;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_event_handle_t hEvent = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hEvent == rhs.hEvent;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeEventDestroyRpcM() = default;

    ZeEventDestroyRpcM(ze_event_handle_t hEvent) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hEvent = hEvent;
    }
    
    static void fillWithoutCapture(ZeEventDestroyRpcM &message, ze_event_handle_t hEvent) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hEvent = hEvent;
    }
    
};
static_assert(std::is_standard_layout_v<ZeEventDestroyRpcM>);
struct ZeEventPoolGetIpcHandleRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 118;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_event_pool_handle_t hEventPool = {};
        ze_ipc_event_pool_handle_t* phIpc = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hEventPool == rhs.hEventPool;
            equal &= this->phIpc == rhs.phIpc;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_ipc_event_pool_handle_t phIpc;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeEventPoolGetIpcHandleRpcM() = default;

    ZeEventPoolGetIpcHandleRpcM(ze_event_pool_handle_t hEventPool, ze_ipc_event_pool_handle_t* phIpc) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hEventPool = hEventPool;
        args.phIpc = phIpc;
    }
    
    static void fillWithoutCapture(ZeEventPoolGetIpcHandleRpcM &message, ze_event_pool_handle_t hEventPool, ze_ipc_event_pool_handle_t* phIpc) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hEventPool = hEventPool;
        message.args.phIpc = phIpc;
    }
    

    void copyToCaller(){
        if(args.phIpc){
            *args.phIpc = captures.phIpc;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeEventPoolGetIpcHandleRpcM>);
struct ZeEventPoolOpenIpcHandleRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 119;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_context_handle_t hContext = {};
        ze_ipc_event_pool_handle_t hIpc = {};
        ze_event_pool_handle_t* phEventPool = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hContext == rhs.hContext;
            equal &= this->hIpc == rhs.hIpc;
            equal &= this->phEventPool == rhs.phEventPool;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_event_pool_handle_t phEventPool;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeEventPoolOpenIpcHandleRpcM() = default;

    ZeEventPoolOpenIpcHandleRpcM(ze_context_handle_t hContext, ze_ipc_event_pool_handle_t hIpc, ze_event_pool_handle_t* phEventPool) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hContext = hContext;
        args.hIpc = hIpc;
        args.phEventPool = phEventPool;
    }
    
    static void fillWithoutCapture(ZeEventPoolOpenIpcHandleRpcM &message, ze_context_handle_t hContext, ze_ipc_event_pool_handle_t hIpc, ze_event_pool_handle_t* phEventPool) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hContext = hContext;
        message.args.hIpc = hIpc;
        message.args.phEventPool = phEventPool;
    }
    

    void copyToCaller(){
        if(args.phEventPool){
            *args.phEventPool = captures.phEventPool;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeEventPoolOpenIpcHandleRpcM>);
struct ZeEventPoolCloseIpcHandleRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 120;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_event_pool_handle_t hEventPool = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hEventPool == rhs.hEventPool;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeEventPoolCloseIpcHandleRpcM() = default;

    ZeEventPoolCloseIpcHandleRpcM(ze_event_pool_handle_t hEventPool) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hEventPool = hEventPool;
    }
    
    static void fillWithoutCapture(ZeEventPoolCloseIpcHandleRpcM &message, ze_event_pool_handle_t hEventPool) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hEventPool = hEventPool;
    }
    
};
static_assert(std::is_standard_layout_v<ZeEventPoolCloseIpcHandleRpcM>);
struct ZeCommandListAppendBarrierRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 121;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendBarrierRpcM() = default;

    ZeCommandListAppendBarrierRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendBarrierRpcM &message, ze_command_list_handle_t hCommandList, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendBarrierRpcM>);
struct ZeCommandListAppendSignalEventRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 122;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        ze_event_handle_t hEvent = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->hEvent == rhs.hEvent;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendSignalEventRpcM() = default;

    ZeCommandListAppendSignalEventRpcM(ze_command_list_handle_t hCommandList, ze_event_handle_t hEvent) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.hEvent = hEvent;
    }
    
    static void fillWithoutCapture(ZeCommandListAppendSignalEventRpcM &message, ze_command_list_handle_t hCommandList, ze_event_handle_t hEvent) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.hEvent = hEvent;
    }
    
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendSignalEventRpcM>);
struct ZeCommandListAppendWaitOnEventsRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 123;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        uint32_t numEvents = {};
        ze_event_handle_t* phEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->numEvents == rhs.numEvents;
            equal &= this->phEvents == rhs.phEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, uint32_t numEvents, ze_event_handle_t* phEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhEvents = 0;
        ze_event_handle_t phEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhEvents = dynamicTraits.phEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendWaitOnEventsRpcM() = default;

    ZeCommandListAppendWaitOnEventsRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, uint32_t numEvents, ze_event_handle_t* phEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.numEvents = numEvents;
        args.phEvents = phEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendWaitOnEventsRpcM &message, ze_command_list_handle_t hCommandList, uint32_t numEvents, ze_event_handle_t* phEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.numEvents = numEvents;
        message.args.phEvents = phEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phEvents){
            memcpy(asMemcpyDstT(captures.phEvents), args.phEvents, dynMemTraits.phEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendWaitOnEventsRpcM>);
struct ZeEventHostSignalRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 124;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_event_handle_t hEvent = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hEvent == rhs.hEvent;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeEventHostSignalRpcM() = default;

    ZeEventHostSignalRpcM(ze_event_handle_t hEvent) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hEvent = hEvent;
    }
    
    static void fillWithoutCapture(ZeEventHostSignalRpcM &message, ze_event_handle_t hEvent) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hEvent = hEvent;
    }
    
};
static_assert(std::is_standard_layout_v<ZeEventHostSignalRpcM>);
struct ZeEventHostSynchronizeRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 125;
    static constexpr float latency = 2.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_event_handle_t hEvent = {};
        uint64_t timeout = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hEvent == rhs.hEvent;
            equal &= this->timeout == rhs.timeout;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeEventHostSynchronizeRpcM() = default;

    ZeEventHostSynchronizeRpcM(ze_event_handle_t hEvent, uint64_t timeout) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hEvent = hEvent;
        args.timeout = timeout;
    }
    
    static void fillWithoutCapture(ZeEventHostSynchronizeRpcM &message, ze_event_handle_t hEvent, uint64_t timeout) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hEvent = hEvent;
        message.args.timeout = timeout;
    }
    
};
static_assert(std::is_standard_layout_v<ZeEventHostSynchronizeRpcM>);
struct ZeEventQueryStatusRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 126;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_event_handle_t hEvent = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hEvent == rhs.hEvent;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeEventQueryStatusRpcM() = default;

    ZeEventQueryStatusRpcM(ze_event_handle_t hEvent) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hEvent = hEvent;
    }
    
    static void fillWithoutCapture(ZeEventQueryStatusRpcM &message, ze_event_handle_t hEvent) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hEvent = hEvent;
    }
    
};
static_assert(std::is_standard_layout_v<ZeEventQueryStatusRpcM>);
struct ZeCommandListAppendEventResetRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 127;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        ze_event_handle_t hEvent = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->hEvent == rhs.hEvent;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendEventResetRpcM() = default;

    ZeCommandListAppendEventResetRpcM(ze_command_list_handle_t hCommandList, ze_event_handle_t hEvent) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.hEvent = hEvent;
    }
    
    static void fillWithoutCapture(ZeCommandListAppendEventResetRpcM &message, ze_command_list_handle_t hCommandList, ze_event_handle_t hEvent) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.hEvent = hEvent;
    }
    
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendEventResetRpcM>);
struct ZeEventHostResetRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 128;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_event_handle_t hEvent = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hEvent == rhs.hEvent;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeEventHostResetRpcM() = default;

    ZeEventHostResetRpcM(ze_event_handle_t hEvent) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hEvent = hEvent;
    }
    
    static void fillWithoutCapture(ZeEventHostResetRpcM &message, ze_event_handle_t hEvent) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hEvent = hEvent;
    }
    
};
static_assert(std::is_standard_layout_v<ZeEventHostResetRpcM>);
struct ZeEventQueryKernelTimestampRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 129;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_event_handle_t hEvent = {};
        ze_kernel_timestamp_result_t* dstptr = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hEvent == rhs.hEvent;
            equal &= this->dstptr == rhs.dstptr;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_kernel_timestamp_result_t dstptr;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeEventQueryKernelTimestampRpcM() = default;

    ZeEventQueryKernelTimestampRpcM(ze_event_handle_t hEvent, ze_kernel_timestamp_result_t* dstptr) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hEvent = hEvent;
        args.dstptr = dstptr;
    }
    
    static void fillWithoutCapture(ZeEventQueryKernelTimestampRpcM &message, ze_event_handle_t hEvent, ze_kernel_timestamp_result_t* dstptr) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hEvent = hEvent;
        message.args.dstptr = dstptr;
    }
    

    void copyToCaller(){
        if(args.dstptr){
            *args.dstptr = captures.dstptr;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeEventQueryKernelTimestampRpcM>);
struct ZeCommandListAppendQueryKernelTimestampsRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 130;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        uint32_t numEvents = {};
        ze_event_handle_t* phEvents = {};
        void* dstptr = {};
        const size_t* pOffsets = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->numEvents == rhs.numEvents;
            equal &= this->phEvents == rhs.phEvents;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->pOffsets == rhs.pOffsets;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, uint32_t numEvents, ze_event_handle_t* phEvents, void* dstptr, const size_t* pOffsets, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phEvents = {};          
            DynamicArgTraits dstptr = {};          
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t offsetDstptr = 0;
        uint32_t offsetPhWaitEvents = 0;
        uint32_t countPhEvents = 0;
        uint32_t countDstptr = 0;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t* getPhEvents() {
            auto offset = 0;
            return reinterpret_cast<ze_event_handle_t*>(dynMem + offset);
        }

        void* getDstptr() {
            auto offset = offsetDstptr;
            return reinterpret_cast<void*>(dynMem + offset);
        }

        ze_event_handle_t* getPhWaitEvents() {
            auto offset = offsetPhWaitEvents;
            return reinterpret_cast<ze_event_handle_t*>(dynMem + offset);
        }


        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        offsetDstptr = dynamicTraits.dstptr.offset;
        offsetPhWaitEvents = dynamicTraits.phWaitEvents.offset;
        countPhEvents = dynamicTraits.phEvents.count;
        countDstptr = dynamicTraits.dstptr.count;
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        alignas(8) char dynMem[];
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendQueryKernelTimestampsRpcM() = default;

    ZeCommandListAppendQueryKernelTimestampsRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, uint32_t numEvents, ze_event_handle_t* phEvents, void* dstptr, const size_t* pOffsets, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.numEvents = numEvents;
        args.phEvents = phEvents;
        args.dstptr = dstptr;
        args.pOffsets = pOffsets;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendQueryKernelTimestampsRpcM &message, ze_command_list_handle_t hCommandList, uint32_t numEvents, ze_event_handle_t* phEvents, void* dstptr, const size_t* pOffsets, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.numEvents = numEvents;
        message.args.phEvents = phEvents;
        message.args.dstptr = dstptr;
        message.args.pOffsets = pOffsets;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phEvents){
            memcpy(asMemcpyDstT(captures.getPhEvents()), args.phEvents, dynMemTraits.phEvents.size);
        }
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.getPhWaitEvents()), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.dstptr){
            memcpy(args.dstptr, captures.getDstptr(), dynMemTraits.dstptr.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendQueryKernelTimestampsRpcM>);
struct ZeEventQueryTimestampsExpRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 131;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_event_handle_t hEvent = {};
        ze_device_handle_t hDevice = {};
        uint32_t* pCount = {};
        ze_kernel_timestamp_result_t* pTimestamps = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hEvent == rhs.hEvent;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->pCount == rhs.pCount;
            equal &= this->pTimestamps == rhs.pTimestamps;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_event_handle_t hEvent, ze_device_handle_t hDevice, uint32_t* pCount, ze_kernel_timestamp_result_t* pTimestamps);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits pTimestamps = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t pCount;
        uint32_t countPTimestamps = 0;
        ze_kernel_timestamp_result_t pTimestamps[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPTimestamps = dynamicTraits.pTimestamps.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeEventQueryTimestampsExpRpcM() = default;

    ZeEventQueryTimestampsExpRpcM(const Captures::DynamicTraits &dynamicTraits, ze_event_handle_t hEvent, ze_device_handle_t hDevice, uint32_t* pCount, ze_kernel_timestamp_result_t* pTimestamps) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hEvent = hEvent;
        args.hDevice = hDevice;
        args.pCount = pCount;
        args.pTimestamps = pTimestamps;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeEventQueryTimestampsExpRpcM &message, ze_event_handle_t hEvent, ze_device_handle_t hDevice, uint32_t* pCount, ze_kernel_timestamp_result_t* pTimestamps) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hEvent = hEvent;
        message.args.hDevice = hDevice;
        message.args.pCount = pCount;
        message.args.pTimestamps = pTimestamps;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            captures.pCount = *args.pCount;
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            *args.pCount = captures.pCount;
        }
        if(args.pTimestamps){
            memcpy(args.pTimestamps, captures.pTimestamps, dynMemTraits.pTimestamps.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeEventQueryTimestampsExpRpcM>);
 // zeEventQueryKernelTimestampsExt ignored in generator - based on dont_generate_rpc_message flag
struct ZeEventQueryKernelTimestampsExtRpcHelperRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 132;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_event_handle_t hEvent = {};
        ze_device_handle_t hDevice = {};
        uint32_t* pCount = {};
        ze_kernel_timestamp_result_t* pResultsTimestamps = {};
        ze_synchronized_timestamp_result_ext_t* pResultsSynchronizedTimestamps = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hEvent == rhs.hEvent;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->pCount == rhs.pCount;
            equal &= this->pResultsTimestamps == rhs.pResultsTimestamps;
            equal &= this->pResultsSynchronizedTimestamps == rhs.pResultsSynchronizedTimestamps;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_event_handle_t hEvent, ze_device_handle_t hDevice, uint32_t* pCount, ze_kernel_timestamp_result_t* pResultsTimestamps, ze_synchronized_timestamp_result_ext_t* pResultsSynchronizedTimestamps);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits pResultsTimestamps = {};          
            DynamicArgTraits pResultsSynchronizedTimestamps = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t pCount;
        uint32_t offsetPResultsSynchronizedTimestamps = 0;
        uint32_t countPResultsTimestamps = 0;
        uint32_t countPResultsSynchronizedTimestamps = 0;
        ze_kernel_timestamp_result_t* getPResultsTimestamps() {
            auto offset = 0;
            return reinterpret_cast<ze_kernel_timestamp_result_t*>(dynMem + offset);
        }

        ze_synchronized_timestamp_result_ext_t* getPResultsSynchronizedTimestamps() {
            auto offset = offsetPResultsSynchronizedTimestamps;
            return reinterpret_cast<ze_synchronized_timestamp_result_ext_t*>(dynMem + offset);
        }


        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        offsetPResultsSynchronizedTimestamps = dynamicTraits.pResultsSynchronizedTimestamps.offset;
        countPResultsTimestamps = dynamicTraits.pResultsTimestamps.count;
        countPResultsSynchronizedTimestamps = dynamicTraits.pResultsSynchronizedTimestamps.count;
        }
        
        alignas(8) char dynMem[];
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeEventQueryKernelTimestampsExtRpcHelperRpcM() = default;

    ZeEventQueryKernelTimestampsExtRpcHelperRpcM(const Captures::DynamicTraits &dynamicTraits, ze_event_handle_t hEvent, ze_device_handle_t hDevice, uint32_t* pCount, ze_kernel_timestamp_result_t* pResultsTimestamps, ze_synchronized_timestamp_result_ext_t* pResultsSynchronizedTimestamps) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hEvent = hEvent;
        args.hDevice = hDevice;
        args.pCount = pCount;
        args.pResultsTimestamps = pResultsTimestamps;
        args.pResultsSynchronizedTimestamps = pResultsSynchronizedTimestamps;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeEventQueryKernelTimestampsExtRpcHelperRpcM &message, ze_event_handle_t hEvent, ze_device_handle_t hDevice, uint32_t* pCount, ze_kernel_timestamp_result_t* pResultsTimestamps, ze_synchronized_timestamp_result_ext_t* pResultsSynchronizedTimestamps) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hEvent = hEvent;
        message.args.hDevice = hDevice;
        message.args.pCount = pCount;
        message.args.pResultsTimestamps = pResultsTimestamps;
        message.args.pResultsSynchronizedTimestamps = pResultsSynchronizedTimestamps;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            captures.pCount = *args.pCount;
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            *args.pCount = captures.pCount;
        }
        if(args.pResultsTimestamps){
            memcpy(args.pResultsTimestamps, captures.getPResultsTimestamps(), dynMemTraits.pResultsTimestamps.size);
        }
        if(args.pResultsSynchronizedTimestamps){
            memcpy(args.pResultsSynchronizedTimestamps, captures.getPResultsSynchronizedTimestamps(), dynMemTraits.pResultsSynchronizedTimestamps.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeEventQueryKernelTimestampsExtRpcHelperRpcM>);
struct ZeFabricVertexGetExpRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 133;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_driver_handle_t hDriver = {};
        uint32_t* pCount = {};
        ze_fabric_vertex_handle_t* phVertices = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDriver == rhs.hDriver;
            equal &= this->pCount == rhs.pCount;
            equal &= this->phVertices == rhs.phVertices;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_driver_handle_t hDriver, uint32_t* pCount, ze_fabric_vertex_handle_t* phVertices);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phVertices = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t pCount;
        uint32_t countPhVertices = 0;
        ze_fabric_vertex_handle_t phVertices[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhVertices = dynamicTraits.phVertices.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeFabricVertexGetExpRpcM() = default;

    ZeFabricVertexGetExpRpcM(const Captures::DynamicTraits &dynamicTraits, ze_driver_handle_t hDriver, uint32_t* pCount, ze_fabric_vertex_handle_t* phVertices) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDriver = hDriver;
        args.pCount = pCount;
        args.phVertices = phVertices;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeFabricVertexGetExpRpcM &message, ze_driver_handle_t hDriver, uint32_t* pCount, ze_fabric_vertex_handle_t* phVertices) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDriver = hDriver;
        message.args.pCount = pCount;
        message.args.phVertices = phVertices;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            captures.pCount = *args.pCount;
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            *args.pCount = captures.pCount;
        }
        if(args.phVertices){
            memcpy(args.phVertices, captures.phVertices, dynMemTraits.phVertices.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeFabricVertexGetExpRpcM>);
struct ZeFabricVertexGetSubVerticesExpRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 134;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_fabric_vertex_handle_t hVertex = {};
        uint32_t* pCount = {};
        ze_fabric_vertex_handle_t* phSubvertices = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hVertex == rhs.hVertex;
            equal &= this->pCount == rhs.pCount;
            equal &= this->phSubvertices == rhs.phSubvertices;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_fabric_vertex_handle_t hVertex, uint32_t* pCount, ze_fabric_vertex_handle_t* phSubvertices);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phSubvertices = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t pCount;
        uint32_t countPhSubvertices = 0;
        ze_fabric_vertex_handle_t phSubvertices[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhSubvertices = dynamicTraits.phSubvertices.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeFabricVertexGetSubVerticesExpRpcM() = default;

    ZeFabricVertexGetSubVerticesExpRpcM(const Captures::DynamicTraits &dynamicTraits, ze_fabric_vertex_handle_t hVertex, uint32_t* pCount, ze_fabric_vertex_handle_t* phSubvertices) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hVertex = hVertex;
        args.pCount = pCount;
        args.phSubvertices = phSubvertices;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeFabricVertexGetSubVerticesExpRpcM &message, ze_fabric_vertex_handle_t hVertex, uint32_t* pCount, ze_fabric_vertex_handle_t* phSubvertices) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hVertex = hVertex;
        message.args.pCount = pCount;
        message.args.phSubvertices = phSubvertices;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            captures.pCount = *args.pCount;
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            *args.pCount = captures.pCount;
        }
        if(args.phSubvertices){
            memcpy(args.phSubvertices, captures.phSubvertices, dynMemTraits.phSubvertices.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeFabricVertexGetSubVerticesExpRpcM>);
struct ZeFabricVertexGetPropertiesExpRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 135;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_fabric_vertex_handle_t hVertex = {};
        ze_fabric_vertex_exp_properties_t* pVertexProperties = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hVertex == rhs.hVertex;
            equal &= this->pVertexProperties == rhs.pVertexProperties;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_fabric_vertex_handle_t hVertex, ze_fabric_vertex_exp_properties_t* pVertexProperties);
            uint32_t totalDynamicSize = 0;
            uint32_t dynamicStructMembersOffset = 0;
            DynamicArgTraits pVertexPropertiesNestedTraits = {};
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_fabric_vertex_exp_properties_t pVertexProperties;
        uint32_t dynamicStructMembersOffset = 0;
        uint32_t pVertexPropertiesNestedTraitsOffset = 0;
        uint32_t pVertexPropertiesNestedTraitsCount = 0;

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
            dynamicStructMembersOffset = dynamicTraits.dynamicStructMembersOffset;
            pVertexPropertiesNestedTraitsOffset = dynamicTraits.pVertexPropertiesNestedTraits.offset;
            pVertexPropertiesNestedTraitsCount = dynamicTraits.pVertexPropertiesNestedTraits.count;
            dynMemSize = dynamicTraits.totalDynamicSize;
        }
        
        uint32_t dynMemSize = 0;
        alignas(8) char dynMem[];
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;
        void reassembleNestedStructs() {
            using Cal::Utils::alignUpPow2;

            uint32_t currentOffset = dynamicStructMembersOffset;

            if(pVertexPropertiesNestedTraitsCount > 0){
                assert(currentOffset == pVertexPropertiesNestedTraitsOffset);
                auto* pVertexPropertiesTraits = reinterpret_cast<DynamicStructTraits<ze_fabric_vertex_exp_properties_t>*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(pVertexPropertiesNestedTraitsCount * sizeof(DynamicStructTraits<ze_fabric_vertex_exp_properties_t>));
                auto* destPVertexProperties = &pVertexProperties;

                for (uint32_t i = 0; i < pVertexPropertiesNestedTraitsCount; ++i) {
                    if(pVertexPropertiesTraits[i].pNextOffset == -1){
                        forcePointerWrite(destPVertexProperties[i].pNext, nullptr);
                        continue;
                    }

                    auto pVertexPropertiesPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                    currentOffset += alignUpPow2<8>(pVertexPropertiesTraits[i].pNextCount * sizeof(NestedPNextTraits));

                    assert(currentOffset == static_cast<uint32_t>(pVertexPropertiesPNextListElementTraits[0].extensionOffset));
                    forcePointerWrite(destPVertexProperties[i].pNext, dynMem + pVertexPropertiesPNextListElementTraits[0].extensionOffset);
                    currentOffset += alignUpPow2<8>(getUnderlyingSize(static_cast<const ze_base_desc_t*>(destPVertexProperties[i].pNext)));

                    auto pVertexPropertiesPNextListElement = static_cast<const ze_base_desc_t*>(destPVertexProperties[i].pNext);
                    for(int32_t j = 1; j <= pVertexPropertiesTraits[i].pNextCount; ++j){
                        if (j < pVertexPropertiesTraits[i].pNextCount) {
                            const auto extensionOffset = pVertexPropertiesPNextListElementTraits[j].extensionOffset;
                            forcePointerWrite(getNextField(*pVertexPropertiesPNextListElement), dynMem + extensionOffset);
                        }

                        if (j < pVertexPropertiesTraits[i].pNextCount) {
                            const auto pNextElement = getNext(pVertexPropertiesPNextListElement);
                            const auto sizeInBytes = getUnderlyingSize(pNextElement);
                            currentOffset += alignUpPow2<8>(sizeInBytes);

                            pVertexPropertiesPNextListElement = pNextElement;
                        }

                    }

                }
        }
    }

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeFabricVertexGetPropertiesExpRpcM() = default;

    ZeFabricVertexGetPropertiesExpRpcM(const Captures::DynamicTraits &dynamicTraits, ze_fabric_vertex_handle_t hVertex, ze_fabric_vertex_exp_properties_t* pVertexProperties) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hVertex = hVertex;
        args.pVertexProperties = pVertexProperties;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeFabricVertexGetPropertiesExpRpcM &message, ze_fabric_vertex_handle_t hVertex, ze_fabric_vertex_exp_properties_t* pVertexProperties) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hVertex = hVertex;
        message.args.pVertexProperties = pVertexProperties;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pVertexProperties){
            captures.pVertexProperties = *args.pVertexProperties;
        }
        using Cal::Utils::alignUpPow2;

        auto& dynMem = captures.dynMem;
        uint32_t currentOffset = captures.dynamicStructMembersOffset;
        if(args.pVertexProperties){
            assert(currentOffset == captures.pVertexPropertiesNestedTraitsOffset);
            auto* pVertexPropertiesTraits = reinterpret_cast<DynamicStructTraits<ze_fabric_vertex_exp_properties_t>*>(dynMem + currentOffset);
            currentOffset += alignUpPow2<8>(captures.pVertexPropertiesNestedTraitsCount * sizeof(DynamicStructTraits<ze_fabric_vertex_exp_properties_t>));

            for (uint32_t i = 0; i < captures.pVertexPropertiesNestedTraitsCount; ++i) {
                const auto& pVertexPropertiesPNext = args.pVertexProperties[i].pNext;
                if(!pVertexPropertiesPNext){
                    pVertexPropertiesTraits[i].pNextOffset = -1;
                    pVertexPropertiesTraits[i].pNextCount = -1;
                    continue;
                }

                const auto pVertexPropertiesPNextCount = static_cast<int32_t>(countOpaqueList(static_cast<const ze_base_desc_t*>(args.pVertexProperties[i].pNext)));
                if(!pVertexPropertiesPNextCount){
                    pVertexPropertiesTraits[i].pNextOffset = -1;
                    pVertexPropertiesTraits[i].pNextCount = -1;
                    continue;
                }

                pVertexPropertiesTraits[i].pNextOffset = currentOffset;
                pVertexPropertiesTraits[i].pNextCount = pVertexPropertiesPNextCount;
                pVertexPropertiesTraits[i].pNextFirstOriginalElement = args.pVertexProperties[i].pNext;

                auto pVertexPropertiesPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(pVertexPropertiesPNextCount * sizeof(NestedPNextTraits));

                auto pVertexPropertiesPNextListElement = static_cast<const ze_base_desc_t*>(args.pVertexProperties[i].pNext);
                for(int32_t j = 0; j < pVertexPropertiesPNextCount; ++j){
                    pVertexPropertiesPNextListElementTraits[j].extensionType = getExtensionType(pVertexPropertiesPNextListElement);
                    pVertexPropertiesPNextListElementTraits[j].extensionOffset = currentOffset;

                    const auto sizeInBytes = getUnderlyingSize(pVertexPropertiesPNextListElement);
                    std::memcpy(dynMem + currentOffset, pVertexPropertiesPNextListElement, sizeInBytes);
                    currentOffset += alignUpPow2<8>(sizeInBytes);

                    pVertexPropertiesPNextListElement = getNext(pVertexPropertiesPNextListElement);
                }

            }
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pVertexProperties){
            *args.pVertexProperties = captures.pVertexProperties;
        }
        using Cal::Utils::alignUpPow2;

        auto& dynMem = captures.dynMem;
        uint32_t currentOffset = captures.dynamicStructMembersOffset;
        if(args.pVertexProperties) {
            assert(currentOffset == captures.pVertexPropertiesNestedTraitsOffset);
            auto* pVertexPropertiesTraits = reinterpret_cast<DynamicStructTraits<ze_fabric_vertex_exp_properties_t>*>(dynMem + currentOffset);
            currentOffset += alignUpPow2<8>(captures.pVertexPropertiesNestedTraitsCount * sizeof(DynamicStructTraits<ze_fabric_vertex_exp_properties_t>));

            auto* destPVertexProperties = args.pVertexProperties;

            for (uint32_t i = 0; i < captures.pVertexPropertiesNestedTraitsCount; ++i) {
                if(pVertexPropertiesTraits[i].pNextOffset == -1){
                    continue;
                }

                destPVertexProperties[i].pNext = pVertexPropertiesTraits[i].pNextFirstOriginalElement;

                auto pVertexPropertiesPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(pVertexPropertiesTraits[i].pNextCount * sizeof(NestedPNextTraits));

                auto pVertexPropertiesPNextListElement = static_cast<const ze_base_desc_t*>(destPVertexProperties[i].pNext);
                for(int32_t j = 0; j < pVertexPropertiesTraits[i].pNextCount; ++j){
                    const auto sizeInBytes = getUnderlyingSize(pVertexPropertiesPNextListElement);
                    currentOffset += alignUpPow2<8>(sizeInBytes);

                    const auto extensionType = getExtensionType(pVertexPropertiesPNextListElement);
                    if (!isReadOnly(extensionType)) {
                        {
                            auto originalNextOpaqueElement = getNext(pVertexPropertiesPNextListElement);
                            const auto extensionOffset = pVertexPropertiesPNextListElementTraits[j].extensionOffset;
                            auto destination = const_cast<ze_base_desc_t*>(pVertexPropertiesPNextListElement);
                            std::memcpy(destination, dynMem + extensionOffset, sizeInBytes);

                            getNextField(*destination) = originalNextOpaqueElement;
                        }

                    }

                    pVertexPropertiesPNextListElement = getNext(pVertexPropertiesPNextListElement);
                }

            }
        }
    }
};
static_assert(std::is_standard_layout_v<ZeFabricVertexGetPropertiesExpRpcM>);
struct ZeFabricVertexGetDeviceExpRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 136;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_fabric_vertex_handle_t hVertex = {};
        ze_device_handle_t* pDevice = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hVertex == rhs.hVertex;
            equal &= this->pDevice == rhs.pDevice;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_device_handle_t pDevice;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeFabricVertexGetDeviceExpRpcM() = default;

    ZeFabricVertexGetDeviceExpRpcM(ze_fabric_vertex_handle_t hVertex, ze_device_handle_t* pDevice) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hVertex = hVertex;
        args.pDevice = pDevice;
    }
    
    static void fillWithoutCapture(ZeFabricVertexGetDeviceExpRpcM &message, ze_fabric_vertex_handle_t hVertex, ze_device_handle_t* pDevice) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hVertex = hVertex;
        message.args.pDevice = pDevice;
    }
    

    void copyFromCaller(){
        if(args.pDevice){
            captures.pDevice = *args.pDevice;
        }
    }

    void copyToCaller(){
        if(args.pDevice){
            *args.pDevice = captures.pDevice;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeFabricVertexGetDeviceExpRpcM>);
struct ZeDeviceGetFabricVertexExpRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 137;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_device_handle_t hDevice = {};
        ze_fabric_vertex_handle_t* pVertex = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->pVertex == rhs.pVertex;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_fabric_vertex_handle_t pVertex;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeDeviceGetFabricVertexExpRpcM() = default;

    ZeDeviceGetFabricVertexExpRpcM(ze_device_handle_t hDevice, ze_fabric_vertex_handle_t* pVertex) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.pVertex = pVertex;
    }
    
    static void fillWithoutCapture(ZeDeviceGetFabricVertexExpRpcM &message, ze_device_handle_t hDevice, ze_fabric_vertex_handle_t* pVertex) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.pVertex = pVertex;
    }
    

    void copyFromCaller(){
        if(args.pVertex){
            captures.pVertex = *args.pVertex;
        }
    }

    void copyToCaller(){
        if(args.pVertex){
            *args.pVertex = captures.pVertex;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeDeviceGetFabricVertexExpRpcM>);
struct ZeFabricEdgeGetExpRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 138;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_fabric_vertex_handle_t hVertexA = {};
        ze_fabric_vertex_handle_t hVertexB = {};
        uint32_t* pCount = {};
        ze_fabric_edge_handle_t* phEdges = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hVertexA == rhs.hVertexA;
            equal &= this->hVertexB == rhs.hVertexB;
            equal &= this->pCount == rhs.pCount;
            equal &= this->phEdges == rhs.phEdges;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_fabric_vertex_handle_t hVertexA, ze_fabric_vertex_handle_t hVertexB, uint32_t* pCount, ze_fabric_edge_handle_t* phEdges);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phEdges = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t pCount;
        uint32_t countPhEdges = 0;
        ze_fabric_edge_handle_t phEdges[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhEdges = dynamicTraits.phEdges.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeFabricEdgeGetExpRpcM() = default;

    ZeFabricEdgeGetExpRpcM(const Captures::DynamicTraits &dynamicTraits, ze_fabric_vertex_handle_t hVertexA, ze_fabric_vertex_handle_t hVertexB, uint32_t* pCount, ze_fabric_edge_handle_t* phEdges) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hVertexA = hVertexA;
        args.hVertexB = hVertexB;
        args.pCount = pCount;
        args.phEdges = phEdges;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeFabricEdgeGetExpRpcM &message, ze_fabric_vertex_handle_t hVertexA, ze_fabric_vertex_handle_t hVertexB, uint32_t* pCount, ze_fabric_edge_handle_t* phEdges) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hVertexA = hVertexA;
        message.args.hVertexB = hVertexB;
        message.args.pCount = pCount;
        message.args.phEdges = phEdges;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            captures.pCount = *args.pCount;
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pCount){
            *args.pCount = captures.pCount;
        }
        if(args.phEdges){
            memcpy(args.phEdges, captures.phEdges, dynMemTraits.phEdges.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeFabricEdgeGetExpRpcM>);
struct ZeFabricEdgeGetVerticesExpRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 139;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_fabric_edge_handle_t hEdge = {};
        ze_fabric_vertex_handle_t* phVertexA = {};
        ze_fabric_vertex_handle_t* phVertexB = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hEdge == rhs.hEdge;
            equal &= this->phVertexA == rhs.phVertexA;
            equal &= this->phVertexB == rhs.phVertexB;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_fabric_vertex_handle_t phVertexA;
        ze_fabric_vertex_handle_t phVertexB;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeFabricEdgeGetVerticesExpRpcM() = default;

    ZeFabricEdgeGetVerticesExpRpcM(ze_fabric_edge_handle_t hEdge, ze_fabric_vertex_handle_t* phVertexA, ze_fabric_vertex_handle_t* phVertexB) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hEdge = hEdge;
        args.phVertexA = phVertexA;
        args.phVertexB = phVertexB;
    }
    
    static void fillWithoutCapture(ZeFabricEdgeGetVerticesExpRpcM &message, ze_fabric_edge_handle_t hEdge, ze_fabric_vertex_handle_t* phVertexA, ze_fabric_vertex_handle_t* phVertexB) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hEdge = hEdge;
        message.args.phVertexA = phVertexA;
        message.args.phVertexB = phVertexB;
    }
    

    void copyFromCaller(){
        if(args.phVertexA){
            captures.phVertexA = *args.phVertexA;
        }
    }

    void copyToCaller(){
        if(args.phVertexA){
            *args.phVertexA = captures.phVertexA;
        }
        if(args.phVertexB){
            *args.phVertexB = captures.phVertexB;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeFabricEdgeGetVerticesExpRpcM>);
struct ZeFabricEdgeGetPropertiesExpRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 140;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_fabric_edge_handle_t hEdge = {};
        ze_fabric_edge_exp_properties_t* pEdgeProperties = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hEdge == rhs.hEdge;
            equal &= this->pEdgeProperties == rhs.pEdgeProperties;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_fabric_edge_handle_t hEdge, ze_fabric_edge_exp_properties_t* pEdgeProperties);
            uint32_t totalDynamicSize = 0;
            uint32_t dynamicStructMembersOffset = 0;
            DynamicArgTraits pEdgePropertiesNestedTraits = {};
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_fabric_edge_exp_properties_t pEdgeProperties;
        uint32_t dynamicStructMembersOffset = 0;
        uint32_t pEdgePropertiesNestedTraitsOffset = 0;
        uint32_t pEdgePropertiesNestedTraitsCount = 0;

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
            dynamicStructMembersOffset = dynamicTraits.dynamicStructMembersOffset;
            pEdgePropertiesNestedTraitsOffset = dynamicTraits.pEdgePropertiesNestedTraits.offset;
            pEdgePropertiesNestedTraitsCount = dynamicTraits.pEdgePropertiesNestedTraits.count;
            dynMemSize = dynamicTraits.totalDynamicSize;
        }
        
        uint32_t dynMemSize = 0;
        alignas(8) char dynMem[];
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;
        void reassembleNestedStructs() {
            using Cal::Utils::alignUpPow2;

            uint32_t currentOffset = dynamicStructMembersOffset;

            if(pEdgePropertiesNestedTraitsCount > 0){
                assert(currentOffset == pEdgePropertiesNestedTraitsOffset);
                auto* pEdgePropertiesTraits = reinterpret_cast<DynamicStructTraits<ze_fabric_edge_exp_properties_t>*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(pEdgePropertiesNestedTraitsCount * sizeof(DynamicStructTraits<ze_fabric_edge_exp_properties_t>));
                auto* destPEdgeProperties = &pEdgeProperties;

                for (uint32_t i = 0; i < pEdgePropertiesNestedTraitsCount; ++i) {
                    if(pEdgePropertiesTraits[i].pNextOffset == -1){
                        forcePointerWrite(destPEdgeProperties[i].pNext, nullptr);
                        continue;
                    }

                    auto pEdgePropertiesPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                    currentOffset += alignUpPow2<8>(pEdgePropertiesTraits[i].pNextCount * sizeof(NestedPNextTraits));

                    assert(currentOffset == static_cast<uint32_t>(pEdgePropertiesPNextListElementTraits[0].extensionOffset));
                    forcePointerWrite(destPEdgeProperties[i].pNext, dynMem + pEdgePropertiesPNextListElementTraits[0].extensionOffset);
                    currentOffset += alignUpPow2<8>(getUnderlyingSize(static_cast<const ze_base_desc_t*>(destPEdgeProperties[i].pNext)));

                    auto pEdgePropertiesPNextListElement = static_cast<const ze_base_desc_t*>(destPEdgeProperties[i].pNext);
                    for(int32_t j = 1; j <= pEdgePropertiesTraits[i].pNextCount; ++j){
                        if (j < pEdgePropertiesTraits[i].pNextCount) {
                            const auto extensionOffset = pEdgePropertiesPNextListElementTraits[j].extensionOffset;
                            forcePointerWrite(getNextField(*pEdgePropertiesPNextListElement), dynMem + extensionOffset);
                        }

                        if (j < pEdgePropertiesTraits[i].pNextCount) {
                            const auto pNextElement = getNext(pEdgePropertiesPNextListElement);
                            const auto sizeInBytes = getUnderlyingSize(pNextElement);
                            currentOffset += alignUpPow2<8>(sizeInBytes);

                            pEdgePropertiesPNextListElement = pNextElement;
                        }

                    }

                }
        }
    }

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeFabricEdgeGetPropertiesExpRpcM() = default;

    ZeFabricEdgeGetPropertiesExpRpcM(const Captures::DynamicTraits &dynamicTraits, ze_fabric_edge_handle_t hEdge, ze_fabric_edge_exp_properties_t* pEdgeProperties) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hEdge = hEdge;
        args.pEdgeProperties = pEdgeProperties;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeFabricEdgeGetPropertiesExpRpcM &message, ze_fabric_edge_handle_t hEdge, ze_fabric_edge_exp_properties_t* pEdgeProperties) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hEdge = hEdge;
        message.args.pEdgeProperties = pEdgeProperties;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pEdgeProperties){
            captures.pEdgeProperties = *args.pEdgeProperties;
        }
        using Cal::Utils::alignUpPow2;

        auto& dynMem = captures.dynMem;
        uint32_t currentOffset = captures.dynamicStructMembersOffset;
        if(args.pEdgeProperties){
            assert(currentOffset == captures.pEdgePropertiesNestedTraitsOffset);
            auto* pEdgePropertiesTraits = reinterpret_cast<DynamicStructTraits<ze_fabric_edge_exp_properties_t>*>(dynMem + currentOffset);
            currentOffset += alignUpPow2<8>(captures.pEdgePropertiesNestedTraitsCount * sizeof(DynamicStructTraits<ze_fabric_edge_exp_properties_t>));

            for (uint32_t i = 0; i < captures.pEdgePropertiesNestedTraitsCount; ++i) {
                const auto& pEdgePropertiesPNext = args.pEdgeProperties[i].pNext;
                if(!pEdgePropertiesPNext){
                    pEdgePropertiesTraits[i].pNextOffset = -1;
                    pEdgePropertiesTraits[i].pNextCount = -1;
                    continue;
                }

                const auto pEdgePropertiesPNextCount = static_cast<int32_t>(countOpaqueList(static_cast<const ze_base_desc_t*>(args.pEdgeProperties[i].pNext)));
                if(!pEdgePropertiesPNextCount){
                    pEdgePropertiesTraits[i].pNextOffset = -1;
                    pEdgePropertiesTraits[i].pNextCount = -1;
                    continue;
                }

                pEdgePropertiesTraits[i].pNextOffset = currentOffset;
                pEdgePropertiesTraits[i].pNextCount = pEdgePropertiesPNextCount;
                pEdgePropertiesTraits[i].pNextFirstOriginalElement = args.pEdgeProperties[i].pNext;

                auto pEdgePropertiesPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(pEdgePropertiesPNextCount * sizeof(NestedPNextTraits));

                auto pEdgePropertiesPNextListElement = static_cast<const ze_base_desc_t*>(args.pEdgeProperties[i].pNext);
                for(int32_t j = 0; j < pEdgePropertiesPNextCount; ++j){
                    pEdgePropertiesPNextListElementTraits[j].extensionType = getExtensionType(pEdgePropertiesPNextListElement);
                    pEdgePropertiesPNextListElementTraits[j].extensionOffset = currentOffset;

                    const auto sizeInBytes = getUnderlyingSize(pEdgePropertiesPNextListElement);
                    std::memcpy(dynMem + currentOffset, pEdgePropertiesPNextListElement, sizeInBytes);
                    currentOffset += alignUpPow2<8>(sizeInBytes);

                    pEdgePropertiesPNextListElement = getNext(pEdgePropertiesPNextListElement);
                }

            }
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pEdgeProperties){
            *args.pEdgeProperties = captures.pEdgeProperties;
        }
        using Cal::Utils::alignUpPow2;

        auto& dynMem = captures.dynMem;
        uint32_t currentOffset = captures.dynamicStructMembersOffset;
        if(args.pEdgeProperties) {
            assert(currentOffset == captures.pEdgePropertiesNestedTraitsOffset);
            auto* pEdgePropertiesTraits = reinterpret_cast<DynamicStructTraits<ze_fabric_edge_exp_properties_t>*>(dynMem + currentOffset);
            currentOffset += alignUpPow2<8>(captures.pEdgePropertiesNestedTraitsCount * sizeof(DynamicStructTraits<ze_fabric_edge_exp_properties_t>));

            auto* destPEdgeProperties = args.pEdgeProperties;

            for (uint32_t i = 0; i < captures.pEdgePropertiesNestedTraitsCount; ++i) {
                if(pEdgePropertiesTraits[i].pNextOffset == -1){
                    continue;
                }

                destPEdgeProperties[i].pNext = pEdgePropertiesTraits[i].pNextFirstOriginalElement;

                auto pEdgePropertiesPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(pEdgePropertiesTraits[i].pNextCount * sizeof(NestedPNextTraits));

                auto pEdgePropertiesPNextListElement = static_cast<const ze_base_desc_t*>(destPEdgeProperties[i].pNext);
                for(int32_t j = 0; j < pEdgePropertiesTraits[i].pNextCount; ++j){
                    const auto sizeInBytes = getUnderlyingSize(pEdgePropertiesPNextListElement);
                    currentOffset += alignUpPow2<8>(sizeInBytes);

                    const auto extensionType = getExtensionType(pEdgePropertiesPNextListElement);
                    if (!isReadOnly(extensionType)) {
                        {
                            auto originalNextOpaqueElement = getNext(pEdgePropertiesPNextListElement);
                            const auto extensionOffset = pEdgePropertiesPNextListElementTraits[j].extensionOffset;
                            auto destination = const_cast<ze_base_desc_t*>(pEdgePropertiesPNextListElement);
                            std::memcpy(destination, dynMem + extensionOffset, sizeInBytes);

                            getNextField(*destination) = originalNextOpaqueElement;
                        }

                    }

                    pEdgePropertiesPNextListElement = getNext(pEdgePropertiesPNextListElement);
                }

            }
        }
    }
};
static_assert(std::is_standard_layout_v<ZeFabricEdgeGetPropertiesExpRpcM>);
struct ZeFenceCreateRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 141;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_queue_handle_t hCommandQueue = {};
        const ze_fence_desc_t* desc = {};
        ze_fence_handle_t* phFence = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandQueue == rhs.hCommandQueue;
            equal &= this->desc == rhs.desc;
            equal &= this->phFence == rhs.phFence;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_fence_desc_t desc;
        ze_fence_handle_t phFence;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeFenceCreateRpcM() = default;

    ZeFenceCreateRpcM(ze_command_queue_handle_t hCommandQueue, const ze_fence_desc_t* desc, ze_fence_handle_t* phFence) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandQueue = hCommandQueue;
        args.desc = desc;
        args.phFence = phFence;
    }
    
    static void fillWithoutCapture(ZeFenceCreateRpcM &message, ze_command_queue_handle_t hCommandQueue, const ze_fence_desc_t* desc, ze_fence_handle_t* phFence) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandQueue = hCommandQueue;
        message.args.desc = desc;
        message.args.phFence = phFence;
    }
    

    void copyFromCaller(){
        if(args.desc){
            captures.desc = *args.desc;
        }
    }

    void copyToCaller(){
        if(args.phFence){
            *args.phFence = captures.phFence;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeFenceCreateRpcM>);
struct ZeFenceDestroyRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 142;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_fence_handle_t hFence = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hFence == rhs.hFence;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeFenceDestroyRpcM() = default;

    ZeFenceDestroyRpcM(ze_fence_handle_t hFence) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hFence = hFence;
    }
    
    static void fillWithoutCapture(ZeFenceDestroyRpcM &message, ze_fence_handle_t hFence) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hFence = hFence;
    }
    
};
static_assert(std::is_standard_layout_v<ZeFenceDestroyRpcM>);
struct ZeFenceHostSynchronizeRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 143;
    static constexpr float latency = 2.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_fence_handle_t hFence = {};
        uint64_t timeout = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hFence == rhs.hFence;
            equal &= this->timeout == rhs.timeout;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeFenceHostSynchronizeRpcM() = default;

    ZeFenceHostSynchronizeRpcM(ze_fence_handle_t hFence, uint64_t timeout) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hFence = hFence;
        args.timeout = timeout;
    }
    
    static void fillWithoutCapture(ZeFenceHostSynchronizeRpcM &message, ze_fence_handle_t hFence, uint64_t timeout) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hFence = hFence;
        message.args.timeout = timeout;
    }
    
};
static_assert(std::is_standard_layout_v<ZeFenceHostSynchronizeRpcM>);
struct ZeFenceQueryStatusRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 144;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_fence_handle_t hFence = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hFence == rhs.hFence;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeFenceQueryStatusRpcM() = default;

    ZeFenceQueryStatusRpcM(ze_fence_handle_t hFence) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hFence = hFence;
    }
    
    static void fillWithoutCapture(ZeFenceQueryStatusRpcM &message, ze_fence_handle_t hFence) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hFence = hFence;
    }
    
};
static_assert(std::is_standard_layout_v<ZeFenceQueryStatusRpcM>);
struct ZeFenceResetRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 145;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_fence_handle_t hFence = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hFence == rhs.hFence;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeFenceResetRpcM() = default;

    ZeFenceResetRpcM(ze_fence_handle_t hFence) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hFence = hFence;
    }
    
    static void fillWithoutCapture(ZeFenceResetRpcM &message, ze_fence_handle_t hFence) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hFence = hFence;
    }
    
};
static_assert(std::is_standard_layout_v<ZeFenceResetRpcM>);
struct ZeKernelSetGlobalOffsetExpRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 146;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_kernel_handle_t hKernel = {};
        uint32_t offsetX = {};
        uint32_t offsetY = {};
        uint32_t offsetZ = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hKernel == rhs.hKernel;
            equal &= this->offsetX == rhs.offsetX;
            equal &= this->offsetY == rhs.offsetY;
            equal &= this->offsetZ == rhs.offsetZ;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeKernelSetGlobalOffsetExpRpcM() = default;

    ZeKernelSetGlobalOffsetExpRpcM(ze_kernel_handle_t hKernel, uint32_t offsetX, uint32_t offsetY, uint32_t offsetZ) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hKernel = hKernel;
        args.offsetX = offsetX;
        args.offsetY = offsetY;
        args.offsetZ = offsetZ;
    }
    
    static void fillWithoutCapture(ZeKernelSetGlobalOffsetExpRpcM &message, ze_kernel_handle_t hKernel, uint32_t offsetX, uint32_t offsetY, uint32_t offsetZ) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hKernel = hKernel;
        message.args.offsetX = offsetX;
        message.args.offsetY = offsetY;
        message.args.offsetZ = offsetZ;
    }
    
};
static_assert(std::is_standard_layout_v<ZeKernelSetGlobalOffsetExpRpcM>);
struct ZeImageGetPropertiesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 147;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_device_handle_t hDevice = {};
        const ze_image_desc_t* desc = {};
        ze_image_properties_t* pImageProperties = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->desc == rhs.desc;
            equal &= this->pImageProperties == rhs.pImageProperties;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_device_handle_t hDevice, const ze_image_desc_t* desc, ze_image_properties_t* pImageProperties);
            uint32_t totalDynamicSize = 0;
            uint32_t dynamicStructMembersOffset = 0;
            DynamicArgTraits descNestedTraits = {};
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_image_desc_t desc;
        ze_image_properties_t pImageProperties;
        uint32_t dynamicStructMembersOffset = 0;
        uint32_t descNestedTraitsOffset = 0;
        uint32_t descNestedTraitsCount = 0;

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
            dynamicStructMembersOffset = dynamicTraits.dynamicStructMembersOffset;
            descNestedTraitsOffset = dynamicTraits.descNestedTraits.offset;
            descNestedTraitsCount = dynamicTraits.descNestedTraits.count;
            dynMemSize = dynamicTraits.totalDynamicSize;
        }
        
        uint32_t dynMemSize = 0;
        alignas(8) char dynMem[];
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;
        void reassembleNestedStructs() {
            using Cal::Utils::alignUpPow2;

            uint32_t currentOffset = dynamicStructMembersOffset;

            if(descNestedTraitsCount > 0){
                assert(currentOffset == descNestedTraitsOffset);
                auto* descTraits = reinterpret_cast<DynamicStructTraits<ze_image_desc_t>*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(descNestedTraitsCount * sizeof(DynamicStructTraits<ze_image_desc_t>));
                auto* destDesc = &desc;

                for (uint32_t i = 0; i < descNestedTraitsCount; ++i) {
                    if(descTraits[i].pNextOffset == -1){
                        forcePointerWrite(destDesc[i].pNext, nullptr);
                        continue;
                    }

                    auto descPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                    currentOffset += alignUpPow2<8>(descTraits[i].pNextCount * sizeof(NestedPNextTraits));

                    assert(currentOffset == static_cast<uint32_t>(descPNextListElementTraits[0].extensionOffset));
                    forcePointerWrite(destDesc[i].pNext, dynMem + descPNextListElementTraits[0].extensionOffset);
                    currentOffset += alignUpPow2<8>(getUnderlyingSize(static_cast<const ze_base_desc_t*>(destDesc[i].pNext)));

                    auto descPNextListElement = static_cast<const ze_base_desc_t*>(destDesc[i].pNext);
                    for(int32_t j = 1; j <= descTraits[i].pNextCount; ++j){
                        if (j < descTraits[i].pNextCount) {
                            const auto extensionOffset = descPNextListElementTraits[j].extensionOffset;
                            forcePointerWrite(getNextField(*descPNextListElement), dynMem + extensionOffset);
                        }

                        if (j < descTraits[i].pNextCount) {
                            const auto pNextElement = getNext(descPNextListElement);
                            const auto sizeInBytes = getUnderlyingSize(pNextElement);
                            currentOffset += alignUpPow2<8>(sizeInBytes);

                            descPNextListElement = pNextElement;
                        }

                    }

                }
        }
    }

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeImageGetPropertiesRpcM() = default;

    ZeImageGetPropertiesRpcM(const Captures::DynamicTraits &dynamicTraits, ze_device_handle_t hDevice, const ze_image_desc_t* desc, ze_image_properties_t* pImageProperties) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.desc = desc;
        args.pImageProperties = pImageProperties;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeImageGetPropertiesRpcM &message, ze_device_handle_t hDevice, const ze_image_desc_t* desc, ze_image_properties_t* pImageProperties) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.desc = desc;
        message.args.pImageProperties = pImageProperties;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.desc){
            captures.desc = *args.desc;
        }
        if(args.pImageProperties){
            captures.pImageProperties = *args.pImageProperties;
        }
        using Cal::Utils::alignUpPow2;

        auto& dynMem = captures.dynMem;
        uint32_t currentOffset = captures.dynamicStructMembersOffset;
        if(args.desc){
            assert(currentOffset == captures.descNestedTraitsOffset);
            auto* descTraits = reinterpret_cast<DynamicStructTraits<ze_image_desc_t>*>(dynMem + currentOffset);
            currentOffset += alignUpPow2<8>(captures.descNestedTraitsCount * sizeof(DynamicStructTraits<ze_image_desc_t>));

            for (uint32_t i = 0; i < captures.descNestedTraitsCount; ++i) {
                const auto& descPNext = args.desc[i].pNext;
                if(!descPNext){
                    descTraits[i].pNextOffset = -1;
                    descTraits[i].pNextCount = -1;
                    continue;
                }

                const auto descPNextCount = static_cast<int32_t>(countOpaqueList(static_cast<const ze_base_desc_t*>(args.desc[i].pNext)));
                if(!descPNextCount){
                    descTraits[i].pNextOffset = -1;
                    descTraits[i].pNextCount = -1;
                    continue;
                }

                descTraits[i].pNextOffset = currentOffset;
                descTraits[i].pNextCount = descPNextCount;
                descTraits[i].pNextFirstOriginalElement = args.desc[i].pNext;

                auto descPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(descPNextCount * sizeof(NestedPNextTraits));

                auto descPNextListElement = static_cast<const ze_base_desc_t*>(args.desc[i].pNext);
                for(int32_t j = 0; j < descPNextCount; ++j){
                    descPNextListElementTraits[j].extensionType = getExtensionType(descPNextListElement);
                    descPNextListElementTraits[j].extensionOffset = currentOffset;

                    const auto sizeInBytes = getUnderlyingSize(descPNextListElement);
                    std::memcpy(dynMem + currentOffset, descPNextListElement, sizeInBytes);
                    currentOffset += alignUpPow2<8>(sizeInBytes);

                    descPNextListElement = getNext(descPNextListElement);
                }

            }
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pImageProperties){
            *args.pImageProperties = captures.pImageProperties;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeImageGetPropertiesRpcM>);
struct ZeImageCreateRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 148;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_context_handle_t hContext = {};
        ze_device_handle_t hDevice = {};
        const ze_image_desc_t* desc = {};
        ze_image_handle_t* phImage = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hContext == rhs.hContext;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->desc == rhs.desc;
            equal &= this->phImage == rhs.phImage;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_context_handle_t hContext, ze_device_handle_t hDevice, const ze_image_desc_t* desc, ze_image_handle_t* phImage);
            uint32_t totalDynamicSize = 0;
            uint32_t dynamicStructMembersOffset = 0;
            DynamicArgTraits descNestedTraits = {};
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_image_desc_t desc;
        ze_image_handle_t phImage;
        uint32_t dynamicStructMembersOffset = 0;
        uint32_t descNestedTraitsOffset = 0;
        uint32_t descNestedTraitsCount = 0;

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
            dynamicStructMembersOffset = dynamicTraits.dynamicStructMembersOffset;
            descNestedTraitsOffset = dynamicTraits.descNestedTraits.offset;
            descNestedTraitsCount = dynamicTraits.descNestedTraits.count;
            dynMemSize = dynamicTraits.totalDynamicSize;
        }
        
        uint32_t dynMemSize = 0;
        alignas(8) char dynMem[];
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;
        void reassembleNestedStructs() {
            using Cal::Utils::alignUpPow2;

            uint32_t currentOffset = dynamicStructMembersOffset;

            if(descNestedTraitsCount > 0){
                assert(currentOffset == descNestedTraitsOffset);
                auto* descTraits = reinterpret_cast<DynamicStructTraits<ze_image_desc_t>*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(descNestedTraitsCount * sizeof(DynamicStructTraits<ze_image_desc_t>));
                auto* destDesc = &desc;

                for (uint32_t i = 0; i < descNestedTraitsCount; ++i) {
                    if(descTraits[i].pNextOffset == -1){
                        forcePointerWrite(destDesc[i].pNext, nullptr);
                        continue;
                    }

                    auto descPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                    currentOffset += alignUpPow2<8>(descTraits[i].pNextCount * sizeof(NestedPNextTraits));

                    assert(currentOffset == static_cast<uint32_t>(descPNextListElementTraits[0].extensionOffset));
                    forcePointerWrite(destDesc[i].pNext, dynMem + descPNextListElementTraits[0].extensionOffset);
                    currentOffset += alignUpPow2<8>(getUnderlyingSize(static_cast<const ze_base_desc_t*>(destDesc[i].pNext)));

                    auto descPNextListElement = static_cast<const ze_base_desc_t*>(destDesc[i].pNext);
                    for(int32_t j = 1; j <= descTraits[i].pNextCount; ++j){
                        if (j < descTraits[i].pNextCount) {
                            const auto extensionOffset = descPNextListElementTraits[j].extensionOffset;
                            forcePointerWrite(getNextField(*descPNextListElement), dynMem + extensionOffset);
                        }

                        if (j < descTraits[i].pNextCount) {
                            const auto pNextElement = getNext(descPNextListElement);
                            const auto sizeInBytes = getUnderlyingSize(pNextElement);
                            currentOffset += alignUpPow2<8>(sizeInBytes);

                            descPNextListElement = pNextElement;
                        }

                    }

                }
        }
    }

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeImageCreateRpcM() = default;

    ZeImageCreateRpcM(const Captures::DynamicTraits &dynamicTraits, ze_context_handle_t hContext, ze_device_handle_t hDevice, const ze_image_desc_t* desc, ze_image_handle_t* phImage) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hContext = hContext;
        args.hDevice = hDevice;
        args.desc = desc;
        args.phImage = phImage;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeImageCreateRpcM &message, ze_context_handle_t hContext, ze_device_handle_t hDevice, const ze_image_desc_t* desc, ze_image_handle_t* phImage) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hContext = hContext;
        message.args.hDevice = hDevice;
        message.args.desc = desc;
        message.args.phImage = phImage;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.desc){
            captures.desc = *args.desc;
        }
        if(args.phImage){
            captures.phImage = *args.phImage;
        }
        using Cal::Utils::alignUpPow2;

        auto& dynMem = captures.dynMem;
        uint32_t currentOffset = captures.dynamicStructMembersOffset;
        if(args.desc){
            assert(currentOffset == captures.descNestedTraitsOffset);
            auto* descTraits = reinterpret_cast<DynamicStructTraits<ze_image_desc_t>*>(dynMem + currentOffset);
            currentOffset += alignUpPow2<8>(captures.descNestedTraitsCount * sizeof(DynamicStructTraits<ze_image_desc_t>));

            for (uint32_t i = 0; i < captures.descNestedTraitsCount; ++i) {
                const auto& descPNext = args.desc[i].pNext;
                if(!descPNext){
                    descTraits[i].pNextOffset = -1;
                    descTraits[i].pNextCount = -1;
                    continue;
                }

                const auto descPNextCount = static_cast<int32_t>(countOpaqueList(static_cast<const ze_base_desc_t*>(args.desc[i].pNext)));
                if(!descPNextCount){
                    descTraits[i].pNextOffset = -1;
                    descTraits[i].pNextCount = -1;
                    continue;
                }

                descTraits[i].pNextOffset = currentOffset;
                descTraits[i].pNextCount = descPNextCount;
                descTraits[i].pNextFirstOriginalElement = args.desc[i].pNext;

                auto descPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(descPNextCount * sizeof(NestedPNextTraits));

                auto descPNextListElement = static_cast<const ze_base_desc_t*>(args.desc[i].pNext);
                for(int32_t j = 0; j < descPNextCount; ++j){
                    descPNextListElementTraits[j].extensionType = getExtensionType(descPNextListElement);
                    descPNextListElementTraits[j].extensionOffset = currentOffset;

                    const auto sizeInBytes = getUnderlyingSize(descPNextListElement);
                    std::memcpy(dynMem + currentOffset, descPNextListElement, sizeInBytes);
                    currentOffset += alignUpPow2<8>(sizeInBytes);

                    descPNextListElement = getNext(descPNextListElement);
                }

            }
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phImage){
            *args.phImage = captures.phImage;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeImageCreateRpcM>);
struct ZeImageDestroyRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 149;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_image_handle_t hImage = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hImage == rhs.hImage;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeImageDestroyRpcM() = default;

    ZeImageDestroyRpcM(ze_image_handle_t hImage) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hImage = hImage;
    }
    
    static void fillWithoutCapture(ZeImageDestroyRpcM &message, ze_image_handle_t hImage) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hImage = hImage;
    }
    
};
static_assert(std::is_standard_layout_v<ZeImageDestroyRpcM>);
struct ZeKernelSchedulingHintExpRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 150;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_kernel_handle_t hKernel = {};
        ze_scheduling_hint_exp_desc_t* pHint = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hKernel == rhs.hKernel;
            equal &= this->pHint == rhs.pHint;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_scheduling_hint_exp_desc_t pHint;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeKernelSchedulingHintExpRpcM() = default;

    ZeKernelSchedulingHintExpRpcM(ze_kernel_handle_t hKernel, ze_scheduling_hint_exp_desc_t* pHint) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hKernel = hKernel;
        args.pHint = pHint;
    }
    
    static void fillWithoutCapture(ZeKernelSchedulingHintExpRpcM &message, ze_kernel_handle_t hKernel, ze_scheduling_hint_exp_desc_t* pHint) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hKernel = hKernel;
        message.args.pHint = pHint;
    }
    

    void copyFromCaller(){
        if(args.pHint){
            captures.pHint = *args.pHint;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeKernelSchedulingHintExpRpcM>);
struct ZeModuleInspectLinkageExtRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 151;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_linkage_inspection_ext_desc_t* pInspectDesc = {};
        uint32_t numModules = {};
        ze_module_handle_t* phModules = {};
        ze_module_build_log_handle_t* phLog = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->pInspectDesc == rhs.pInspectDesc;
            equal &= this->numModules == rhs.numModules;
            equal &= this->phModules == rhs.phModules;
            equal &= this->phLog == rhs.phLog;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_linkage_inspection_ext_desc_t* pInspectDesc, uint32_t numModules, ze_module_handle_t* phModules, ze_module_build_log_handle_t* phLog);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phModules = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_linkage_inspection_ext_desc_t pInspectDesc;
        ze_module_build_log_handle_t phLog;
        uint32_t countPhModules = 0;
        ze_module_handle_t phModules[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhModules = dynamicTraits.phModules.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeModuleInspectLinkageExtRpcM() = default;

    ZeModuleInspectLinkageExtRpcM(const Captures::DynamicTraits &dynamicTraits, ze_linkage_inspection_ext_desc_t* pInspectDesc, uint32_t numModules, ze_module_handle_t* phModules, ze_module_build_log_handle_t* phLog) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.pInspectDesc = pInspectDesc;
        args.numModules = numModules;
        args.phModules = phModules;
        args.phLog = phLog;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeModuleInspectLinkageExtRpcM &message, ze_linkage_inspection_ext_desc_t* pInspectDesc, uint32_t numModules, ze_module_handle_t* phModules, ze_module_build_log_handle_t* phLog) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.pInspectDesc = pInspectDesc;
        message.args.numModules = numModules;
        message.args.phModules = phModules;
        message.args.phLog = phLog;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pInspectDesc){
            captures.pInspectDesc = *args.pInspectDesc;
        }
        if(args.phModules){
            memcpy(asMemcpyDstT(captures.phModules), args.phModules, dynMemTraits.phModules.size);
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phLog){
            *args.phLog = captures.phLog;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeModuleInspectLinkageExtRpcM>);
struct ZeMemAllocSharedRpcMImplicitArgs {
    int shmem_resource = {};
    size_t offset_within_resource = {};
    size_t aligned_size = {};
};

struct ZeMemAllocSharedRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 152;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_context_handle_t hContext = {};
        const ze_device_mem_alloc_desc_t* device_desc = {};
        const ze_host_mem_alloc_desc_t* host_desc = {};
        size_t size = {};
        size_t alignment = {};
        ze_device_handle_t hDevice = {};
        void** pptr = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hContext == rhs.hContext;
            equal &= this->device_desc == rhs.device_desc;
            equal &= this->host_desc == rhs.host_desc;
            equal &= this->size == rhs.size;
            equal &= this->alignment == rhs.alignment;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->pptr == rhs.pptr;
            return equal;
        }
    }args;

    ZeMemAllocSharedRpcMImplicitArgs implicitArgs{};
    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_context_handle_t hContext, const ze_device_mem_alloc_desc_t* device_desc, const ze_host_mem_alloc_desc_t* host_desc, size_t size, size_t alignment, ze_device_handle_t hDevice, void** pptr);
            uint32_t totalDynamicSize = 0;
            uint32_t dynamicStructMembersOffset = 0;
            DynamicArgTraits device_descNestedTraits = {};
            DynamicArgTraits host_descNestedTraits = {};
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_device_mem_alloc_desc_t device_desc;
        ze_host_mem_alloc_desc_t host_desc;
        void* pptr;
        uint32_t dynamicStructMembersOffset = 0;
        uint32_t device_descNestedTraitsOffset = 0;
        uint32_t device_descNestedTraitsCount = 0;
        uint32_t host_descNestedTraitsOffset = 0;
        uint32_t host_descNestedTraitsCount = 0;

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
            dynamicStructMembersOffset = dynamicTraits.dynamicStructMembersOffset;
            device_descNestedTraitsOffset = dynamicTraits.device_descNestedTraits.offset;
            device_descNestedTraitsCount = dynamicTraits.device_descNestedTraits.count;
            host_descNestedTraitsOffset = dynamicTraits.host_descNestedTraits.offset;
            host_descNestedTraitsCount = dynamicTraits.host_descNestedTraits.count;
            dynMemSize = dynamicTraits.totalDynamicSize;
        }
        
        uint32_t dynMemSize = 0;
        alignas(8) char dynMem[];
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;
        void reassembleNestedStructs() {
            using Cal::Utils::alignUpPow2;

            uint32_t currentOffset = dynamicStructMembersOffset;

            if(device_descNestedTraitsCount > 0){
                assert(currentOffset == device_descNestedTraitsOffset);
                auto* device_descTraits = reinterpret_cast<DynamicStructTraits<ze_device_mem_alloc_desc_t>*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(device_descNestedTraitsCount * sizeof(DynamicStructTraits<ze_device_mem_alloc_desc_t>));
                auto* destDevice_desc = &device_desc;

                for (uint32_t i = 0; i < device_descNestedTraitsCount; ++i) {
                    if(device_descTraits[i].pNextOffset == -1){
                        forcePointerWrite(destDevice_desc[i].pNext, nullptr);
                        continue;
                    }

                    auto device_descPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                    currentOffset += alignUpPow2<8>(device_descTraits[i].pNextCount * sizeof(NestedPNextTraits));

                    assert(currentOffset == static_cast<uint32_t>(device_descPNextListElementTraits[0].extensionOffset));
                    forcePointerWrite(destDevice_desc[i].pNext, dynMem + device_descPNextListElementTraits[0].extensionOffset);
                    currentOffset += alignUpPow2<8>(getUnderlyingSize(static_cast<const ze_base_desc_t*>(destDevice_desc[i].pNext)));

                    auto device_descPNextListElement = static_cast<const ze_base_desc_t*>(destDevice_desc[i].pNext);
                    for(int32_t j = 1; j <= device_descTraits[i].pNextCount; ++j){
                        if (j < device_descTraits[i].pNextCount) {
                            const auto extensionOffset = device_descPNextListElementTraits[j].extensionOffset;
                            forcePointerWrite(getNextField(*device_descPNextListElement), dynMem + extensionOffset);
                        }

                        if (j < device_descTraits[i].pNextCount) {
                            const auto pNextElement = getNext(device_descPNextListElement);
                            const auto sizeInBytes = getUnderlyingSize(pNextElement);
                            currentOffset += alignUpPow2<8>(sizeInBytes);

                            device_descPNextListElement = pNextElement;
                        }

                    }

                }
        }
            if(host_descNestedTraitsCount > 0){
                assert(currentOffset == host_descNestedTraitsOffset);
                auto* host_descTraits = reinterpret_cast<DynamicStructTraits<ze_host_mem_alloc_desc_t>*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(host_descNestedTraitsCount * sizeof(DynamicStructTraits<ze_host_mem_alloc_desc_t>));
                auto* destHost_desc = &host_desc;

                for (uint32_t i = 0; i < host_descNestedTraitsCount; ++i) {
                    if(host_descTraits[i].pNextOffset == -1){
                        forcePointerWrite(destHost_desc[i].pNext, nullptr);
                        continue;
                    }

                    auto host_descPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                    currentOffset += alignUpPow2<8>(host_descTraits[i].pNextCount * sizeof(NestedPNextTraits));

                    assert(currentOffset == static_cast<uint32_t>(host_descPNextListElementTraits[0].extensionOffset));
                    forcePointerWrite(destHost_desc[i].pNext, dynMem + host_descPNextListElementTraits[0].extensionOffset);
                    currentOffset += alignUpPow2<8>(getUnderlyingSize(static_cast<const ze_base_desc_t*>(destHost_desc[i].pNext)));

                    auto host_descPNextListElement = static_cast<const ze_base_desc_t*>(destHost_desc[i].pNext);
                    for(int32_t j = 1; j <= host_descTraits[i].pNextCount; ++j){
                        if (j < host_descTraits[i].pNextCount) {
                            const auto extensionOffset = host_descPNextListElementTraits[j].extensionOffset;
                            forcePointerWrite(getNextField(*host_descPNextListElement), dynMem + extensionOffset);
                        }

                        if (j < host_descTraits[i].pNextCount) {
                            const auto pNextElement = getNext(host_descPNextListElement);
                            const auto sizeInBytes = getUnderlyingSize(pNextElement);
                            currentOffset += alignUpPow2<8>(sizeInBytes);

                            host_descPNextListElement = pNextElement;
                        }

                    }

                }
        }
    }

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeMemAllocSharedRpcM() = default;

    ZeMemAllocSharedRpcM(const Captures::DynamicTraits &dynamicTraits, ze_context_handle_t hContext, const ze_device_mem_alloc_desc_t* device_desc, const ze_host_mem_alloc_desc_t* host_desc, size_t size, size_t alignment, ze_device_handle_t hDevice, void** pptr) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hContext = hContext;
        args.device_desc = device_desc;
        args.host_desc = host_desc;
        args.size = size;
        args.alignment = alignment;
        args.hDevice = hDevice;
        args.pptr = pptr;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeMemAllocSharedRpcM &message, ze_context_handle_t hContext, const ze_device_mem_alloc_desc_t* device_desc, const ze_host_mem_alloc_desc_t* host_desc, size_t size, size_t alignment, ze_device_handle_t hDevice, void** pptr) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hContext = hContext;
        message.args.device_desc = device_desc;
        message.args.host_desc = host_desc;
        message.args.size = size;
        message.args.alignment = alignment;
        message.args.hDevice = hDevice;
        message.args.pptr = pptr;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits, const Cal::Rpc::LevelZero::ZeMemAllocSharedRpcMImplicitArgs &implicitArgs){
        if(args.device_desc){
            captures.device_desc = *args.device_desc;
        }
        if(args.host_desc){
            captures.host_desc = *args.host_desc;
        }
        using Cal::Utils::alignUpPow2;

        auto& dynMem = captures.dynMem;
        uint32_t currentOffset = captures.dynamicStructMembersOffset;
        if(args.device_desc){
            assert(currentOffset == captures.device_descNestedTraitsOffset);
            auto* device_descTraits = reinterpret_cast<DynamicStructTraits<ze_device_mem_alloc_desc_t>*>(dynMem + currentOffset);
            currentOffset += alignUpPow2<8>(captures.device_descNestedTraitsCount * sizeof(DynamicStructTraits<ze_device_mem_alloc_desc_t>));

            for (uint32_t i = 0; i < captures.device_descNestedTraitsCount; ++i) {
                const auto& device_descPNext = args.device_desc[i].pNext;
                if(!device_descPNext){
                    device_descTraits[i].pNextOffset = -1;
                    device_descTraits[i].pNextCount = -1;
                    continue;
                }

                const auto device_descPNextCount = static_cast<int32_t>(countOpaqueList(static_cast<const ze_base_desc_t*>(args.device_desc[i].pNext)));
                if(!device_descPNextCount){
                    device_descTraits[i].pNextOffset = -1;
                    device_descTraits[i].pNextCount = -1;
                    continue;
                }

                device_descTraits[i].pNextOffset = currentOffset;
                device_descTraits[i].pNextCount = device_descPNextCount;
                device_descTraits[i].pNextFirstOriginalElement = args.device_desc[i].pNext;

                auto device_descPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(device_descPNextCount * sizeof(NestedPNextTraits));

                auto device_descPNextListElement = static_cast<const ze_base_desc_t*>(args.device_desc[i].pNext);
                for(int32_t j = 0; j < device_descPNextCount; ++j){
                    device_descPNextListElementTraits[j].extensionType = getExtensionType(device_descPNextListElement);
                    device_descPNextListElementTraits[j].extensionOffset = currentOffset;

                    const auto sizeInBytes = getUnderlyingSize(device_descPNextListElement);
                    std::memcpy(dynMem + currentOffset, device_descPNextListElement, sizeInBytes);
                    currentOffset += alignUpPow2<8>(sizeInBytes);

                    device_descPNextListElement = getNext(device_descPNextListElement);
                }

            }
        }
        if(args.host_desc){
            assert(currentOffset == captures.host_descNestedTraitsOffset);
            auto* host_descTraits = reinterpret_cast<DynamicStructTraits<ze_host_mem_alloc_desc_t>*>(dynMem + currentOffset);
            currentOffset += alignUpPow2<8>(captures.host_descNestedTraitsCount * sizeof(DynamicStructTraits<ze_host_mem_alloc_desc_t>));

            for (uint32_t i = 0; i < captures.host_descNestedTraitsCount; ++i) {
                const auto& host_descPNext = args.host_desc[i].pNext;
                if(!host_descPNext){
                    host_descTraits[i].pNextOffset = -1;
                    host_descTraits[i].pNextCount = -1;
                    continue;
                }

                const auto host_descPNextCount = static_cast<int32_t>(countOpaqueList(static_cast<const ze_base_desc_t*>(args.host_desc[i].pNext)));
                if(!host_descPNextCount){
                    host_descTraits[i].pNextOffset = -1;
                    host_descTraits[i].pNextCount = -1;
                    continue;
                }

                host_descTraits[i].pNextOffset = currentOffset;
                host_descTraits[i].pNextCount = host_descPNextCount;
                host_descTraits[i].pNextFirstOriginalElement = args.host_desc[i].pNext;

                auto host_descPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(host_descPNextCount * sizeof(NestedPNextTraits));

                auto host_descPNextListElement = static_cast<const ze_base_desc_t*>(args.host_desc[i].pNext);
                for(int32_t j = 0; j < host_descPNextCount; ++j){
                    host_descPNextListElementTraits[j].extensionType = getExtensionType(host_descPNextListElement);
                    host_descPNextListElementTraits[j].extensionOffset = currentOffset;

                    const auto sizeInBytes = getUnderlyingSize(host_descPNextListElement);
                    std::memcpy(dynMem + currentOffset, host_descPNextListElement, sizeInBytes);
                    currentOffset += alignUpPow2<8>(sizeInBytes);

                    host_descPNextListElement = getNext(host_descPNextListElement);
                }

            }
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits, Cal::Rpc::LevelZero::ZeMemAllocSharedRpcMImplicitArgs &implicitArgs){
        if(args.pptr){
            *args.pptr = captures.pptr;
        }
         implicitArgs.shmem_resource = this->implicitArgs.shmem_resource;
         implicitArgs.offset_within_resource = this->implicitArgs.offset_within_resource;
         implicitArgs.aligned_size = this->implicitArgs.aligned_size;
    }
};
static_assert(std::is_standard_layout_v<ZeMemAllocSharedRpcM>);
struct ZeMemAllocDeviceRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 153;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_context_handle_t hContext = {};
        const ze_device_mem_alloc_desc_t* device_desc = {};
        size_t size = {};
        size_t alignment = {};
        ze_device_handle_t hDevice = {};
        void** pptr = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hContext == rhs.hContext;
            equal &= this->device_desc == rhs.device_desc;
            equal &= this->size == rhs.size;
            equal &= this->alignment == rhs.alignment;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->pptr == rhs.pptr;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_context_handle_t hContext, const ze_device_mem_alloc_desc_t* device_desc, size_t size, size_t alignment, ze_device_handle_t hDevice, void** pptr);
            uint32_t totalDynamicSize = 0;
            uint32_t dynamicStructMembersOffset = 0;
            DynamicArgTraits device_descNestedTraits = {};
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_device_mem_alloc_desc_t device_desc;
        void* pptr;
        uint32_t dynamicStructMembersOffset = 0;
        uint32_t device_descNestedTraitsOffset = 0;
        uint32_t device_descNestedTraitsCount = 0;

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
            dynamicStructMembersOffset = dynamicTraits.dynamicStructMembersOffset;
            device_descNestedTraitsOffset = dynamicTraits.device_descNestedTraits.offset;
            device_descNestedTraitsCount = dynamicTraits.device_descNestedTraits.count;
            dynMemSize = dynamicTraits.totalDynamicSize;
        }
        
        uint32_t dynMemSize = 0;
        alignas(8) char dynMem[];
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;
        void reassembleNestedStructs() {
            using Cal::Utils::alignUpPow2;

            uint32_t currentOffset = dynamicStructMembersOffset;

            if(device_descNestedTraitsCount > 0){
                assert(currentOffset == device_descNestedTraitsOffset);
                auto* device_descTraits = reinterpret_cast<DynamicStructTraits<ze_device_mem_alloc_desc_t>*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(device_descNestedTraitsCount * sizeof(DynamicStructTraits<ze_device_mem_alloc_desc_t>));
                auto* destDevice_desc = &device_desc;

                for (uint32_t i = 0; i < device_descNestedTraitsCount; ++i) {
                    if(device_descTraits[i].pNextOffset == -1){
                        forcePointerWrite(destDevice_desc[i].pNext, nullptr);
                        continue;
                    }

                    auto device_descPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                    currentOffset += alignUpPow2<8>(device_descTraits[i].pNextCount * sizeof(NestedPNextTraits));

                    assert(currentOffset == static_cast<uint32_t>(device_descPNextListElementTraits[0].extensionOffset));
                    forcePointerWrite(destDevice_desc[i].pNext, dynMem + device_descPNextListElementTraits[0].extensionOffset);
                    currentOffset += alignUpPow2<8>(getUnderlyingSize(static_cast<const ze_base_desc_t*>(destDevice_desc[i].pNext)));

                    auto device_descPNextListElement = static_cast<const ze_base_desc_t*>(destDevice_desc[i].pNext);
                    for(int32_t j = 1; j <= device_descTraits[i].pNextCount; ++j){
                        if (j < device_descTraits[i].pNextCount) {
                            const auto extensionOffset = device_descPNextListElementTraits[j].extensionOffset;
                            forcePointerWrite(getNextField(*device_descPNextListElement), dynMem + extensionOffset);
                        }

                        if (j < device_descTraits[i].pNextCount) {
                            const auto pNextElement = getNext(device_descPNextListElement);
                            const auto sizeInBytes = getUnderlyingSize(pNextElement);
                            currentOffset += alignUpPow2<8>(sizeInBytes);

                            device_descPNextListElement = pNextElement;
                        }

                    }

                }
        }
    }

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeMemAllocDeviceRpcM() = default;

    ZeMemAllocDeviceRpcM(const Captures::DynamicTraits &dynamicTraits, ze_context_handle_t hContext, const ze_device_mem_alloc_desc_t* device_desc, size_t size, size_t alignment, ze_device_handle_t hDevice, void** pptr) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hContext = hContext;
        args.device_desc = device_desc;
        args.size = size;
        args.alignment = alignment;
        args.hDevice = hDevice;
        args.pptr = pptr;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeMemAllocDeviceRpcM &message, ze_context_handle_t hContext, const ze_device_mem_alloc_desc_t* device_desc, size_t size, size_t alignment, ze_device_handle_t hDevice, void** pptr) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hContext = hContext;
        message.args.device_desc = device_desc;
        message.args.size = size;
        message.args.alignment = alignment;
        message.args.hDevice = hDevice;
        message.args.pptr = pptr;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.device_desc){
            captures.device_desc = *args.device_desc;
        }
        using Cal::Utils::alignUpPow2;

        auto& dynMem = captures.dynMem;
        uint32_t currentOffset = captures.dynamicStructMembersOffset;
        if(args.device_desc){
            assert(currentOffset == captures.device_descNestedTraitsOffset);
            auto* device_descTraits = reinterpret_cast<DynamicStructTraits<ze_device_mem_alloc_desc_t>*>(dynMem + currentOffset);
            currentOffset += alignUpPow2<8>(captures.device_descNestedTraitsCount * sizeof(DynamicStructTraits<ze_device_mem_alloc_desc_t>));

            for (uint32_t i = 0; i < captures.device_descNestedTraitsCount; ++i) {
                const auto& device_descPNext = args.device_desc[i].pNext;
                if(!device_descPNext){
                    device_descTraits[i].pNextOffset = -1;
                    device_descTraits[i].pNextCount = -1;
                    continue;
                }

                const auto device_descPNextCount = static_cast<int32_t>(countOpaqueList(static_cast<const ze_base_desc_t*>(args.device_desc[i].pNext)));
                if(!device_descPNextCount){
                    device_descTraits[i].pNextOffset = -1;
                    device_descTraits[i].pNextCount = -1;
                    continue;
                }

                device_descTraits[i].pNextOffset = currentOffset;
                device_descTraits[i].pNextCount = device_descPNextCount;
                device_descTraits[i].pNextFirstOriginalElement = args.device_desc[i].pNext;

                auto device_descPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(device_descPNextCount * sizeof(NestedPNextTraits));

                auto device_descPNextListElement = static_cast<const ze_base_desc_t*>(args.device_desc[i].pNext);
                for(int32_t j = 0; j < device_descPNextCount; ++j){
                    device_descPNextListElementTraits[j].extensionType = getExtensionType(device_descPNextListElement);
                    device_descPNextListElementTraits[j].extensionOffset = currentOffset;

                    const auto sizeInBytes = getUnderlyingSize(device_descPNextListElement);
                    std::memcpy(dynMem + currentOffset, device_descPNextListElement, sizeInBytes);
                    currentOffset += alignUpPow2<8>(sizeInBytes);

                    device_descPNextListElement = getNext(device_descPNextListElement);
                }

            }
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pptr){
            *args.pptr = captures.pptr;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeMemAllocDeviceRpcM>);
struct ZeMemAllocHostRpcMImplicitArgs {
    int shmem_resource = {};
    size_t offset_within_resource = {};
    size_t aligned_size = {};
};

struct ZeMemAllocHostRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 154;
    static constexpr float latency = 1.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_context_handle_t hContext = {};
        const ze_host_mem_alloc_desc_t* host_desc = {};
        size_t size = {};
        size_t alignment = {};
        void** pptr = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hContext == rhs.hContext;
            equal &= this->host_desc == rhs.host_desc;
            equal &= this->size == rhs.size;
            equal &= this->alignment == rhs.alignment;
            equal &= this->pptr == rhs.pptr;
            return equal;
        }
    }args;

    ZeMemAllocHostRpcMImplicitArgs implicitArgs{};
    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_context_handle_t hContext, const ze_host_mem_alloc_desc_t* host_desc, size_t size, size_t alignment, void** pptr);
            uint32_t totalDynamicSize = 0;
            uint32_t dynamicStructMembersOffset = 0;
            DynamicArgTraits host_descNestedTraits = {};
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_host_mem_alloc_desc_t host_desc;
        void* pptr;
        uint32_t dynamicStructMembersOffset = 0;
        uint32_t host_descNestedTraitsOffset = 0;
        uint32_t host_descNestedTraitsCount = 0;

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
            dynamicStructMembersOffset = dynamicTraits.dynamicStructMembersOffset;
            host_descNestedTraitsOffset = dynamicTraits.host_descNestedTraits.offset;
            host_descNestedTraitsCount = dynamicTraits.host_descNestedTraits.count;
            dynMemSize = dynamicTraits.totalDynamicSize;
        }
        
        uint32_t dynMemSize = 0;
        alignas(8) char dynMem[];
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;
        void reassembleNestedStructs() {
            using Cal::Utils::alignUpPow2;

            uint32_t currentOffset = dynamicStructMembersOffset;

            if(host_descNestedTraitsCount > 0){
                assert(currentOffset == host_descNestedTraitsOffset);
                auto* host_descTraits = reinterpret_cast<DynamicStructTraits<ze_host_mem_alloc_desc_t>*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(host_descNestedTraitsCount * sizeof(DynamicStructTraits<ze_host_mem_alloc_desc_t>));
                auto* destHost_desc = &host_desc;

                for (uint32_t i = 0; i < host_descNestedTraitsCount; ++i) {
                    if(host_descTraits[i].pNextOffset == -1){
                        forcePointerWrite(destHost_desc[i].pNext, nullptr);
                        continue;
                    }

                    auto host_descPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                    currentOffset += alignUpPow2<8>(host_descTraits[i].pNextCount * sizeof(NestedPNextTraits));

                    assert(currentOffset == static_cast<uint32_t>(host_descPNextListElementTraits[0].extensionOffset));
                    forcePointerWrite(destHost_desc[i].pNext, dynMem + host_descPNextListElementTraits[0].extensionOffset);
                    currentOffset += alignUpPow2<8>(getUnderlyingSize(static_cast<const ze_base_desc_t*>(destHost_desc[i].pNext)));

                    auto host_descPNextListElement = static_cast<const ze_base_desc_t*>(destHost_desc[i].pNext);
                    for(int32_t j = 1; j <= host_descTraits[i].pNextCount; ++j){
                        if (j < host_descTraits[i].pNextCount) {
                            const auto extensionOffset = host_descPNextListElementTraits[j].extensionOffset;
                            forcePointerWrite(getNextField(*host_descPNextListElement), dynMem + extensionOffset);
                        }

                        if (j < host_descTraits[i].pNextCount) {
                            const auto pNextElement = getNext(host_descPNextListElement);
                            const auto sizeInBytes = getUnderlyingSize(pNextElement);
                            currentOffset += alignUpPow2<8>(sizeInBytes);

                            host_descPNextListElement = pNextElement;
                        }

                    }

                }
        }
    }

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeMemAllocHostRpcM() = default;

    ZeMemAllocHostRpcM(const Captures::DynamicTraits &dynamicTraits, ze_context_handle_t hContext, const ze_host_mem_alloc_desc_t* host_desc, size_t size, size_t alignment, void** pptr) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hContext = hContext;
        args.host_desc = host_desc;
        args.size = size;
        args.alignment = alignment;
        args.pptr = pptr;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeMemAllocHostRpcM &message, ze_context_handle_t hContext, const ze_host_mem_alloc_desc_t* host_desc, size_t size, size_t alignment, void** pptr) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hContext = hContext;
        message.args.host_desc = host_desc;
        message.args.size = size;
        message.args.alignment = alignment;
        message.args.pptr = pptr;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits, const Cal::Rpc::LevelZero::ZeMemAllocHostRpcMImplicitArgs &implicitArgs){
        if(args.host_desc){
            captures.host_desc = *args.host_desc;
        }
        using Cal::Utils::alignUpPow2;

        auto& dynMem = captures.dynMem;
        uint32_t currentOffset = captures.dynamicStructMembersOffset;
        if(args.host_desc){
            assert(currentOffset == captures.host_descNestedTraitsOffset);
            auto* host_descTraits = reinterpret_cast<DynamicStructTraits<ze_host_mem_alloc_desc_t>*>(dynMem + currentOffset);
            currentOffset += alignUpPow2<8>(captures.host_descNestedTraitsCount * sizeof(DynamicStructTraits<ze_host_mem_alloc_desc_t>));

            for (uint32_t i = 0; i < captures.host_descNestedTraitsCount; ++i) {
                const auto& host_descPNext = args.host_desc[i].pNext;
                if(!host_descPNext){
                    host_descTraits[i].pNextOffset = -1;
                    host_descTraits[i].pNextCount = -1;
                    continue;
                }

                const auto host_descPNextCount = static_cast<int32_t>(countOpaqueList(static_cast<const ze_base_desc_t*>(args.host_desc[i].pNext)));
                if(!host_descPNextCount){
                    host_descTraits[i].pNextOffset = -1;
                    host_descTraits[i].pNextCount = -1;
                    continue;
                }

                host_descTraits[i].pNextOffset = currentOffset;
                host_descTraits[i].pNextCount = host_descPNextCount;
                host_descTraits[i].pNextFirstOriginalElement = args.host_desc[i].pNext;

                auto host_descPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(host_descPNextCount * sizeof(NestedPNextTraits));

                auto host_descPNextListElement = static_cast<const ze_base_desc_t*>(args.host_desc[i].pNext);
                for(int32_t j = 0; j < host_descPNextCount; ++j){
                    host_descPNextListElementTraits[j].extensionType = getExtensionType(host_descPNextListElement);
                    host_descPNextListElementTraits[j].extensionOffset = currentOffset;

                    const auto sizeInBytes = getUnderlyingSize(host_descPNextListElement);
                    std::memcpy(dynMem + currentOffset, host_descPNextListElement, sizeInBytes);
                    currentOffset += alignUpPow2<8>(sizeInBytes);

                    host_descPNextListElement = getNext(host_descPNextListElement);
                }

            }
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits, Cal::Rpc::LevelZero::ZeMemAllocHostRpcMImplicitArgs &implicitArgs){
        if(args.pptr){
            *args.pptr = captures.pptr;
        }
         implicitArgs.shmem_resource = this->implicitArgs.shmem_resource;
         implicitArgs.offset_within_resource = this->implicitArgs.offset_within_resource;
         implicitArgs.aligned_size = this->implicitArgs.aligned_size;
    }
};
static_assert(std::is_standard_layout_v<ZeMemAllocHostRpcM>);
struct ZeMemFreeRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 155;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_context_handle_t hContext = {};
        void* ptr = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hContext == rhs.hContext;
            equal &= this->ptr == rhs.ptr;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeMemFreeRpcM() = default;

    ZeMemFreeRpcM(ze_context_handle_t hContext, void* ptr) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hContext = hContext;
        args.ptr = ptr;
    }
    
    static void fillWithoutCapture(ZeMemFreeRpcM &message, ze_context_handle_t hContext, void* ptr) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hContext = hContext;
        message.args.ptr = ptr;
    }
    
};
static_assert(std::is_standard_layout_v<ZeMemFreeRpcM>);
struct ZeMemGetAllocPropertiesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 156;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_context_handle_t hContext = {};
        const void* ptr = {};
        ze_memory_allocation_properties_t* pMemAllocProperties = {};
        ze_device_handle_t* phDevice = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hContext == rhs.hContext;
            equal &= this->ptr == rhs.ptr;
            equal &= this->pMemAllocProperties == rhs.pMemAllocProperties;
            equal &= this->phDevice == rhs.phDevice;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_context_handle_t hContext, const void* ptr, ze_memory_allocation_properties_t* pMemAllocProperties, ze_device_handle_t* phDevice);
            uint32_t totalDynamicSize = 0;
            uint32_t dynamicStructMembersOffset = 0;
            DynamicArgTraits pMemAllocPropertiesNestedTraits = {};
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_memory_allocation_properties_t pMemAllocProperties;
        ze_device_handle_t phDevice;
        uint32_t dynamicStructMembersOffset = 0;
        uint32_t pMemAllocPropertiesNestedTraitsOffset = 0;
        uint32_t pMemAllocPropertiesNestedTraitsCount = 0;

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
            dynamicStructMembersOffset = dynamicTraits.dynamicStructMembersOffset;
            pMemAllocPropertiesNestedTraitsOffset = dynamicTraits.pMemAllocPropertiesNestedTraits.offset;
            pMemAllocPropertiesNestedTraitsCount = dynamicTraits.pMemAllocPropertiesNestedTraits.count;
            dynMemSize = dynamicTraits.totalDynamicSize;
        }
        
        uint32_t dynMemSize = 0;
        alignas(8) char dynMem[];
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;
        void reassembleNestedStructs() {
            using Cal::Utils::alignUpPow2;

            uint32_t currentOffset = dynamicStructMembersOffset;

            if(pMemAllocPropertiesNestedTraitsCount > 0){
                assert(currentOffset == pMemAllocPropertiesNestedTraitsOffset);
                auto* pMemAllocPropertiesTraits = reinterpret_cast<DynamicStructTraits<ze_memory_allocation_properties_t>*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(pMemAllocPropertiesNestedTraitsCount * sizeof(DynamicStructTraits<ze_memory_allocation_properties_t>));
                auto* destPMemAllocProperties = &pMemAllocProperties;

                for (uint32_t i = 0; i < pMemAllocPropertiesNestedTraitsCount; ++i) {
                    if(pMemAllocPropertiesTraits[i].pNextOffset == -1){
                        forcePointerWrite(destPMemAllocProperties[i].pNext, nullptr);
                        continue;
                    }

                    auto pMemAllocPropertiesPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                    currentOffset += alignUpPow2<8>(pMemAllocPropertiesTraits[i].pNextCount * sizeof(NestedPNextTraits));

                    assert(currentOffset == static_cast<uint32_t>(pMemAllocPropertiesPNextListElementTraits[0].extensionOffset));
                    forcePointerWrite(destPMemAllocProperties[i].pNext, dynMem + pMemAllocPropertiesPNextListElementTraits[0].extensionOffset);
                    currentOffset += alignUpPow2<8>(getUnderlyingSize(static_cast<const ze_base_desc_t*>(destPMemAllocProperties[i].pNext)));

                    auto pMemAllocPropertiesPNextListElement = static_cast<const ze_base_desc_t*>(destPMemAllocProperties[i].pNext);
                    for(int32_t j = 1; j <= pMemAllocPropertiesTraits[i].pNextCount; ++j){
                        if (j < pMemAllocPropertiesTraits[i].pNextCount) {
                            const auto extensionOffset = pMemAllocPropertiesPNextListElementTraits[j].extensionOffset;
                            forcePointerWrite(getNextField(*pMemAllocPropertiesPNextListElement), dynMem + extensionOffset);
                        }

                        if (j < pMemAllocPropertiesTraits[i].pNextCount) {
                            const auto pNextElement = getNext(pMemAllocPropertiesPNextListElement);
                            const auto sizeInBytes = getUnderlyingSize(pNextElement);
                            currentOffset += alignUpPow2<8>(sizeInBytes);

                            pMemAllocPropertiesPNextListElement = pNextElement;
                        }

                    }

                }
        }
    }

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeMemGetAllocPropertiesRpcM() = default;

    ZeMemGetAllocPropertiesRpcM(const Captures::DynamicTraits &dynamicTraits, ze_context_handle_t hContext, const void* ptr, ze_memory_allocation_properties_t* pMemAllocProperties, ze_device_handle_t* phDevice) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hContext = hContext;
        args.ptr = ptr;
        args.pMemAllocProperties = pMemAllocProperties;
        args.phDevice = phDevice;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeMemGetAllocPropertiesRpcM &message, ze_context_handle_t hContext, const void* ptr, ze_memory_allocation_properties_t* pMemAllocProperties, ze_device_handle_t* phDevice) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hContext = hContext;
        message.args.ptr = ptr;
        message.args.pMemAllocProperties = pMemAllocProperties;
        message.args.phDevice = phDevice;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pMemAllocProperties){
            captures.pMemAllocProperties = *args.pMemAllocProperties;
        }
        using Cal::Utils::alignUpPow2;

        auto& dynMem = captures.dynMem;
        uint32_t currentOffset = captures.dynamicStructMembersOffset;
        if(args.pMemAllocProperties){
            assert(currentOffset == captures.pMemAllocPropertiesNestedTraitsOffset);
            auto* pMemAllocPropertiesTraits = reinterpret_cast<DynamicStructTraits<ze_memory_allocation_properties_t>*>(dynMem + currentOffset);
            currentOffset += alignUpPow2<8>(captures.pMemAllocPropertiesNestedTraitsCount * sizeof(DynamicStructTraits<ze_memory_allocation_properties_t>));

            for (uint32_t i = 0; i < captures.pMemAllocPropertiesNestedTraitsCount; ++i) {
                const auto& pMemAllocPropertiesPNext = args.pMemAllocProperties[i].pNext;
                if(!pMemAllocPropertiesPNext){
                    pMemAllocPropertiesTraits[i].pNextOffset = -1;
                    pMemAllocPropertiesTraits[i].pNextCount = -1;
                    continue;
                }

                const auto pMemAllocPropertiesPNextCount = static_cast<int32_t>(countOpaqueList(static_cast<const ze_base_desc_t*>(args.pMemAllocProperties[i].pNext)));
                if(!pMemAllocPropertiesPNextCount){
                    pMemAllocPropertiesTraits[i].pNextOffset = -1;
                    pMemAllocPropertiesTraits[i].pNextCount = -1;
                    continue;
                }

                pMemAllocPropertiesTraits[i].pNextOffset = currentOffset;
                pMemAllocPropertiesTraits[i].pNextCount = pMemAllocPropertiesPNextCount;
                pMemAllocPropertiesTraits[i].pNextFirstOriginalElement = args.pMemAllocProperties[i].pNext;

                auto pMemAllocPropertiesPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(pMemAllocPropertiesPNextCount * sizeof(NestedPNextTraits));

                auto pMemAllocPropertiesPNextListElement = static_cast<const ze_base_desc_t*>(args.pMemAllocProperties[i].pNext);
                for(int32_t j = 0; j < pMemAllocPropertiesPNextCount; ++j){
                    pMemAllocPropertiesPNextListElementTraits[j].extensionType = getExtensionType(pMemAllocPropertiesPNextListElement);
                    pMemAllocPropertiesPNextListElementTraits[j].extensionOffset = currentOffset;

                    const auto sizeInBytes = getUnderlyingSize(pMemAllocPropertiesPNextListElement);
                    std::memcpy(dynMem + currentOffset, pMemAllocPropertiesPNextListElement, sizeInBytes);
                    currentOffset += alignUpPow2<8>(sizeInBytes);

                    pMemAllocPropertiesPNextListElement = getNext(pMemAllocPropertiesPNextListElement);
                }

            }
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pMemAllocProperties){
            *args.pMemAllocProperties = captures.pMemAllocProperties;
        }
        if(args.phDevice){
            *args.phDevice = captures.phDevice;
        }
        using Cal::Utils::alignUpPow2;

        auto& dynMem = captures.dynMem;
        uint32_t currentOffset = captures.dynamicStructMembersOffset;
        if(args.pMemAllocProperties) {
            assert(currentOffset == captures.pMemAllocPropertiesNestedTraitsOffset);
            auto* pMemAllocPropertiesTraits = reinterpret_cast<DynamicStructTraits<ze_memory_allocation_properties_t>*>(dynMem + currentOffset);
            currentOffset += alignUpPow2<8>(captures.pMemAllocPropertiesNestedTraitsCount * sizeof(DynamicStructTraits<ze_memory_allocation_properties_t>));

            auto* destPMemAllocProperties = args.pMemAllocProperties;

            for (uint32_t i = 0; i < captures.pMemAllocPropertiesNestedTraitsCount; ++i) {
                if(pMemAllocPropertiesTraits[i].pNextOffset == -1){
                    continue;
                }

                destPMemAllocProperties[i].pNext = pMemAllocPropertiesTraits[i].pNextFirstOriginalElement;

                auto pMemAllocPropertiesPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(pMemAllocPropertiesTraits[i].pNextCount * sizeof(NestedPNextTraits));

                auto pMemAllocPropertiesPNextListElement = static_cast<const ze_base_desc_t*>(destPMemAllocProperties[i].pNext);
                for(int32_t j = 0; j < pMemAllocPropertiesTraits[i].pNextCount; ++j){
                    const auto sizeInBytes = getUnderlyingSize(pMemAllocPropertiesPNextListElement);
                    currentOffset += alignUpPow2<8>(sizeInBytes);

                    const auto extensionType = getExtensionType(pMemAllocPropertiesPNextListElement);
                    if (!isReadOnly(extensionType)) {
                        {
                            auto originalNextOpaqueElement = getNext(pMemAllocPropertiesPNextListElement);
                            const auto extensionOffset = pMemAllocPropertiesPNextListElementTraits[j].extensionOffset;
                            auto destination = const_cast<ze_base_desc_t*>(pMemAllocPropertiesPNextListElement);
                            std::memcpy(destination, dynMem + extensionOffset, sizeInBytes);

                            getNextField(*destination) = originalNextOpaqueElement;
                        }

                    }

                    pMemAllocPropertiesPNextListElement = getNext(pMemAllocPropertiesPNextListElement);
                }

            }
        }
    }
};
static_assert(std::is_standard_layout_v<ZeMemGetAllocPropertiesRpcM>);
struct ZeMemGetAddressRangeRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 157;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_context_handle_t hContext = {};
        const void* ptr = {};
        void** pBase = {};
        size_t* pSize = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hContext == rhs.hContext;
            equal &= this->ptr == rhs.ptr;
            equal &= this->pBase == rhs.pBase;
            equal &= this->pSize == rhs.pSize;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        void* pBase;
        size_t pSize;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeMemGetAddressRangeRpcM() = default;

    ZeMemGetAddressRangeRpcM(ze_context_handle_t hContext, const void* ptr, void** pBase, size_t* pSize) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hContext = hContext;
        args.ptr = ptr;
        args.pBase = pBase;
        args.pSize = pSize;
    }
    
    static void fillWithoutCapture(ZeMemGetAddressRangeRpcM &message, ze_context_handle_t hContext, const void* ptr, void** pBase, size_t* pSize) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hContext = hContext;
        message.args.ptr = ptr;
        message.args.pBase = pBase;
        message.args.pSize = pSize;
    }
    

    void copyToCaller(){
        if(args.pBase){
            *args.pBase = captures.pBase;
        }
        if(args.pSize){
            *args.pSize = captures.pSize;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeMemGetAddressRangeRpcM>);
struct ZeMemGetIpcHandleRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 158;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_context_handle_t hContext = {};
        const void* ptr = {};
        ze_ipc_mem_handle_t* pIpcHandle = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hContext == rhs.hContext;
            equal &= this->ptr == rhs.ptr;
            equal &= this->pIpcHandle == rhs.pIpcHandle;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_ipc_mem_handle_t pIpcHandle;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeMemGetIpcHandleRpcM() = default;

    ZeMemGetIpcHandleRpcM(ze_context_handle_t hContext, const void* ptr, ze_ipc_mem_handle_t* pIpcHandle) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hContext = hContext;
        args.ptr = ptr;
        args.pIpcHandle = pIpcHandle;
    }
    
    static void fillWithoutCapture(ZeMemGetIpcHandleRpcM &message, ze_context_handle_t hContext, const void* ptr, ze_ipc_mem_handle_t* pIpcHandle) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hContext = hContext;
        message.args.ptr = ptr;
        message.args.pIpcHandle = pIpcHandle;
    }
    

    void copyToCaller(){
        if(args.pIpcHandle){
            *args.pIpcHandle = captures.pIpcHandle;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeMemGetIpcHandleRpcM>);
struct ZeMemOpenIpcHandleRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 159;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_context_handle_t hContext = {};
        ze_device_handle_t hDevice = {};
        ze_ipc_mem_handle_t handle = {};
        ze_ipc_memory_flags_t flags = {};
        void** pptr = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hContext == rhs.hContext;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->handle == rhs.handle;
            equal &= this->flags == rhs.flags;
            equal &= this->pptr == rhs.pptr;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        void* pptr;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeMemOpenIpcHandleRpcM() = default;

    ZeMemOpenIpcHandleRpcM(ze_context_handle_t hContext, ze_device_handle_t hDevice, ze_ipc_mem_handle_t handle, ze_ipc_memory_flags_t flags, void** pptr) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hContext = hContext;
        args.hDevice = hDevice;
        args.handle = handle;
        args.flags = flags;
        args.pptr = pptr;
    }
    
    static void fillWithoutCapture(ZeMemOpenIpcHandleRpcM &message, ze_context_handle_t hContext, ze_device_handle_t hDevice, ze_ipc_mem_handle_t handle, ze_ipc_memory_flags_t flags, void** pptr) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hContext = hContext;
        message.args.hDevice = hDevice;
        message.args.handle = handle;
        message.args.flags = flags;
        message.args.pptr = pptr;
    }
    

    void copyToCaller(){
        if(args.pptr){
            *args.pptr = captures.pptr;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeMemOpenIpcHandleRpcM>);
struct ZeMemCloseIpcHandleRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 160;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_context_handle_t hContext = {};
        const void* ptr = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hContext == rhs.hContext;
            equal &= this->ptr == rhs.ptr;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeMemCloseIpcHandleRpcM() = default;

    ZeMemCloseIpcHandleRpcM(ze_context_handle_t hContext, const void* ptr) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hContext = hContext;
        args.ptr = ptr;
    }
    
    static void fillWithoutCapture(ZeMemCloseIpcHandleRpcM &message, ze_context_handle_t hContext, const void* ptr) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hContext = hContext;
        message.args.ptr = ptr;
    }
    
};
static_assert(std::is_standard_layout_v<ZeMemCloseIpcHandleRpcM>);
struct ZexMemGetIpcHandlesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 161;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_context_handle_t hContext = {};
        const void* ptr = {};
        uint32_t* numIpcHandles = {};
        ze_ipc_mem_handle_t* pIpcHandles = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hContext == rhs.hContext;
            equal &= this->ptr == rhs.ptr;
            equal &= this->numIpcHandles == rhs.numIpcHandles;
            equal &= this->pIpcHandles == rhs.pIpcHandles;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_context_handle_t hContext, const void* ptr, uint32_t* numIpcHandles, ze_ipc_mem_handle_t* pIpcHandles);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits pIpcHandles = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t numIpcHandles;
        uint32_t countPIpcHandles = 0;
        ze_ipc_mem_handle_t pIpcHandles[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPIpcHandles = dynamicTraits.pIpcHandles.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZexMemGetIpcHandlesRpcM() = default;

    ZexMemGetIpcHandlesRpcM(const Captures::DynamicTraits &dynamicTraits, ze_context_handle_t hContext, const void* ptr, uint32_t* numIpcHandles, ze_ipc_mem_handle_t* pIpcHandles) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hContext = hContext;
        args.ptr = ptr;
        args.numIpcHandles = numIpcHandles;
        args.pIpcHandles = pIpcHandles;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZexMemGetIpcHandlesRpcM &message, ze_context_handle_t hContext, const void* ptr, uint32_t* numIpcHandles, ze_ipc_mem_handle_t* pIpcHandles) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hContext = hContext;
        message.args.ptr = ptr;
        message.args.numIpcHandles = numIpcHandles;
        message.args.pIpcHandles = pIpcHandles;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.numIpcHandles){
            captures.numIpcHandles = *args.numIpcHandles;
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.numIpcHandles){
            *args.numIpcHandles = captures.numIpcHandles;
        }
        if(args.pIpcHandles){
            memcpy(args.pIpcHandles, captures.pIpcHandles, dynMemTraits.pIpcHandles.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZexMemGetIpcHandlesRpcM>);
struct ZexMemOpenIpcHandlesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 162;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_context_handle_t hContext = {};
        ze_device_handle_t hDevice = {};
        uint32_t numIpcHandles = {};
        ze_ipc_mem_handle_t* pIpcHandles = {};
        ze_ipc_memory_flags_t flags = {};
        void** pptr = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hContext == rhs.hContext;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->numIpcHandles == rhs.numIpcHandles;
            equal &= this->pIpcHandles == rhs.pIpcHandles;
            equal &= this->flags == rhs.flags;
            equal &= this->pptr == rhs.pptr;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_context_handle_t hContext, ze_device_handle_t hDevice, uint32_t numIpcHandles, ze_ipc_mem_handle_t* pIpcHandles, ze_ipc_memory_flags_t flags, void** pptr);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits pIpcHandles = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        void* pptr;
        uint32_t countPIpcHandles = 0;
        ze_ipc_mem_handle_t pIpcHandles[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPIpcHandles = dynamicTraits.pIpcHandles.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZexMemOpenIpcHandlesRpcM() = default;

    ZexMemOpenIpcHandlesRpcM(const Captures::DynamicTraits &dynamicTraits, ze_context_handle_t hContext, ze_device_handle_t hDevice, uint32_t numIpcHandles, ze_ipc_mem_handle_t* pIpcHandles, ze_ipc_memory_flags_t flags, void** pptr) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hContext = hContext;
        args.hDevice = hDevice;
        args.numIpcHandles = numIpcHandles;
        args.pIpcHandles = pIpcHandles;
        args.flags = flags;
        args.pptr = pptr;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZexMemOpenIpcHandlesRpcM &message, ze_context_handle_t hContext, ze_device_handle_t hDevice, uint32_t numIpcHandles, ze_ipc_mem_handle_t* pIpcHandles, ze_ipc_memory_flags_t flags, void** pptr) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hContext = hContext;
        message.args.hDevice = hDevice;
        message.args.numIpcHandles = numIpcHandles;
        message.args.pIpcHandles = pIpcHandles;
        message.args.flags = flags;
        message.args.pptr = pptr;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pIpcHandles){
            memcpy(asMemcpyDstT(captures.pIpcHandles), args.pIpcHandles, dynMemTraits.pIpcHandles.size);
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pptr){
            *args.pptr = captures.pptr;
        }
    }
};
static_assert(std::is_standard_layout_v<ZexMemOpenIpcHandlesRpcM>);
struct ZeMemFreeExtRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 163;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_context_handle_t hContext = {};
        const ze_memory_free_ext_desc_t* pMemFreeDesc = {};
        void* ptr = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hContext == rhs.hContext;
            equal &= this->pMemFreeDesc == rhs.pMemFreeDesc;
            equal &= this->ptr == rhs.ptr;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_context_handle_t hContext, const ze_memory_free_ext_desc_t* pMemFreeDesc, void* ptr);
            uint32_t totalDynamicSize = 0;
            uint32_t dynamicStructMembersOffset = 0;
            DynamicArgTraits pMemFreeDescNestedTraits = {};
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_memory_free_ext_desc_t pMemFreeDesc;
        uint32_t dynamicStructMembersOffset = 0;
        uint32_t pMemFreeDescNestedTraitsOffset = 0;
        uint32_t pMemFreeDescNestedTraitsCount = 0;

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
            dynamicStructMembersOffset = dynamicTraits.dynamicStructMembersOffset;
            pMemFreeDescNestedTraitsOffset = dynamicTraits.pMemFreeDescNestedTraits.offset;
            pMemFreeDescNestedTraitsCount = dynamicTraits.pMemFreeDescNestedTraits.count;
            dynMemSize = dynamicTraits.totalDynamicSize;
        }
        
        uint32_t dynMemSize = 0;
        alignas(8) char dynMem[];
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;
        void reassembleNestedStructs() {
            using Cal::Utils::alignUpPow2;

            uint32_t currentOffset = dynamicStructMembersOffset;

            if(pMemFreeDescNestedTraitsCount > 0){
                assert(currentOffset == pMemFreeDescNestedTraitsOffset);
                auto* pMemFreeDescTraits = reinterpret_cast<DynamicStructTraits<ze_memory_free_ext_desc_t>*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(pMemFreeDescNestedTraitsCount * sizeof(DynamicStructTraits<ze_memory_free_ext_desc_t>));
                auto* destPMemFreeDesc = &pMemFreeDesc;

                for (uint32_t i = 0; i < pMemFreeDescNestedTraitsCount; ++i) {
                    if(pMemFreeDescTraits[i].pNextOffset == -1){
                        forcePointerWrite(destPMemFreeDesc[i].pNext, nullptr);
                        continue;
                    }

                    auto pMemFreeDescPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                    currentOffset += alignUpPow2<8>(pMemFreeDescTraits[i].pNextCount * sizeof(NestedPNextTraits));

                    assert(currentOffset == static_cast<uint32_t>(pMemFreeDescPNextListElementTraits[0].extensionOffset));
                    forcePointerWrite(destPMemFreeDesc[i].pNext, dynMem + pMemFreeDescPNextListElementTraits[0].extensionOffset);
                    currentOffset += alignUpPow2<8>(getUnderlyingSize(static_cast<const ze_base_desc_t*>(destPMemFreeDesc[i].pNext)));

                    auto pMemFreeDescPNextListElement = static_cast<const ze_base_desc_t*>(destPMemFreeDesc[i].pNext);
                    for(int32_t j = 1; j <= pMemFreeDescTraits[i].pNextCount; ++j){
                        if (j < pMemFreeDescTraits[i].pNextCount) {
                            const auto extensionOffset = pMemFreeDescPNextListElementTraits[j].extensionOffset;
                            forcePointerWrite(getNextField(*pMemFreeDescPNextListElement), dynMem + extensionOffset);
                        }

                        if (j < pMemFreeDescTraits[i].pNextCount) {
                            const auto pNextElement = getNext(pMemFreeDescPNextListElement);
                            const auto sizeInBytes = getUnderlyingSize(pNextElement);
                            currentOffset += alignUpPow2<8>(sizeInBytes);

                            pMemFreeDescPNextListElement = pNextElement;
                        }

                    }

                }
        }
    }

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeMemFreeExtRpcM() = default;

    ZeMemFreeExtRpcM(const Captures::DynamicTraits &dynamicTraits, ze_context_handle_t hContext, const ze_memory_free_ext_desc_t* pMemFreeDesc, void* ptr) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hContext = hContext;
        args.pMemFreeDesc = pMemFreeDesc;
        args.ptr = ptr;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeMemFreeExtRpcM &message, ze_context_handle_t hContext, const ze_memory_free_ext_desc_t* pMemFreeDesc, void* ptr) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hContext = hContext;
        message.args.pMemFreeDesc = pMemFreeDesc;
        message.args.ptr = ptr;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pMemFreeDesc){
            captures.pMemFreeDesc = *args.pMemFreeDesc;
        }
        using Cal::Utils::alignUpPow2;

        auto& dynMem = captures.dynMem;
        uint32_t currentOffset = captures.dynamicStructMembersOffset;
        if(args.pMemFreeDesc){
            assert(currentOffset == captures.pMemFreeDescNestedTraitsOffset);
            auto* pMemFreeDescTraits = reinterpret_cast<DynamicStructTraits<ze_memory_free_ext_desc_t>*>(dynMem + currentOffset);
            currentOffset += alignUpPow2<8>(captures.pMemFreeDescNestedTraitsCount * sizeof(DynamicStructTraits<ze_memory_free_ext_desc_t>));

            for (uint32_t i = 0; i < captures.pMemFreeDescNestedTraitsCount; ++i) {
                const auto& pMemFreeDescPNext = args.pMemFreeDesc[i].pNext;
                if(!pMemFreeDescPNext){
                    pMemFreeDescTraits[i].pNextOffset = -1;
                    pMemFreeDescTraits[i].pNextCount = -1;
                    continue;
                }

                const auto pMemFreeDescPNextCount = static_cast<int32_t>(countOpaqueList(static_cast<const ze_base_desc_t*>(args.pMemFreeDesc[i].pNext)));
                if(!pMemFreeDescPNextCount){
                    pMemFreeDescTraits[i].pNextOffset = -1;
                    pMemFreeDescTraits[i].pNextCount = -1;
                    continue;
                }

                pMemFreeDescTraits[i].pNextOffset = currentOffset;
                pMemFreeDescTraits[i].pNextCount = pMemFreeDescPNextCount;
                pMemFreeDescTraits[i].pNextFirstOriginalElement = args.pMemFreeDesc[i].pNext;

                auto pMemFreeDescPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(pMemFreeDescPNextCount * sizeof(NestedPNextTraits));

                auto pMemFreeDescPNextListElement = static_cast<const ze_base_desc_t*>(args.pMemFreeDesc[i].pNext);
                for(int32_t j = 0; j < pMemFreeDescPNextCount; ++j){
                    pMemFreeDescPNextListElementTraits[j].extensionType = getExtensionType(pMemFreeDescPNextListElement);
                    pMemFreeDescPNextListElementTraits[j].extensionOffset = currentOffset;

                    const auto sizeInBytes = getUnderlyingSize(pMemFreeDescPNextListElement);
                    std::memcpy(dynMem + currentOffset, pMemFreeDescPNextListElement, sizeInBytes);
                    currentOffset += alignUpPow2<8>(sizeInBytes);

                    pMemFreeDescPNextListElement = getNext(pMemFreeDescPNextListElement);
                }

            }
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
    }
};
static_assert(std::is_standard_layout_v<ZeMemFreeExtRpcM>);
struct ZeModuleCreateRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 164;
    static constexpr float latency = 2.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_context_handle_t hContext = {};
        ze_device_handle_t hDevice = {};
        const ze_module_desc_t* desc = {};
        ze_module_handle_t* phModule = {};
        ze_module_build_log_handle_t* phBuildLog = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hContext == rhs.hContext;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->desc == rhs.desc;
            equal &= this->phModule == rhs.phModule;
            equal &= this->phBuildLog == rhs.phBuildLog;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_context_handle_t hContext, ze_device_handle_t hDevice, const ze_module_desc_t* desc, ze_module_handle_t* phModule, ze_module_build_log_handle_t* phBuildLog);
            uint32_t totalDynamicSize = 0;
            uint32_t dynamicStructMembersOffset = 0;
            DynamicArgTraits descNestedTraits = {};
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_module_desc_t desc;
        ze_module_handle_t phModule;
        ze_module_build_log_handle_t phBuildLog;
        uint32_t dynamicStructMembersOffset = 0;
        uint32_t descNestedTraitsOffset = 0;
        uint32_t descNestedTraitsCount = 0;

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
            dynamicStructMembersOffset = dynamicTraits.dynamicStructMembersOffset;
            descNestedTraitsOffset = dynamicTraits.descNestedTraits.offset;
            descNestedTraitsCount = dynamicTraits.descNestedTraits.count;
            dynMemSize = dynamicTraits.totalDynamicSize;
        }
        
        uint32_t dynMemSize = 0;
        alignas(8) char dynMem[];
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;
        void reassembleNestedStructs() {
            using Cal::Utils::alignUpPow2;

            uint32_t currentOffset = dynamicStructMembersOffset;

            if(descNestedTraitsCount > 0){
                assert(currentOffset == descNestedTraitsOffset);
                auto* descTraits = reinterpret_cast<DynamicStructTraits<ze_module_desc_t>*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(descNestedTraitsCount * sizeof(DynamicStructTraits<ze_module_desc_t>));
                auto* destDesc = &desc;

                for (uint32_t i = 0; i < descNestedTraitsCount; ++i) {
                    if(descTraits[i].pNextOffset == -1){
                        forcePointerWrite(destDesc[i].pNext, nullptr);
                        continue;
                    }

                    auto descPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                    currentOffset += alignUpPow2<8>(descTraits[i].pNextCount * sizeof(NestedPNextTraits));

                    assert(currentOffset == static_cast<uint32_t>(descPNextListElementTraits[0].extensionOffset));
                    forcePointerWrite(destDesc[i].pNext, dynMem + descPNextListElementTraits[0].extensionOffset);
                    currentOffset += alignUpPow2<8>(getUnderlyingSize(static_cast<const ze_base_desc_t*>(destDesc[i].pNext)));

                    auto descPNextListElement = static_cast<const ze_base_desc_t*>(destDesc[i].pNext);
                    for(int32_t j = 1; j <= descTraits[i].pNextCount; ++j){
                        if (j < descTraits[i].pNextCount) {
                            const auto extensionOffset = descPNextListElementTraits[j].extensionOffset;
                            forcePointerWrite(getNextField(*descPNextListElement), dynMem + extensionOffset);
                        }

                        const auto extensionType = static_cast<int>(descPNextListElementTraits[j - 1].extensionType);
                        if (extensionType == ZE_STRUCTURE_TYPE_MODULE_PROGRAM_EXP_DESC) {
                            auto& extension = *reinterpret_cast<const ze_module_program_exp_desc_t*>(descPNextListElement);
                            auto* extensionTraits = reinterpret_cast<DynamicStructTraits<ze_module_program_exp_desc_t>*>(dynMem + currentOffset);
                            currentOffset += alignUpPow2<8>(sizeof(DynamicStructTraits<ze_module_program_exp_desc_t>));

                            for(int32_t k = 0; k < 1; ++k) {
                                if(extensionTraits[k].inputSizesOffset == -1){
                                    forcePointerWrite(extension.inputSizes, nullptr);
                                    continue;
                                }

                                forcePointerWrite(extension.inputSizes, dynMem + extensionTraits[k].inputSizesOffset);
                                currentOffset += alignUpPow2<8>(extensionTraits[k].inputSizesCount * sizeof(size_t));
                            }

                            for(int32_t k = 0; k < 1; ++k) {
                                if(extensionTraits[k].pInputModulesOffset == -1){
                                    forcePointerWrite(extension.pInputModules, nullptr);
                                    continue;
                                }

                                forcePointerWrite(extension.pInputModules, dynMem + extensionTraits[k].pInputModulesOffset);
                                currentOffset += alignUpPow2<8>(extensionTraits[k].pInputModulesCount * sizeof(const uint8_t*));

                                auto* descPNextPInputModulesTraits = reinterpret_cast<DynamicStructTraits<const uint8_t*>*>(dynMem + currentOffset);
                                currentOffset += alignUpPow2<8>(extensionTraits[k].pInputModulesCount * sizeof(DynamicStructTraits<const uint8_t*>));

                                for(int32_t l = 0; l < extensionTraits[k].pInputModulesCount; ++l){
                                    if(descPNextPInputModulesTraits[l].offset == -1){
                                        forcePointerWrite(extension.pInputModules[l], nullptr);
                                        continue;
                                    }

                                    forcePointerWrite(extension.pInputModules[l], dynMem + descPNextPInputModulesTraits[l].offset);
                                    currentOffset += alignUpPow2<8>(descPNextPInputModulesTraits[l].count * sizeof(uint8_t));
                                }

                            }

                            for(int32_t k = 0; k < 1; ++k) {
                                if(extensionTraits[k].pBuildFlagsOffset == -1){
                                    forcePointerWrite(extension.pBuildFlags, nullptr);
                                    continue;
                                }

                                forcePointerWrite(extension.pBuildFlags, dynMem + extensionTraits[k].pBuildFlagsOffset);
                                currentOffset += alignUpPow2<8>(extensionTraits[k].pBuildFlagsCount * sizeof(const char*));

                                auto* descPNextPBuildFlagsTraits = reinterpret_cast<DynamicStructTraits<const char*>*>(dynMem + currentOffset);
                                currentOffset += alignUpPow2<8>(extensionTraits[k].pBuildFlagsCount * sizeof(DynamicStructTraits<const char*>));

                                for(int32_t l = 0; l < extensionTraits[k].pBuildFlagsCount; ++l){
                                    if(descPNextPBuildFlagsTraits[l].offset == -1){
                                        forcePointerWrite(extension.pBuildFlags[l], nullptr);
                                        continue;
                                    }

                                    forcePointerWrite(extension.pBuildFlags[l], dynMem + descPNextPBuildFlagsTraits[l].offset);
                                    currentOffset += alignUpPow2<8>(descPNextPBuildFlagsTraits[l].count * sizeof(char));
                                }

                            }

                            for(int32_t k = 0; k < 1; ++k) {
                                if(extensionTraits[k].pConstantsOffset == -1){
                                    forcePointerWrite(extension.pConstants, nullptr);
                                    continue;
                                }

                                forcePointerWrite(extension.pConstants, dynMem + extensionTraits[k].pConstantsOffset);
                                currentOffset += alignUpPow2<8>(extensionTraits[k].pConstantsCount * sizeof(const ze_module_constants_t*));

                                auto* descPNextPConstantsTraits = reinterpret_cast<DynamicStructTraits<const ze_module_constants_t*>*>(dynMem + currentOffset);
                                currentOffset += alignUpPow2<8>(extensionTraits[k].pConstantsCount * sizeof(DynamicStructTraits<const ze_module_constants_t*>));

                                for(int32_t l = 0; l < extensionTraits[k].pConstantsCount; ++l){
                                    if(descPNextPConstantsTraits[l].offset == -1){
                                        forcePointerWrite(extension.pConstants[l], nullptr);
                                        continue;
                                    }

                                    forcePointerWrite(extension.pConstants[l], dynMem + descPNextPConstantsTraits[l].offset);
                                    currentOffset += alignUpPow2<8>(descPNextPConstantsTraits[l].count * sizeof(ze_module_constants_t));

                                    auto* nestedChildTraits = reinterpret_cast<DynamicStructTraits<ze_module_constants_t>*>(dynMem + currentOffset);
                                    currentOffset += alignUpPow2<8>(descPNextPConstantsTraits[l].count * sizeof(DynamicStructTraits<ze_module_constants_t>));

                                    for(int32_t m = 0; m < descPNextPConstantsTraits[l].count; ++m){
                                        do {
                                            if(nestedChildTraits[m].pConstantIdsOffset == -1){
                                                forcePointerWrite(extension.pConstants[l][m].pConstantIds, nullptr);
                                                continue;
                                            }

                                            forcePointerWrite(extension.pConstants[l][m].pConstantIds, dynMem + nestedChildTraits[m].pConstantIdsOffset);
                                            currentOffset += alignUpPow2<8>(nestedChildTraits[m].pConstantIdsCount * sizeof(uint32_t));
                                        } while (0);
                                        do {
                                            if(nestedChildTraits[m].pConstantValuesOffset == -1){
                                                forcePointerWrite(extension.pConstants[l][m].pConstantValues, nullptr);
                                                continue;
                                            }

                                            forcePointerWrite(extension.pConstants[l][m].pConstantValues, dynMem + nestedChildTraits[m].pConstantValuesOffset);
                                            currentOffset += alignUpPow2<8>(nestedChildTraits[m].pConstantValuesCount * sizeof(const void *));

                                            auto* descPNextPConstantsPConstantValuesTraits = reinterpret_cast<DynamicStructTraits<const void *>*>(dynMem + currentOffset);
                                            currentOffset += alignUpPow2<8>(nestedChildTraits[m].pConstantValuesCount * sizeof(DynamicStructTraits<const void *>));

                                            for(int32_t n = 0; n < nestedChildTraits[m].pConstantValuesCount; ++n){
                                                if(descPNextPConstantsPConstantValuesTraits[n].offset == -1){
                                                    forcePointerWrite(extension.pConstants[l][m].pConstantValues[n], nullptr);
                                                    continue;
                                                }

                                                forcePointerWrite(extension.pConstants[l][m].pConstantValues[n], dynMem + descPNextPConstantsPConstantValuesTraits[n].offset);
                                                currentOffset += alignUpPow2<8>(descPNextPConstantsPConstantValuesTraits[n].count * sizeof(uint64_t));
                                            }

                                        } while (0);
                                    }
                                }

                            }
                        }
                        if (j < descTraits[i].pNextCount) {
                            const auto pNextElement = getNext(descPNextListElement);
                            const auto sizeInBytes = getUnderlyingSize(pNextElement);
                            currentOffset += alignUpPow2<8>(sizeInBytes);

                            descPNextListElement = pNextElement;
                        }

                    }

                }

                for (uint32_t i = 0; i < descNestedTraitsCount; ++i) {
                    if(descTraits[i].pInputModuleOffset == -1){
                        forcePointerWrite(destDesc[i].pInputModule, nullptr);
                        continue;
                    }

                    forcePointerWrite(destDesc[i].pInputModule, dynMem + descTraits[i].pInputModuleOffset);
                    currentOffset += alignUpPow2<8>(descTraits[i].pInputModuleCount * sizeof(uint8_t));
                }

                for (uint32_t i = 0; i < descNestedTraitsCount; ++i) {
                    if(descTraits[i].pBuildFlagsOffset == -1){
                        forcePointerWrite(destDesc[i].pBuildFlags, nullptr);
                        continue;
                    }

                    forcePointerWrite(destDesc[i].pBuildFlags, dynMem + descTraits[i].pBuildFlagsOffset);
                    currentOffset += alignUpPow2<8>(descTraits[i].pBuildFlagsCount * sizeof(char));
                }

                for (uint32_t i = 0; i < descNestedTraitsCount; ++i) {
                    if(descTraits[i].pConstantsOffset == -1){
                        forcePointerWrite(destDesc[i].pConstants, nullptr);
                        continue;
                    }

                    forcePointerWrite(destDesc[i].pConstants, dynMem + descTraits[i].pConstantsOffset);
                    currentOffset += alignUpPow2<8>(descTraits[i].pConstantsCount * sizeof(ze_module_constants_t));

                    auto* descPConstantsTraits = reinterpret_cast<DynamicStructTraits<ze_module_constants_t>*>(dynMem + currentOffset);
                    currentOffset += alignUpPow2<8>(descTraits[i].pConstantsCount * sizeof(DynamicStructTraits<ze_module_constants_t>));

                    for(int32_t j = 0; j < descTraits[i].pConstantsCount; ++j){
                        if(descPConstantsTraits[j].pConstantIdsOffset == -1){
                            forcePointerWrite(destDesc[i].pConstants[j].pConstantIds, nullptr);
                            continue;
                        }

                        forcePointerWrite(destDesc[i].pConstants[j].pConstantIds, dynMem + descPConstantsTraits[j].pConstantIdsOffset);
                        currentOffset += alignUpPow2<8>(descPConstantsTraits[j].pConstantIdsCount * sizeof(uint32_t));
                    }

                    for(int32_t j = 0; j < descTraits[i].pConstantsCount; ++j){
                        if(descPConstantsTraits[j].pConstantValuesOffset == -1){
                            forcePointerWrite(destDesc[i].pConstants[j].pConstantValues, nullptr);
                            continue;
                        }

                        forcePointerWrite(destDesc[i].pConstants[j].pConstantValues, dynMem + descPConstantsTraits[j].pConstantValuesOffset);
                        currentOffset += alignUpPow2<8>(descPConstantsTraits[j].pConstantValuesCount * sizeof(const void *));

                        auto* descPConstantsPConstantValuesTraits = reinterpret_cast<DynamicStructTraits<const void *>*>(dynMem + currentOffset);
                        currentOffset += alignUpPow2<8>(descPConstantsTraits[j].pConstantValuesCount * sizeof(DynamicStructTraits<const void *>));

                        for(int32_t k = 0; k < descPConstantsTraits[j].pConstantValuesCount; ++k){
                            if(descPConstantsPConstantValuesTraits[k].offset == -1){
                                forcePointerWrite(destDesc[i].pConstants[j].pConstantValues[k], nullptr);
                                continue;
                            }

                            forcePointerWrite(destDesc[i].pConstants[j].pConstantValues[k], dynMem + descPConstantsPConstantValuesTraits[k].offset);
                            currentOffset += alignUpPow2<8>(descPConstantsPConstantValuesTraits[k].count * sizeof(uint64_t));
                        }

                    }

                }
        }
    }

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeModuleCreateRpcM() = default;

    ZeModuleCreateRpcM(const Captures::DynamicTraits &dynamicTraits, ze_context_handle_t hContext, ze_device_handle_t hDevice, const ze_module_desc_t* desc, ze_module_handle_t* phModule, ze_module_build_log_handle_t* phBuildLog) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hContext = hContext;
        args.hDevice = hDevice;
        args.desc = desc;
        args.phModule = phModule;
        args.phBuildLog = phBuildLog;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeModuleCreateRpcM &message, ze_context_handle_t hContext, ze_device_handle_t hDevice, const ze_module_desc_t* desc, ze_module_handle_t* phModule, ze_module_build_log_handle_t* phBuildLog) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hContext = hContext;
        message.args.hDevice = hDevice;
        message.args.desc = desc;
        message.args.phModule = phModule;
        message.args.phBuildLog = phBuildLog;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.desc){
            captures.desc = *args.desc;
        }
        if(args.phModule){
            captures.phModule = *args.phModule;
        }
        using Cal::Utils::alignUpPow2;

        auto& dynMem = captures.dynMem;
        uint32_t currentOffset = captures.dynamicStructMembersOffset;
        if(args.desc){
            assert(currentOffset == captures.descNestedTraitsOffset);
            auto* descTraits = reinterpret_cast<DynamicStructTraits<ze_module_desc_t>*>(dynMem + currentOffset);
            currentOffset += alignUpPow2<8>(captures.descNestedTraitsCount * sizeof(DynamicStructTraits<ze_module_desc_t>));

            for (uint32_t i = 0; i < captures.descNestedTraitsCount; ++i) {
                const auto& descPNext = args.desc[i].pNext;
                if(!descPNext){
                    descTraits[i].pNextOffset = -1;
                    descTraits[i].pNextCount = -1;
                    continue;
                }

                const auto descPNextCount = static_cast<int32_t>(countOpaqueList(static_cast<const ze_base_desc_t*>(args.desc[i].pNext)));
                if(!descPNextCount){
                    descTraits[i].pNextOffset = -1;
                    descTraits[i].pNextCount = -1;
                    continue;
                }

                descTraits[i].pNextOffset = currentOffset;
                descTraits[i].pNextCount = descPNextCount;
                descTraits[i].pNextFirstOriginalElement = args.desc[i].pNext;

                auto descPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(descPNextCount * sizeof(NestedPNextTraits));

                auto descPNextListElement = static_cast<const ze_base_desc_t*>(args.desc[i].pNext);
                for(int32_t j = 0; j < descPNextCount; ++j){
                    descPNextListElementTraits[j].extensionType = getExtensionType(descPNextListElement);
                    descPNextListElementTraits[j].extensionOffset = currentOffset;

                    const auto sizeInBytes = getUnderlyingSize(descPNextListElement);
                    std::memcpy(dynMem + currentOffset, descPNextListElement, sizeInBytes);
                    currentOffset += alignUpPow2<8>(sizeInBytes);


                    const auto extensionType = static_cast<int>(getExtensionType(descPNextListElement));
                    if (extensionType == ZE_STRUCTURE_TYPE_MODULE_PROGRAM_EXP_DESC) {
                        auto& extension = *reinterpret_cast<const ze_module_program_exp_desc_t*>(descPNextListElement);
                        auto* extensionTraits = reinterpret_cast<DynamicStructTraits<ze_module_program_exp_desc_t>*>(dynMem + currentOffset);
                        currentOffset += alignUpPow2<8>(sizeof(DynamicStructTraits<ze_module_program_exp_desc_t>));

                        for(int32_t k = 0; k < 1; ++k) {
                            const auto& descPNextInputSizes = extension.inputSizes;
                            if(!descPNextInputSizes){
                                extensionTraits[k].inputSizesOffset = -1;
                                extensionTraits[k].inputSizesCount = -1;
                                continue;
                            }

                            const auto descPNextInputSizesCount = static_cast<int32_t>(extension.count);
                            if(!descPNextInputSizesCount){
                                extensionTraits[k].inputSizesOffset = -1;
                                extensionTraits[k].inputSizesCount = -1;
                                continue;
                            }

                            extensionTraits[k].inputSizesOffset = currentOffset;
                            extensionTraits[k].inputSizesCount = descPNextInputSizesCount;

                            std::memcpy(dynMem + currentOffset, descPNextInputSizes, descPNextInputSizesCount * sizeof(size_t));
                            currentOffset += alignUpPow2<8>(descPNextInputSizesCount * sizeof(size_t));
                        }

                        for(int32_t k = 0; k < 1; ++k) {
                            const auto& descPNextPInputModules = extension.pInputModules;
                            if(!descPNextPInputModules){
                                extensionTraits[k].pInputModulesOffset = -1;
                                extensionTraits[k].pInputModulesCount = -1;
                                continue;
                            }

                            const auto descPNextPInputModulesCount = static_cast<int32_t>(extension.count);
                            if(!descPNextPInputModulesCount){
                                extensionTraits[k].pInputModulesOffset = -1;
                                extensionTraits[k].pInputModulesCount = -1;
                                continue;
                            }

                            extensionTraits[k].pInputModulesOffset = currentOffset;
                            extensionTraits[k].pInputModulesCount = descPNextPInputModulesCount;

                            std::memcpy(dynMem + currentOffset, descPNextPInputModules, descPNextPInputModulesCount * sizeof(const uint8_t*));
                            currentOffset += alignUpPow2<8>(descPNextPInputModulesCount * sizeof(const uint8_t*));

                            auto* descPNextPInputModulesTraits = reinterpret_cast<DynamicStructTraits<const uint8_t*>*>(dynMem + currentOffset);
                            currentOffset += alignUpPow2<8>(descPNextPInputModulesCount * sizeof(DynamicStructTraits<const uint8_t*>));

                            for(int32_t l = 0; l < descPNextPInputModulesCount; ++l){
                                const auto& descPNextPInputModules_l = descPNextPInputModules[l];
                                if(!descPNextPInputModules_l){
                                    descPNextPInputModulesTraits[l].offset = -1;
                                    descPNextPInputModulesTraits[l].count = -1;
                                    continue;
                                }

                                const auto& descPNextPInputModules_lCount = extension.inputSizes[l];
                                if(!descPNextPInputModules_lCount){
                                    descPNextPInputModulesTraits[l].offset = -1;
                                    descPNextPInputModulesTraits[l].count = -1;
                                    continue;
                                }

                                descPNextPInputModulesTraits[l].offset = currentOffset;
                                descPNextPInputModulesTraits[l].count = descPNextPInputModules_lCount;

                                std::memcpy(dynMem + currentOffset, descPNextPInputModules_l, descPNextPInputModules_lCount * sizeof(uint8_t));
                                currentOffset += alignUpPow2<8>(descPNextPInputModules_lCount * sizeof(uint8_t));
                            }

                        }

                        for(int32_t k = 0; k < 1; ++k) {
                            const auto& descPNextPBuildFlags = extension.pBuildFlags;
                            if(!descPNextPBuildFlags){
                                extensionTraits[k].pBuildFlagsOffset = -1;
                                extensionTraits[k].pBuildFlagsCount = -1;
                                continue;
                            }

                            const auto descPNextPBuildFlagsCount = static_cast<int32_t>(extension.count);
                            if(!descPNextPBuildFlagsCount){
                                extensionTraits[k].pBuildFlagsOffset = -1;
                                extensionTraits[k].pBuildFlagsCount = -1;
                                continue;
                            }

                            extensionTraits[k].pBuildFlagsOffset = currentOffset;
                            extensionTraits[k].pBuildFlagsCount = descPNextPBuildFlagsCount;

                            std::memcpy(dynMem + currentOffset, descPNextPBuildFlags, descPNextPBuildFlagsCount * sizeof(const char*));
                            currentOffset += alignUpPow2<8>(descPNextPBuildFlagsCount * sizeof(const char*));

                            auto* descPNextPBuildFlagsTraits = reinterpret_cast<DynamicStructTraits<const char*>*>(dynMem + currentOffset);
                            currentOffset += alignUpPow2<8>(descPNextPBuildFlagsCount * sizeof(DynamicStructTraits<const char*>));

                            for(int32_t l = 0; l < descPNextPBuildFlagsCount; ++l){
                                const auto& descPNextPBuildFlags_l = descPNextPBuildFlags[l];
                                if(!descPNextPBuildFlags_l){
                                    descPNextPBuildFlagsTraits[l].offset = -1;
                                    descPNextPBuildFlagsTraits[l].count = -1;
                                    continue;
                                }

                                const auto& descPNextPBuildFlags_lCount = Cal::Utils::countNullterminated(descPNextPBuildFlags[l]);
                                if(!descPNextPBuildFlags_lCount){
                                    descPNextPBuildFlagsTraits[l].offset = -1;
                                    descPNextPBuildFlagsTraits[l].count = -1;
                                    continue;
                                }

                                descPNextPBuildFlagsTraits[l].offset = currentOffset;
                                descPNextPBuildFlagsTraits[l].count = descPNextPBuildFlags_lCount;

                                std::memcpy(dynMem + currentOffset, descPNextPBuildFlags_l, descPNextPBuildFlags_lCount * sizeof(char));
                                currentOffset += alignUpPow2<8>(descPNextPBuildFlags_lCount * sizeof(char));
                            }

                        }

                        for(int32_t k = 0; k < 1; ++k) {
                            const auto& descPNextPConstants = extension.pConstants;
                            if(!descPNextPConstants){
                                extensionTraits[k].pConstantsOffset = -1;
                                extensionTraits[k].pConstantsCount = -1;
                                continue;
                            }

                            const auto descPNextPConstantsCount = static_cast<int32_t>(extension.count);
                            if(!descPNextPConstantsCount){
                                extensionTraits[k].pConstantsOffset = -1;
                                extensionTraits[k].pConstantsCount = -1;
                                continue;
                            }

                            extensionTraits[k].pConstantsOffset = currentOffset;
                            extensionTraits[k].pConstantsCount = descPNextPConstantsCount;

                            std::memcpy(dynMem + currentOffset, descPNextPConstants, descPNextPConstantsCount * sizeof(const ze_module_constants_t*));
                            currentOffset += alignUpPow2<8>(descPNextPConstantsCount * sizeof(const ze_module_constants_t*));

                            auto* descPNextPConstantsTraits = reinterpret_cast<DynamicStructTraits<const ze_module_constants_t*>*>(dynMem + currentOffset);
                            currentOffset += alignUpPow2<8>(descPNextPConstantsCount * sizeof(DynamicStructTraits<const ze_module_constants_t*>));

                            for(int32_t l = 0; l < descPNextPConstantsCount; ++l){
                                const auto& descPNextPConstants_l = descPNextPConstants[l];
                                if(!descPNextPConstants_l){
                                    descPNextPConstantsTraits[l].offset = -1;
                                    descPNextPConstantsTraits[l].count = -1;
                                    continue;
                                }

                                const auto& descPNextPConstants_lCount = 1;
                                if(!descPNextPConstants_lCount){
                                    descPNextPConstantsTraits[l].offset = -1;
                                    descPNextPConstantsTraits[l].count = -1;
                                    continue;
                                }

                                descPNextPConstantsTraits[l].offset = currentOffset;
                                descPNextPConstantsTraits[l].count = descPNextPConstants_lCount;

                                std::memcpy(dynMem + currentOffset, descPNextPConstants_l, descPNextPConstants_lCount * sizeof(ze_module_constants_t));
                                currentOffset += alignUpPow2<8>(descPNextPConstants_lCount * sizeof(ze_module_constants_t));

                                auto* nestedChildTraits = reinterpret_cast<DynamicStructTraits<ze_module_constants_t>*>(dynMem + currentOffset);
                                currentOffset += alignUpPow2<8>(descPNextPConstants_lCount * sizeof(DynamicStructTraits<ze_module_constants_t>));


                                for(int32_t m = 0; m < 1; ++m){
                                    do {
                                        const auto& descPNextPConstantsPConstantIds = extension.pConstants[l][m].pConstantIds;
                                        if(!descPNextPConstantsPConstantIds){
                                            nestedChildTraits[m].pConstantIdsOffset = -1;
                                            nestedChildTraits[m].pConstantIdsCount = -1;
                                            continue;
                                        }

                                        const auto descPNextPConstantsPConstantIdsCount = static_cast<int32_t>(extension.pConstants[l][m].numConstants);
                                        if(!descPNextPConstantsPConstantIdsCount){
                                            nestedChildTraits[m].pConstantIdsOffset = -1;
                                            nestedChildTraits[m].pConstantIdsCount = -1;
                                            continue;
                                        }

                                        nestedChildTraits[m].pConstantIdsOffset = currentOffset;
                                        nestedChildTraits[m].pConstantIdsCount = descPNextPConstantsPConstantIdsCount;

                                        std::memcpy(dynMem + currentOffset, descPNextPConstantsPConstantIds, descPNextPConstantsPConstantIdsCount * sizeof(uint32_t));
                                        currentOffset += alignUpPow2<8>(descPNextPConstantsPConstantIdsCount * sizeof(uint32_t));
                                    } while (0);
                                    do {
                                        const auto& descPNextPConstantsPConstantValues = extension.pConstants[l][m].pConstantValues;
                                        if(!descPNextPConstantsPConstantValues){
                                            nestedChildTraits[m].pConstantValuesOffset = -1;
                                            nestedChildTraits[m].pConstantValuesCount = -1;
                                            continue;
                                        }

                                        const auto descPNextPConstantsPConstantValuesCount = static_cast<int32_t>(extension.pConstants[l][m].numConstants);
                                        if(!descPNextPConstantsPConstantValuesCount){
                                            nestedChildTraits[m].pConstantValuesOffset = -1;
                                            nestedChildTraits[m].pConstantValuesCount = -1;
                                            continue;
                                        }

                                        nestedChildTraits[m].pConstantValuesOffset = currentOffset;
                                        nestedChildTraits[m].pConstantValuesCount = descPNextPConstantsPConstantValuesCount;

                                        std::memcpy(dynMem + currentOffset, descPNextPConstantsPConstantValues, descPNextPConstantsPConstantValuesCount * sizeof(const void *));
                                        currentOffset += alignUpPow2<8>(descPNextPConstantsPConstantValuesCount * sizeof(const void *));

                                        auto* descPNextPConstantsPConstantValuesTraits = reinterpret_cast<DynamicStructTraits<const void *>*>(dynMem + currentOffset);
                                        currentOffset += alignUpPow2<8>(descPNextPConstantsPConstantValuesCount * sizeof(DynamicStructTraits<const void *>));

                                        for(int32_t n = 0; n < descPNextPConstantsPConstantValuesCount; ++n){
                                            const auto& descPNextPConstantsPConstantValues_n = descPNextPConstantsPConstantValues[n];
                                            if(!descPNextPConstantsPConstantValues_n){
                                                descPNextPConstantsPConstantValuesTraits[n].offset = -1;
                                                descPNextPConstantsPConstantValuesTraits[n].count = -1;
                                                continue;
                                            }

                                            const auto& descPNextPConstantsPConstantValues_nCount = 1;
                                            if(!descPNextPConstantsPConstantValues_nCount){
                                                descPNextPConstantsPConstantValuesTraits[n].offset = -1;
                                                descPNextPConstantsPConstantValuesTraits[n].count = -1;
                                                continue;
                                            }

                                            descPNextPConstantsPConstantValuesTraits[n].offset = currentOffset;
                                            descPNextPConstantsPConstantValuesTraits[n].count = descPNextPConstantsPConstantValues_nCount;

                                            std::memcpy(dynMem + currentOffset, descPNextPConstantsPConstantValues_n, descPNextPConstantsPConstantValues_nCount * sizeof(uint64_t));
                                            currentOffset += alignUpPow2<8>(descPNextPConstantsPConstantValues_nCount * sizeof(uint64_t));
                                        }

                                    } while (0);
                                }
                            }

                        }
                    }
                    descPNextListElement = getNext(descPNextListElement);
                }

            }

            for (uint32_t i = 0; i < captures.descNestedTraitsCount; ++i) {
                const auto& descPInputModule = args.desc[i].pInputModule;
                if(!descPInputModule){
                    descTraits[i].pInputModuleOffset = -1;
                    descTraits[i].pInputModuleCount = -1;
                    continue;
                }

                const auto descPInputModuleCount = static_cast<int32_t>(args.desc[i].inputSize);
                if(!descPInputModuleCount){
                    descTraits[i].pInputModuleOffset = -1;
                    descTraits[i].pInputModuleCount = -1;
                    continue;
                }

                descTraits[i].pInputModuleOffset = currentOffset;
                descTraits[i].pInputModuleCount = descPInputModuleCount;

                std::memcpy(dynMem + currentOffset, descPInputModule, descPInputModuleCount * sizeof(uint8_t));
                currentOffset += alignUpPow2<8>(descPInputModuleCount * sizeof(uint8_t));
            }

            for (uint32_t i = 0; i < captures.descNestedTraitsCount; ++i) {
                const auto& descPBuildFlags = args.desc[i].pBuildFlags;
                if(!descPBuildFlags){
                    descTraits[i].pBuildFlagsOffset = -1;
                    descTraits[i].pBuildFlagsCount = -1;
                    continue;
                }

                const auto descPBuildFlagsCount = static_cast<int32_t>(Cal::Utils::countNullterminated(args.desc[i].pBuildFlags));
                if(!descPBuildFlagsCount){
                    descTraits[i].pBuildFlagsOffset = -1;
                    descTraits[i].pBuildFlagsCount = -1;
                    continue;
                }

                descTraits[i].pBuildFlagsOffset = currentOffset;
                descTraits[i].pBuildFlagsCount = descPBuildFlagsCount;

                std::memcpy(dynMem + currentOffset, descPBuildFlags, descPBuildFlagsCount * sizeof(char));
                currentOffset += alignUpPow2<8>(descPBuildFlagsCount * sizeof(char));
            }

            for (uint32_t i = 0; i < captures.descNestedTraitsCount; ++i) {
                const auto& descPConstants = args.desc[i].pConstants;
                if(!descPConstants){
                    descTraits[i].pConstantsOffset = -1;
                    descTraits[i].pConstantsCount = -1;
                    continue;
                }

                const auto descPConstantsCount = static_cast<int32_t>(1);
                if(!descPConstantsCount){
                    descTraits[i].pConstantsOffset = -1;
                    descTraits[i].pConstantsCount = -1;
                    continue;
                }

                descTraits[i].pConstantsOffset = currentOffset;
                descTraits[i].pConstantsCount = descPConstantsCount;

                std::memcpy(dynMem + currentOffset, descPConstants, descPConstantsCount * sizeof(ze_module_constants_t));
                currentOffset += alignUpPow2<8>(descPConstantsCount * sizeof(ze_module_constants_t));

                auto* descPConstantsTraits = reinterpret_cast<DynamicStructTraits<ze_module_constants_t>*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(descPConstantsCount * sizeof(DynamicStructTraits<ze_module_constants_t>));

                for(int32_t j = 0; j < descPConstantsCount; ++j){
                    const auto& descPConstantsPConstantIds = args.desc[i].pConstants[j].pConstantIds;
                    if(!descPConstantsPConstantIds){
                        descPConstantsTraits[j].pConstantIdsOffset = -1;
                        descPConstantsTraits[j].pConstantIdsCount = -1;
                        continue;
                    }

                    const auto descPConstantsPConstantIdsCount = static_cast<int32_t>(args.desc[i].pConstants[j].numConstants);
                    if(!descPConstantsPConstantIdsCount){
                        descPConstantsTraits[j].pConstantIdsOffset = -1;
                        descPConstantsTraits[j].pConstantIdsCount = -1;
                        continue;
                    }

                    descPConstantsTraits[j].pConstantIdsOffset = currentOffset;
                    descPConstantsTraits[j].pConstantIdsCount = descPConstantsPConstantIdsCount;

                    std::memcpy(dynMem + currentOffset, descPConstantsPConstantIds, descPConstantsPConstantIdsCount * sizeof(uint32_t));
                    currentOffset += alignUpPow2<8>(descPConstantsPConstantIdsCount * sizeof(uint32_t));
                }

                for(int32_t j = 0; j < descPConstantsCount; ++j){
                    const auto& descPConstantsPConstantValues = args.desc[i].pConstants[j].pConstantValues;
                    if(!descPConstantsPConstantValues){
                        descPConstantsTraits[j].pConstantValuesOffset = -1;
                        descPConstantsTraits[j].pConstantValuesCount = -1;
                        continue;
                    }

                    const auto descPConstantsPConstantValuesCount = static_cast<int32_t>(args.desc[i].pConstants[j].numConstants);
                    if(!descPConstantsPConstantValuesCount){
                        descPConstantsTraits[j].pConstantValuesOffset = -1;
                        descPConstantsTraits[j].pConstantValuesCount = -1;
                        continue;
                    }

                    descPConstantsTraits[j].pConstantValuesOffset = currentOffset;
                    descPConstantsTraits[j].pConstantValuesCount = descPConstantsPConstantValuesCount;

                    std::memcpy(dynMem + currentOffset, descPConstantsPConstantValues, descPConstantsPConstantValuesCount * sizeof(const void *));
                    currentOffset += alignUpPow2<8>(descPConstantsPConstantValuesCount * sizeof(const void *));

                    auto* descPConstantsPConstantValuesTraits = reinterpret_cast<DynamicStructTraits<const void *>*>(dynMem + currentOffset);
                    currentOffset += alignUpPow2<8>(descPConstantsPConstantValuesCount * sizeof(DynamicStructTraits<const void *>));

                    for(int32_t k = 0; k < descPConstantsPConstantValuesCount; ++k){
                        const auto& descPConstantsPConstantValues_k = descPConstantsPConstantValues[k];
                        if(!descPConstantsPConstantValues_k){
                            descPConstantsPConstantValuesTraits[k].offset = -1;
                            descPConstantsPConstantValuesTraits[k].count = -1;
                            continue;
                        }

                        const auto& descPConstantsPConstantValues_kCount = 1;
                        if(!descPConstantsPConstantValues_kCount){
                            descPConstantsPConstantValuesTraits[k].offset = -1;
                            descPConstantsPConstantValuesTraits[k].count = -1;
                            continue;
                        }

                        descPConstantsPConstantValuesTraits[k].offset = currentOffset;
                        descPConstantsPConstantValuesTraits[k].count = descPConstantsPConstantValues_kCount;

                        std::memcpy(dynMem + currentOffset, descPConstantsPConstantValues_k, descPConstantsPConstantValues_kCount * sizeof(uint64_t));
                        currentOffset += alignUpPow2<8>(descPConstantsPConstantValues_kCount * sizeof(uint64_t));
                    }

                }

            }
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phModule){
            *args.phModule = captures.phModule;
        }
        if(args.phBuildLog){
            *args.phBuildLog = captures.phBuildLog;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeModuleCreateRpcM>);
struct ZeModuleDestroyRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 165;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_module_handle_t hModule = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hModule == rhs.hModule;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeModuleDestroyRpcM() = default;

    ZeModuleDestroyRpcM(ze_module_handle_t hModule) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hModule = hModule;
    }
    
    static void fillWithoutCapture(ZeModuleDestroyRpcM &message, ze_module_handle_t hModule) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hModule = hModule;
    }
    
};
static_assert(std::is_standard_layout_v<ZeModuleDestroyRpcM>);
struct ZeModuleDynamicLinkRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 166;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        uint32_t numModules = {};
        ze_module_handle_t* phModules = {};
        ze_module_build_log_handle_t* phLinkLog = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->numModules == rhs.numModules;
            equal &= this->phModules == rhs.phModules;
            equal &= this->phLinkLog == rhs.phLinkLog;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(uint32_t numModules, ze_module_handle_t* phModules, ze_module_build_log_handle_t* phLinkLog);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phModules = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_module_build_log_handle_t phLinkLog;
        uint32_t countPhModules = 0;
        ze_module_handle_t phModules[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhModules = dynamicTraits.phModules.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeModuleDynamicLinkRpcM() = default;

    ZeModuleDynamicLinkRpcM(const Captures::DynamicTraits &dynamicTraits, uint32_t numModules, ze_module_handle_t* phModules, ze_module_build_log_handle_t* phLinkLog) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.numModules = numModules;
        args.phModules = phModules;
        args.phLinkLog = phLinkLog;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeModuleDynamicLinkRpcM &message, uint32_t numModules, ze_module_handle_t* phModules, ze_module_build_log_handle_t* phLinkLog) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.numModules = numModules;
        message.args.phModules = phModules;
        message.args.phLinkLog = phLinkLog;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phModules){
            memcpy(asMemcpyDstT(captures.phModules), args.phModules, dynMemTraits.phModules.size);
        }
        if(args.phLinkLog){
            captures.phLinkLog = *args.phLinkLog;
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phLinkLog){
            *args.phLinkLog = captures.phLinkLog;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeModuleDynamicLinkRpcM>);
struct ZeModuleBuildLogDestroyRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 167;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_module_build_log_handle_t hModuleBuildLog = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hModuleBuildLog == rhs.hModuleBuildLog;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeModuleBuildLogDestroyRpcM() = default;

    ZeModuleBuildLogDestroyRpcM(ze_module_build_log_handle_t hModuleBuildLog) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hModuleBuildLog = hModuleBuildLog;
    }
    
    static void fillWithoutCapture(ZeModuleBuildLogDestroyRpcM &message, ze_module_build_log_handle_t hModuleBuildLog) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hModuleBuildLog = hModuleBuildLog;
    }
    
};
static_assert(std::is_standard_layout_v<ZeModuleBuildLogDestroyRpcM>);
struct ZeModuleBuildLogGetStringRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 168;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_module_build_log_handle_t hModuleBuildLog = {};
        size_t* pSize = {};
        char* pBuildLog = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hModuleBuildLog == rhs.hModuleBuildLog;
            equal &= this->pSize == rhs.pSize;
            equal &= this->pBuildLog == rhs.pBuildLog;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_module_build_log_handle_t hModuleBuildLog, size_t* pSize, char* pBuildLog);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits pBuildLog = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        size_t pSize;
        uint32_t countPBuildLog = 0;
        char pBuildLog[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPBuildLog = dynamicTraits.pBuildLog.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeModuleBuildLogGetStringRpcM() = default;

    ZeModuleBuildLogGetStringRpcM(const Captures::DynamicTraits &dynamicTraits, ze_module_build_log_handle_t hModuleBuildLog, size_t* pSize, char* pBuildLog) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hModuleBuildLog = hModuleBuildLog;
        args.pSize = pSize;
        args.pBuildLog = pBuildLog;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeModuleBuildLogGetStringRpcM &message, ze_module_build_log_handle_t hModuleBuildLog, size_t* pSize, char* pBuildLog) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hModuleBuildLog = hModuleBuildLog;
        message.args.pSize = pSize;
        message.args.pBuildLog = pBuildLog;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pSize){
            captures.pSize = *args.pSize;
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pSize){
            *args.pSize = captures.pSize;
        }
        if(args.pBuildLog){
            memcpy(args.pBuildLog, captures.pBuildLog, dynMemTraits.pBuildLog.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeModuleBuildLogGetStringRpcM>);
struct ZeModuleGetNativeBinaryRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 169;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_module_handle_t hModule = {};
        size_t* pSize = {};
        uint8_t* pModuleNativeBinary = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hModule == rhs.hModule;
            equal &= this->pSize == rhs.pSize;
            equal &= this->pModuleNativeBinary == rhs.pModuleNativeBinary;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_module_handle_t hModule, size_t* pSize, uint8_t* pModuleNativeBinary);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits pModuleNativeBinary = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        size_t pSize;
        uint32_t countPModuleNativeBinary = 0;
        uint8_t pModuleNativeBinary[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPModuleNativeBinary = dynamicTraits.pModuleNativeBinary.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeModuleGetNativeBinaryRpcM() = default;

    ZeModuleGetNativeBinaryRpcM(const Captures::DynamicTraits &dynamicTraits, ze_module_handle_t hModule, size_t* pSize, uint8_t* pModuleNativeBinary) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hModule = hModule;
        args.pSize = pSize;
        args.pModuleNativeBinary = pModuleNativeBinary;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeModuleGetNativeBinaryRpcM &message, ze_module_handle_t hModule, size_t* pSize, uint8_t* pModuleNativeBinary) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hModule = hModule;
        message.args.pSize = pSize;
        message.args.pModuleNativeBinary = pModuleNativeBinary;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pSize){
            captures.pSize = *args.pSize;
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pSize){
            *args.pSize = captures.pSize;
        }
        if(args.pModuleNativeBinary){
            memcpy(args.pModuleNativeBinary, captures.pModuleNativeBinary, dynMemTraits.pModuleNativeBinary.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeModuleGetNativeBinaryRpcM>);
struct ZeModuleGetGlobalPointerRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 170;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_module_handle_t hModule = {};
        const char* pGlobalName = {};
        size_t* pSize = {};
        void** pptr = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hModule == rhs.hModule;
            equal &= this->pGlobalName == rhs.pGlobalName;
            equal &= this->pSize == rhs.pSize;
            equal &= this->pptr == rhs.pptr;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_module_handle_t hModule, const char* pGlobalName, size_t* pSize, void** pptr);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits pGlobalName = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        size_t pSize;
        void* pptr;
        uint32_t countPGlobalName = 0;
        char pGlobalName[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPGlobalName = dynamicTraits.pGlobalName.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeModuleGetGlobalPointerRpcM() = default;

    ZeModuleGetGlobalPointerRpcM(const Captures::DynamicTraits &dynamicTraits, ze_module_handle_t hModule, const char* pGlobalName, size_t* pSize, void** pptr) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hModule = hModule;
        args.pGlobalName = pGlobalName;
        args.pSize = pSize;
        args.pptr = pptr;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeModuleGetGlobalPointerRpcM &message, ze_module_handle_t hModule, const char* pGlobalName, size_t* pSize, void** pptr) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hModule = hModule;
        message.args.pGlobalName = pGlobalName;
        message.args.pSize = pSize;
        message.args.pptr = pptr;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pGlobalName){
            memcpy(asMemcpyDstT(captures.pGlobalName), args.pGlobalName, dynMemTraits.pGlobalName.size);
        }
        if(args.pSize){
            captures.pSize = *args.pSize;
        }
        if(args.pptr){
            captures.pptr = *args.pptr;
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pSize){
            *args.pSize = captures.pSize;
        }
        if(args.pptr){
            *args.pptr = captures.pptr;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeModuleGetGlobalPointerRpcM>);
 // zeModuleGetKernelNames ignored in generator - based on dont_generate_rpc_message flag
struct ZeModuleGetKernelNamesRpcHelperRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 171;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_module_handle_t hModule = {};
        uint32_t* totalLength = {};
        char* namesBuffer = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hModule == rhs.hModule;
            equal &= this->totalLength == rhs.totalLength;
            equal &= this->namesBuffer == rhs.namesBuffer;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_module_handle_t hModule, uint32_t* totalLength, char* namesBuffer);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits namesBuffer = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t totalLength;
        uint32_t countNamesBuffer = 0;
        char namesBuffer[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countNamesBuffer = dynamicTraits.namesBuffer.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeModuleGetKernelNamesRpcHelperRpcM() = default;

    ZeModuleGetKernelNamesRpcHelperRpcM(const Captures::DynamicTraits &dynamicTraits, ze_module_handle_t hModule, uint32_t* totalLength, char* namesBuffer) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hModule = hModule;
        args.totalLength = totalLength;
        args.namesBuffer = namesBuffer;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeModuleGetKernelNamesRpcHelperRpcM &message, ze_module_handle_t hModule, uint32_t* totalLength, char* namesBuffer) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hModule = hModule;
        message.args.totalLength = totalLength;
        message.args.namesBuffer = namesBuffer;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.totalLength){
            captures.totalLength = *args.totalLength;
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.totalLength){
            *args.totalLength = captures.totalLength;
        }
        if(args.namesBuffer){
            memcpy(args.namesBuffer, captures.namesBuffer, dynMemTraits.namesBuffer.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeModuleGetKernelNamesRpcHelperRpcM>);
struct ZeModuleGetPropertiesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 172;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_module_handle_t hModule = {};
        ze_module_properties_t* pModuleProperties = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hModule == rhs.hModule;
            equal &= this->pModuleProperties == rhs.pModuleProperties;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_module_properties_t pModuleProperties;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeModuleGetPropertiesRpcM() = default;

    ZeModuleGetPropertiesRpcM(ze_module_handle_t hModule, ze_module_properties_t* pModuleProperties) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hModule = hModule;
        args.pModuleProperties = pModuleProperties;
    }
    
    static void fillWithoutCapture(ZeModuleGetPropertiesRpcM &message, ze_module_handle_t hModule, ze_module_properties_t* pModuleProperties) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hModule = hModule;
        message.args.pModuleProperties = pModuleProperties;
    }
    

    void copyFromCaller(){
        if(args.pModuleProperties){
            captures.pModuleProperties = *args.pModuleProperties;
        }
    }

    void copyToCaller(){
        if(args.pModuleProperties){
            *args.pModuleProperties = captures.pModuleProperties;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeModuleGetPropertiesRpcM>);
struct ZeKernelCreateRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 173;
    static constexpr float latency = 0.5;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_module_handle_t hModule = {};
        const ze_kernel_desc_t* desc = {};
        ze_kernel_handle_t* phKernel = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hModule == rhs.hModule;
            equal &= this->desc == rhs.desc;
            equal &= this->phKernel == rhs.phKernel;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_module_handle_t hModule, const ze_kernel_desc_t* desc, ze_kernel_handle_t* phKernel);
            uint32_t totalDynamicSize = 0;
            uint32_t dynamicStructMembersOffset = 0;
            DynamicArgTraits descNestedTraits = {};
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_kernel_desc_t desc;
        ze_kernel_handle_t phKernel;
        uint32_t dynamicStructMembersOffset = 0;
        uint32_t descNestedTraitsOffset = 0;
        uint32_t descNestedTraitsCount = 0;

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
            dynamicStructMembersOffset = dynamicTraits.dynamicStructMembersOffset;
            descNestedTraitsOffset = dynamicTraits.descNestedTraits.offset;
            descNestedTraitsCount = dynamicTraits.descNestedTraits.count;
            dynMemSize = dynamicTraits.totalDynamicSize;
        }
        
        uint32_t dynMemSize = 0;
        alignas(8) char dynMem[];
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        std::unique_ptr<char[]> clone() {
            auto newCapturesMem = std::make_unique<char[]>(getCaptureTotalSize());
            auto newCaptures = new (newCapturesMem.get()) Captures();

            constexpr static bool skipSizeValidation{true};
            newCaptures->assignFrom(*this, skipSizeValidation);

            return newCapturesMem;
        }

        bool assignFrom(const Captures& rhs, bool skipSizeValidation = false) {
            if (this == &rhs) {
                return true;
            }
            if (!skipSizeValidation && getCaptureDynMemSize() != rhs.getCaptureDynMemSize()) {
                return false;
            }
            this->ret = rhs.ret;
            this->desc = rhs.desc;
            this->phKernel = rhs.phKernel;
            this->descNestedTraitsOffset = rhs.descNestedTraitsOffset;
            this->descNestedTraitsCount = rhs.descNestedTraitsCount;
            memcpy(this->dynMem, rhs.dynMem, rhs.getCaptureDynMemSize());
            this->dynMemSize = rhs.dynMemSize;
            this->dynamicStructMembersOffset = rhs.dynamicStructMembersOffset;
            reassembleNestedStructs();
            return true;
        }
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;
        void reassembleNestedStructs() {
            using Cal::Utils::alignUpPow2;

            uint32_t currentOffset = dynamicStructMembersOffset;

            if(descNestedTraitsCount > 0){
                assert(currentOffset == descNestedTraitsOffset);
                auto* descTraits = reinterpret_cast<DynamicStructTraits<ze_kernel_desc_t>*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(descNestedTraitsCount * sizeof(DynamicStructTraits<ze_kernel_desc_t>));
                auto* destDesc = &desc;

                for (uint32_t i = 0; i < descNestedTraitsCount; ++i) {
                    if(descTraits[i].pKernelNameOffset == -1){
                        forcePointerWrite(destDesc[i].pKernelName, nullptr);
                        continue;
                    }

                    forcePointerWrite(destDesc[i].pKernelName, dynMem + descTraits[i].pKernelNameOffset);
                    currentOffset += alignUpPow2<8>(descTraits[i].pKernelNameCount * sizeof(char));
                }
        }
    }

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeKernelCreateRpcM() = default;

    ZeKernelCreateRpcM(const Captures::DynamicTraits &dynamicTraits, ze_module_handle_t hModule, const ze_kernel_desc_t* desc, ze_kernel_handle_t* phKernel) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hModule = hModule;
        args.desc = desc;
        args.phKernel = phKernel;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeKernelCreateRpcM &message, ze_module_handle_t hModule, const ze_kernel_desc_t* desc, ze_kernel_handle_t* phKernel) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hModule = hModule;
        message.args.desc = desc;
        message.args.phKernel = phKernel;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.desc){
            captures.desc = *args.desc;
        }
        using Cal::Utils::alignUpPow2;

        auto& dynMem = captures.dynMem;
        uint32_t currentOffset = captures.dynamicStructMembersOffset;
        if(args.desc){
            assert(currentOffset == captures.descNestedTraitsOffset);
            auto* descTraits = reinterpret_cast<DynamicStructTraits<ze_kernel_desc_t>*>(dynMem + currentOffset);
            currentOffset += alignUpPow2<8>(captures.descNestedTraitsCount * sizeof(DynamicStructTraits<ze_kernel_desc_t>));

            for (uint32_t i = 0; i < captures.descNestedTraitsCount; ++i) {
                const auto& descPKernelName = args.desc[i].pKernelName;
                if(!descPKernelName){
                    descTraits[i].pKernelNameOffset = -1;
                    descTraits[i].pKernelNameCount = -1;
                    continue;
                }

                const auto descPKernelNameCount = static_cast<int32_t>(Cal::Utils::countNullterminated(args.desc[i].pKernelName));
                if(!descPKernelNameCount){
                    descTraits[i].pKernelNameOffset = -1;
                    descTraits[i].pKernelNameCount = -1;
                    continue;
                }

                descTraits[i].pKernelNameOffset = currentOffset;
                descTraits[i].pKernelNameCount = descPKernelNameCount;

                std::memcpy(dynMem + currentOffset, descPKernelName, descPKernelNameCount * sizeof(char));
                currentOffset += alignUpPow2<8>(descPKernelNameCount * sizeof(char));
            }
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phKernel){
            *args.phKernel = captures.phKernel;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeKernelCreateRpcM>);
struct ZeKernelDestroyRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 174;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_kernel_handle_t hKernel = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hKernel == rhs.hKernel;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeKernelDestroyRpcM() = default;

    ZeKernelDestroyRpcM(ze_kernel_handle_t hKernel) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hKernel = hKernel;
    }
    
    static void fillWithoutCapture(ZeKernelDestroyRpcM &message, ze_kernel_handle_t hKernel) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hKernel = hKernel;
    }
    
};
static_assert(std::is_standard_layout_v<ZeKernelDestroyRpcM>);
struct ZeModuleGetFunctionPointerRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 175;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_module_handle_t hModule = {};
        const char* pFunctionName = {};
        void** pfnFunction = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hModule == rhs.hModule;
            equal &= this->pFunctionName == rhs.pFunctionName;
            equal &= this->pfnFunction == rhs.pfnFunction;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_module_handle_t hModule, const char* pFunctionName, void** pfnFunction);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits pFunctionName = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        void* pfnFunction;
        uint32_t countPFunctionName = 0;
        char pFunctionName[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPFunctionName = dynamicTraits.pFunctionName.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeModuleGetFunctionPointerRpcM() = default;

    ZeModuleGetFunctionPointerRpcM(const Captures::DynamicTraits &dynamicTraits, ze_module_handle_t hModule, const char* pFunctionName, void** pfnFunction) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hModule = hModule;
        args.pFunctionName = pFunctionName;
        args.pfnFunction = pfnFunction;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeModuleGetFunctionPointerRpcM &message, ze_module_handle_t hModule, const char* pFunctionName, void** pfnFunction) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hModule = hModule;
        message.args.pFunctionName = pFunctionName;
        message.args.pfnFunction = pfnFunction;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pFunctionName){
            memcpy(asMemcpyDstT(captures.pFunctionName), args.pFunctionName, dynMemTraits.pFunctionName.size);
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pfnFunction){
            *args.pfnFunction = captures.pfnFunction;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeModuleGetFunctionPointerRpcM>);
struct ZeKernelSetGroupSizeRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 176;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_kernel_handle_t hKernel = {};
        uint32_t groupSizeX = {};
        uint32_t groupSizeY = {};
        uint32_t groupSizeZ = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hKernel == rhs.hKernel;
            equal &= this->groupSizeX == rhs.groupSizeX;
            equal &= this->groupSizeY == rhs.groupSizeY;
            equal &= this->groupSizeZ == rhs.groupSizeZ;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeKernelSetGroupSizeRpcM() = default;

    ZeKernelSetGroupSizeRpcM(ze_kernel_handle_t hKernel, uint32_t groupSizeX, uint32_t groupSizeY, uint32_t groupSizeZ) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hKernel = hKernel;
        args.groupSizeX = groupSizeX;
        args.groupSizeY = groupSizeY;
        args.groupSizeZ = groupSizeZ;
    }
    
    static void fillWithoutCapture(ZeKernelSetGroupSizeRpcM &message, ze_kernel_handle_t hKernel, uint32_t groupSizeX, uint32_t groupSizeY, uint32_t groupSizeZ) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hKernel = hKernel;
        message.args.groupSizeX = groupSizeX;
        message.args.groupSizeY = groupSizeY;
        message.args.groupSizeZ = groupSizeZ;
    }
    
};
static_assert(std::is_standard_layout_v<ZeKernelSetGroupSizeRpcM>);
struct ZeKernelSuggestGroupSizeRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 177;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_kernel_handle_t hKernel = {};
        uint32_t globalSizeX = {};
        uint32_t globalSizeY = {};
        uint32_t globalSizeZ = {};
        uint32_t* groupSizeX = {};
        uint32_t* groupSizeY = {};
        uint32_t* groupSizeZ = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hKernel == rhs.hKernel;
            equal &= this->globalSizeX == rhs.globalSizeX;
            equal &= this->globalSizeY == rhs.globalSizeY;
            equal &= this->globalSizeZ == rhs.globalSizeZ;
            equal &= this->groupSizeX == rhs.groupSizeX;
            equal &= this->groupSizeY == rhs.groupSizeY;
            equal &= this->groupSizeZ == rhs.groupSizeZ;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t groupSizeX;
        uint32_t groupSizeY;
        uint32_t groupSizeZ;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeKernelSuggestGroupSizeRpcM() = default;

    ZeKernelSuggestGroupSizeRpcM(ze_kernel_handle_t hKernel, uint32_t globalSizeX, uint32_t globalSizeY, uint32_t globalSizeZ, uint32_t* groupSizeX, uint32_t* groupSizeY, uint32_t* groupSizeZ) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hKernel = hKernel;
        args.globalSizeX = globalSizeX;
        args.globalSizeY = globalSizeY;
        args.globalSizeZ = globalSizeZ;
        args.groupSizeX = groupSizeX;
        args.groupSizeY = groupSizeY;
        args.groupSizeZ = groupSizeZ;
    }
    
    static void fillWithoutCapture(ZeKernelSuggestGroupSizeRpcM &message, ze_kernel_handle_t hKernel, uint32_t globalSizeX, uint32_t globalSizeY, uint32_t globalSizeZ, uint32_t* groupSizeX, uint32_t* groupSizeY, uint32_t* groupSizeZ) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hKernel = hKernel;
        message.args.globalSizeX = globalSizeX;
        message.args.globalSizeY = globalSizeY;
        message.args.globalSizeZ = globalSizeZ;
        message.args.groupSizeX = groupSizeX;
        message.args.groupSizeY = groupSizeY;
        message.args.groupSizeZ = groupSizeZ;
    }
    

    void copyToCaller(){
        if(args.groupSizeX){
            *args.groupSizeX = captures.groupSizeX;
        }
        if(args.groupSizeY){
            *args.groupSizeY = captures.groupSizeY;
        }
        if(args.groupSizeZ){
            *args.groupSizeZ = captures.groupSizeZ;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeKernelSuggestGroupSizeRpcM>);
struct ZeKernelSuggestMaxCooperativeGroupCountRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 178;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_kernel_handle_t hKernel = {};
        uint32_t* totalGroupCount = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hKernel == rhs.hKernel;
            equal &= this->totalGroupCount == rhs.totalGroupCount;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t totalGroupCount;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeKernelSuggestMaxCooperativeGroupCountRpcM() = default;

    ZeKernelSuggestMaxCooperativeGroupCountRpcM(ze_kernel_handle_t hKernel, uint32_t* totalGroupCount) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hKernel = hKernel;
        args.totalGroupCount = totalGroupCount;
    }
    
    static void fillWithoutCapture(ZeKernelSuggestMaxCooperativeGroupCountRpcM &message, ze_kernel_handle_t hKernel, uint32_t* totalGroupCount) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hKernel = hKernel;
        message.args.totalGroupCount = totalGroupCount;
    }
    

    void copyToCaller(){
        if(args.totalGroupCount){
            *args.totalGroupCount = captures.totalGroupCount;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeKernelSuggestMaxCooperativeGroupCountRpcM>);
struct ZeKernelSetArgumentValueRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 179;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_kernel_handle_t hKernel = {};
        uint32_t argIndex = {};
        size_t argSize = {};
        const void* pArgValue = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hKernel == rhs.hKernel;
            equal &= this->argIndex == rhs.argIndex;
            equal &= this->argSize == rhs.argSize;
            equal &= this->pArgValue == rhs.pArgValue;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_kernel_handle_t hKernel, uint32_t argIndex, size_t argSize, const void* pArgValue);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits pArgValue = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPArgValue = 0;
        char pArgValue[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPArgValue = dynamicTraits.pArgValue.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeKernelSetArgumentValueRpcM() = default;

    ZeKernelSetArgumentValueRpcM(const Captures::DynamicTraits &dynamicTraits, ze_kernel_handle_t hKernel, uint32_t argIndex, size_t argSize, const void* pArgValue) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hKernel = hKernel;
        args.argIndex = argIndex;
        args.argSize = argSize;
        args.pArgValue = pArgValue;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeKernelSetArgumentValueRpcM &message, ze_kernel_handle_t hKernel, uint32_t argIndex, size_t argSize, const void* pArgValue) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hKernel = hKernel;
        message.args.argIndex = argIndex;
        message.args.argSize = argSize;
        message.args.pArgValue = pArgValue;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pArgValue){
            memcpy(asMemcpyDstT(captures.pArgValue), args.pArgValue, dynMemTraits.pArgValue.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeKernelSetArgumentValueRpcM>);
struct ZeKernelSetIndirectAccessRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 180;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_kernel_handle_t hKernel = {};
        ze_kernel_indirect_access_flags_t flags = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hKernel == rhs.hKernel;
            equal &= this->flags == rhs.flags;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeKernelSetIndirectAccessRpcM() = default;

    ZeKernelSetIndirectAccessRpcM(ze_kernel_handle_t hKernel, ze_kernel_indirect_access_flags_t flags) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hKernel = hKernel;
        args.flags = flags;
    }
    
    static void fillWithoutCapture(ZeKernelSetIndirectAccessRpcM &message, ze_kernel_handle_t hKernel, ze_kernel_indirect_access_flags_t flags) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hKernel = hKernel;
        message.args.flags = flags;
    }
    
};
static_assert(std::is_standard_layout_v<ZeKernelSetIndirectAccessRpcM>);
struct ZeKernelGetIndirectAccessRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 181;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_kernel_handle_t hKernel = {};
        ze_kernel_indirect_access_flags_t* pFlags = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hKernel == rhs.hKernel;
            equal &= this->pFlags == rhs.pFlags;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_kernel_indirect_access_flags_t pFlags;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeKernelGetIndirectAccessRpcM() = default;

    ZeKernelGetIndirectAccessRpcM(ze_kernel_handle_t hKernel, ze_kernel_indirect_access_flags_t* pFlags) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hKernel = hKernel;
        args.pFlags = pFlags;
    }
    
    static void fillWithoutCapture(ZeKernelGetIndirectAccessRpcM &message, ze_kernel_handle_t hKernel, ze_kernel_indirect_access_flags_t* pFlags) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hKernel = hKernel;
        message.args.pFlags = pFlags;
    }
    

    void copyToCaller(){
        if(args.pFlags){
            *args.pFlags = captures.pFlags;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeKernelGetIndirectAccessRpcM>);
struct ZeKernelSetCacheConfigRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 182;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_kernel_handle_t hKernel = {};
        ze_cache_config_flags_t flags = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hKernel == rhs.hKernel;
            equal &= this->flags == rhs.flags;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeKernelSetCacheConfigRpcM() = default;

    ZeKernelSetCacheConfigRpcM(ze_kernel_handle_t hKernel, ze_cache_config_flags_t flags) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hKernel = hKernel;
        args.flags = flags;
    }
    
    static void fillWithoutCapture(ZeKernelSetCacheConfigRpcM &message, ze_kernel_handle_t hKernel, ze_cache_config_flags_t flags) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hKernel = hKernel;
        message.args.flags = flags;
    }
    
};
static_assert(std::is_standard_layout_v<ZeKernelSetCacheConfigRpcM>);
struct ZeKernelGetPropertiesRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 183;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_kernel_handle_t hKernel = {};
        ze_kernel_properties_t* pKernelProperties = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hKernel == rhs.hKernel;
            equal &= this->pKernelProperties == rhs.pKernelProperties;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_kernel_handle_t hKernel, ze_kernel_properties_t* pKernelProperties);
            uint32_t totalDynamicSize = 0;
            uint32_t dynamicStructMembersOffset = 0;
            DynamicArgTraits pKernelPropertiesNestedTraits = {};
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_kernel_properties_t pKernelProperties;
        uint32_t dynamicStructMembersOffset = 0;
        uint32_t pKernelPropertiesNestedTraitsOffset = 0;
        uint32_t pKernelPropertiesNestedTraitsCount = 0;

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
            dynamicStructMembersOffset = dynamicTraits.dynamicStructMembersOffset;
            pKernelPropertiesNestedTraitsOffset = dynamicTraits.pKernelPropertiesNestedTraits.offset;
            pKernelPropertiesNestedTraitsCount = dynamicTraits.pKernelPropertiesNestedTraits.count;
            dynMemSize = dynamicTraits.totalDynamicSize;
        }
        
        uint32_t dynMemSize = 0;
        alignas(8) char dynMem[];
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;
        void reassembleNestedStructs() {
            using Cal::Utils::alignUpPow2;

            uint32_t currentOffset = dynamicStructMembersOffset;

            if(pKernelPropertiesNestedTraitsCount > 0){
                assert(currentOffset == pKernelPropertiesNestedTraitsOffset);
                auto* pKernelPropertiesTraits = reinterpret_cast<DynamicStructTraits<ze_kernel_properties_t>*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(pKernelPropertiesNestedTraitsCount * sizeof(DynamicStructTraits<ze_kernel_properties_t>));
                auto* destPKernelProperties = &pKernelProperties;

                for (uint32_t i = 0; i < pKernelPropertiesNestedTraitsCount; ++i) {
                    if(pKernelPropertiesTraits[i].pNextOffset == -1){
                        forcePointerWrite(destPKernelProperties[i].pNext, nullptr);
                        continue;
                    }

                    auto pKernelPropertiesPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                    currentOffset += alignUpPow2<8>(pKernelPropertiesTraits[i].pNextCount * sizeof(NestedPNextTraits));

                    assert(currentOffset == static_cast<uint32_t>(pKernelPropertiesPNextListElementTraits[0].extensionOffset));
                    forcePointerWrite(destPKernelProperties[i].pNext, dynMem + pKernelPropertiesPNextListElementTraits[0].extensionOffset);
                    currentOffset += alignUpPow2<8>(getUnderlyingSize(static_cast<const ze_base_desc_t*>(destPKernelProperties[i].pNext)));

                    auto pKernelPropertiesPNextListElement = static_cast<const ze_base_desc_t*>(destPKernelProperties[i].pNext);
                    for(int32_t j = 1; j <= pKernelPropertiesTraits[i].pNextCount; ++j){
                        if (j < pKernelPropertiesTraits[i].pNextCount) {
                            const auto extensionOffset = pKernelPropertiesPNextListElementTraits[j].extensionOffset;
                            forcePointerWrite(getNextField(*pKernelPropertiesPNextListElement), dynMem + extensionOffset);
                        }

                        if (j < pKernelPropertiesTraits[i].pNextCount) {
                            const auto pNextElement = getNext(pKernelPropertiesPNextListElement);
                            const auto sizeInBytes = getUnderlyingSize(pNextElement);
                            currentOffset += alignUpPow2<8>(sizeInBytes);

                            pKernelPropertiesPNextListElement = pNextElement;
                        }

                    }

                }
        }
    }

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeKernelGetPropertiesRpcM() = default;

    ZeKernelGetPropertiesRpcM(const Captures::DynamicTraits &dynamicTraits, ze_kernel_handle_t hKernel, ze_kernel_properties_t* pKernelProperties) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hKernel = hKernel;
        args.pKernelProperties = pKernelProperties;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeKernelGetPropertiesRpcM &message, ze_kernel_handle_t hKernel, ze_kernel_properties_t* pKernelProperties) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hKernel = hKernel;
        message.args.pKernelProperties = pKernelProperties;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pKernelProperties){
            captures.pKernelProperties = *args.pKernelProperties;
        }
        using Cal::Utils::alignUpPow2;

        auto& dynMem = captures.dynMem;
        uint32_t currentOffset = captures.dynamicStructMembersOffset;
        if(args.pKernelProperties){
            assert(currentOffset == captures.pKernelPropertiesNestedTraitsOffset);
            auto* pKernelPropertiesTraits = reinterpret_cast<DynamicStructTraits<ze_kernel_properties_t>*>(dynMem + currentOffset);
            currentOffset += alignUpPow2<8>(captures.pKernelPropertiesNestedTraitsCount * sizeof(DynamicStructTraits<ze_kernel_properties_t>));

            for (uint32_t i = 0; i < captures.pKernelPropertiesNestedTraitsCount; ++i) {
                const auto& pKernelPropertiesPNext = args.pKernelProperties[i].pNext;
                if(!pKernelPropertiesPNext){
                    pKernelPropertiesTraits[i].pNextOffset = -1;
                    pKernelPropertiesTraits[i].pNextCount = -1;
                    continue;
                }

                const auto pKernelPropertiesPNextCount = static_cast<int32_t>(countOpaqueList(static_cast<const ze_base_desc_t*>(args.pKernelProperties[i].pNext)));
                if(!pKernelPropertiesPNextCount){
                    pKernelPropertiesTraits[i].pNextOffset = -1;
                    pKernelPropertiesTraits[i].pNextCount = -1;
                    continue;
                }

                pKernelPropertiesTraits[i].pNextOffset = currentOffset;
                pKernelPropertiesTraits[i].pNextCount = pKernelPropertiesPNextCount;
                pKernelPropertiesTraits[i].pNextFirstOriginalElement = args.pKernelProperties[i].pNext;

                auto pKernelPropertiesPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(pKernelPropertiesPNextCount * sizeof(NestedPNextTraits));

                auto pKernelPropertiesPNextListElement = static_cast<const ze_base_desc_t*>(args.pKernelProperties[i].pNext);
                for(int32_t j = 0; j < pKernelPropertiesPNextCount; ++j){
                    pKernelPropertiesPNextListElementTraits[j].extensionType = getExtensionType(pKernelPropertiesPNextListElement);
                    pKernelPropertiesPNextListElementTraits[j].extensionOffset = currentOffset;

                    const auto sizeInBytes = getUnderlyingSize(pKernelPropertiesPNextListElement);
                    std::memcpy(dynMem + currentOffset, pKernelPropertiesPNextListElement, sizeInBytes);
                    currentOffset += alignUpPow2<8>(sizeInBytes);

                    pKernelPropertiesPNextListElement = getNext(pKernelPropertiesPNextListElement);
                }

            }
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pKernelProperties){
            *args.pKernelProperties = captures.pKernelProperties;
        }
        using Cal::Utils::alignUpPow2;

        auto& dynMem = captures.dynMem;
        uint32_t currentOffset = captures.dynamicStructMembersOffset;
        if(args.pKernelProperties) {
            assert(currentOffset == captures.pKernelPropertiesNestedTraitsOffset);
            auto* pKernelPropertiesTraits = reinterpret_cast<DynamicStructTraits<ze_kernel_properties_t>*>(dynMem + currentOffset);
            currentOffset += alignUpPow2<8>(captures.pKernelPropertiesNestedTraitsCount * sizeof(DynamicStructTraits<ze_kernel_properties_t>));

            auto* destPKernelProperties = args.pKernelProperties;

            for (uint32_t i = 0; i < captures.pKernelPropertiesNestedTraitsCount; ++i) {
                if(pKernelPropertiesTraits[i].pNextOffset == -1){
                    continue;
                }

                destPKernelProperties[i].pNext = pKernelPropertiesTraits[i].pNextFirstOriginalElement;

                auto pKernelPropertiesPNextListElementTraits = reinterpret_cast<NestedPNextTraits*>(dynMem + currentOffset);
                currentOffset += alignUpPow2<8>(pKernelPropertiesTraits[i].pNextCount * sizeof(NestedPNextTraits));

                auto pKernelPropertiesPNextListElement = static_cast<const ze_base_desc_t*>(destPKernelProperties[i].pNext);
                for(int32_t j = 0; j < pKernelPropertiesTraits[i].pNextCount; ++j){
                    const auto sizeInBytes = getUnderlyingSize(pKernelPropertiesPNextListElement);
                    currentOffset += alignUpPow2<8>(sizeInBytes);

                    const auto extensionType = getExtensionType(pKernelPropertiesPNextListElement);
                    if (!isReadOnly(extensionType)) {
                        {
                            auto originalNextOpaqueElement = getNext(pKernelPropertiesPNextListElement);
                            const auto extensionOffset = pKernelPropertiesPNextListElementTraits[j].extensionOffset;
                            auto destination = const_cast<ze_base_desc_t*>(pKernelPropertiesPNextListElement);
                            std::memcpy(destination, dynMem + extensionOffset, sizeInBytes);

                            getNextField(*destination) = originalNextOpaqueElement;
                        }

                    }

                    pKernelPropertiesPNextListElement = getNext(pKernelPropertiesPNextListElement);
                }

            }
        }
    }
};
static_assert(std::is_standard_layout_v<ZeKernelGetPropertiesRpcM>);
struct ZeKernelGetNameRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 184;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_kernel_handle_t hKernel = {};
        size_t* pSize = {};
        char* pName = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hKernel == rhs.hKernel;
            equal &= this->pSize == rhs.pSize;
            equal &= this->pName == rhs.pName;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_kernel_handle_t hKernel, size_t* pSize, char* pName);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits pName = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        size_t pSize;
        uint32_t countPName = 0;
        char pName[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPName = dynamicTraits.pName.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeKernelGetNameRpcM() = default;

    ZeKernelGetNameRpcM(const Captures::DynamicTraits &dynamicTraits, ze_kernel_handle_t hKernel, size_t* pSize, char* pName) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hKernel = hKernel;
        args.pSize = pSize;
        args.pName = pName;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeKernelGetNameRpcM &message, ze_kernel_handle_t hKernel, size_t* pSize, char* pName) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hKernel = hKernel;
        message.args.pSize = pSize;
        message.args.pName = pName;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pSize){
            captures.pSize = *args.pSize;
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pSize){
            *args.pSize = captures.pSize;
        }
        if(args.pName){
            memcpy(args.pName, captures.pName, dynMemTraits.pName.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeKernelGetNameRpcM>);
struct ZeCommandListAppendLaunchKernelRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 185;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        ze_kernel_handle_t hKernel = {};
        const ze_group_count_t* pLaunchFuncArgs = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->hKernel == rhs.hKernel;
            equal &= this->pLaunchFuncArgs == rhs.pLaunchFuncArgs;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, ze_kernel_handle_t hKernel, const ze_group_count_t* pLaunchFuncArgs, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_group_count_t pLaunchFuncArgs;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendLaunchKernelRpcM() = default;

    ZeCommandListAppendLaunchKernelRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, ze_kernel_handle_t hKernel, const ze_group_count_t* pLaunchFuncArgs, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.hKernel = hKernel;
        args.pLaunchFuncArgs = pLaunchFuncArgs;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendLaunchKernelRpcM &message, ze_command_list_handle_t hCommandList, ze_kernel_handle_t hKernel, const ze_group_count_t* pLaunchFuncArgs, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.hKernel = hKernel;
        message.args.pLaunchFuncArgs = pLaunchFuncArgs;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pLaunchFuncArgs){
            captures.pLaunchFuncArgs = *args.pLaunchFuncArgs;
        }
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendLaunchKernelRpcM>);
struct ZeCommandListAppendLaunchCooperativeKernelRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 186;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        ze_kernel_handle_t hKernel = {};
        const ze_group_count_t* pLaunchFuncArgs = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->hKernel == rhs.hKernel;
            equal &= this->pLaunchFuncArgs == rhs.pLaunchFuncArgs;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, ze_kernel_handle_t hKernel, const ze_group_count_t* pLaunchFuncArgs, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_group_count_t pLaunchFuncArgs;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendLaunchCooperativeKernelRpcM() = default;

    ZeCommandListAppendLaunchCooperativeKernelRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, ze_kernel_handle_t hKernel, const ze_group_count_t* pLaunchFuncArgs, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.hKernel = hKernel;
        args.pLaunchFuncArgs = pLaunchFuncArgs;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendLaunchCooperativeKernelRpcM &message, ze_command_list_handle_t hCommandList, ze_kernel_handle_t hKernel, const ze_group_count_t* pLaunchFuncArgs, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.hKernel = hKernel;
        message.args.pLaunchFuncArgs = pLaunchFuncArgs;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.pLaunchFuncArgs){
            captures.pLaunchFuncArgs = *args.pLaunchFuncArgs;
        }
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendLaunchCooperativeKernelRpcM>);
struct ZeCommandListAppendLaunchKernelIndirectRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 187;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        ze_kernel_handle_t hKernel = {};
        const ze_group_count_t* pLaunchArgumentsBuffer = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->hKernel == rhs.hKernel;
            equal &= this->pLaunchArgumentsBuffer == rhs.pLaunchArgumentsBuffer;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, ze_kernel_handle_t hKernel, const ze_group_count_t* pLaunchArgumentsBuffer, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendLaunchKernelIndirectRpcM() = default;

    ZeCommandListAppendLaunchKernelIndirectRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, ze_kernel_handle_t hKernel, const ze_group_count_t* pLaunchArgumentsBuffer, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.hKernel = hKernel;
        args.pLaunchArgumentsBuffer = pLaunchArgumentsBuffer;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendLaunchKernelIndirectRpcM &message, ze_command_list_handle_t hCommandList, ze_kernel_handle_t hKernel, const ze_group_count_t* pLaunchArgumentsBuffer, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.hKernel = hKernel;
        message.args.pLaunchArgumentsBuffer = pLaunchArgumentsBuffer;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendLaunchKernelIndirectRpcM>);
struct ZeCommandListAppendLaunchMultipleKernelsIndirectRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 188;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        uint32_t numKernels = {};
        ze_kernel_handle_t* phKernels = {};
        const uint32_t* pCountBuffer = {};
        const ze_group_count_t* pLaunchArgumentsBuffer = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->numKernels == rhs.numKernels;
            equal &= this->phKernels == rhs.phKernels;
            equal &= this->pCountBuffer == rhs.pCountBuffer;
            equal &= this->pLaunchArgumentsBuffer == rhs.pLaunchArgumentsBuffer;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, uint32_t numKernels, ze_kernel_handle_t* phKernels, const uint32_t* pCountBuffer, const ze_group_count_t* pLaunchArgumentsBuffer, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phKernels = {};          
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t offsetPhWaitEvents = 0;
        uint32_t countPhKernels = 0;
        uint32_t countPhWaitEvents = 0;
        ze_kernel_handle_t* getPhKernels() {
            auto offset = 0;
            return reinterpret_cast<ze_kernel_handle_t*>(dynMem + offset);
        }

        ze_event_handle_t* getPhWaitEvents() {
            auto offset = offsetPhWaitEvents;
            return reinterpret_cast<ze_event_handle_t*>(dynMem + offset);
        }


        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        offsetPhWaitEvents = dynamicTraits.phWaitEvents.offset;
        countPhKernels = dynamicTraits.phKernels.count;
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        alignas(8) char dynMem[];
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendLaunchMultipleKernelsIndirectRpcM() = default;

    ZeCommandListAppendLaunchMultipleKernelsIndirectRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, uint32_t numKernels, ze_kernel_handle_t* phKernels, const uint32_t* pCountBuffer, const ze_group_count_t* pLaunchArgumentsBuffer, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.numKernels = numKernels;
        args.phKernels = phKernels;
        args.pCountBuffer = pCountBuffer;
        args.pLaunchArgumentsBuffer = pLaunchArgumentsBuffer;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendLaunchMultipleKernelsIndirectRpcM &message, ze_command_list_handle_t hCommandList, uint32_t numKernels, ze_kernel_handle_t* phKernels, const uint32_t* pCountBuffer, const ze_group_count_t* pLaunchArgumentsBuffer, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.numKernels = numKernels;
        message.args.phKernels = phKernels;
        message.args.pCountBuffer = pCountBuffer;
        message.args.pLaunchArgumentsBuffer = pLaunchArgumentsBuffer;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phKernels){
            memcpy(asMemcpyDstT(captures.getPhKernels()), args.phKernels, dynMemTraits.phKernels.size);
        }
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.getPhWaitEvents()), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendLaunchMultipleKernelsIndirectRpcM>);
struct ZeCommandListHostSynchronizeRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 189;
    static constexpr float latency = 2.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        uint64_t timeout = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->timeout == rhs.timeout;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListHostSynchronizeRpcM() = default;

    ZeCommandListHostSynchronizeRpcM(ze_command_list_handle_t hCommandList, uint64_t timeout) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.timeout = timeout;
    }
    
    static void fillWithoutCapture(ZeCommandListHostSynchronizeRpcM &message, ze_command_list_handle_t hCommandList, uint64_t timeout) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.timeout = timeout;
    }
    
};
static_assert(std::is_standard_layout_v<ZeCommandListHostSynchronizeRpcM>);
struct ZeDevicePciGetPropertiesExtRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 190;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_device_handle_t hDevice = {};
        ze_pci_ext_properties_t* pPciProperties = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->pPciProperties == rhs.pPciProperties;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_pci_ext_properties_t pPciProperties;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeDevicePciGetPropertiesExtRpcM() = default;

    ZeDevicePciGetPropertiesExtRpcM(ze_device_handle_t hDevice, ze_pci_ext_properties_t* pPciProperties) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDevice = hDevice;
        args.pPciProperties = pPciProperties;
    }
    
    static void fillWithoutCapture(ZeDevicePciGetPropertiesExtRpcM &message, ze_device_handle_t hDevice, ze_pci_ext_properties_t* pPciProperties) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDevice = hDevice;
        message.args.pPciProperties = pPciProperties;
    }
    

    void copyFromCaller(){
        if(args.pPciProperties){
            captures.pPciProperties = *args.pPciProperties;
        }
    }

    void copyToCaller(){
        if(args.pPciProperties){
            *args.pPciProperties = captures.pPciProperties;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeDevicePciGetPropertiesExtRpcM>);
struct ZeContextMakeMemoryResidentRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 191;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_context_handle_t hContext = {};
        ze_device_handle_t hDevice = {};
        void* ptr = {};
        size_t size = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hContext == rhs.hContext;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->ptr == rhs.ptr;
            equal &= this->size == rhs.size;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeContextMakeMemoryResidentRpcM() = default;

    ZeContextMakeMemoryResidentRpcM(ze_context_handle_t hContext, ze_device_handle_t hDevice, void* ptr, size_t size) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hContext = hContext;
        args.hDevice = hDevice;
        args.ptr = ptr;
        args.size = size;
    }
    
    static void fillWithoutCapture(ZeContextMakeMemoryResidentRpcM &message, ze_context_handle_t hContext, ze_device_handle_t hDevice, void* ptr, size_t size) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hContext = hContext;
        message.args.hDevice = hDevice;
        message.args.ptr = ptr;
        message.args.size = size;
    }
    
};
static_assert(std::is_standard_layout_v<ZeContextMakeMemoryResidentRpcM>);
struct ZeContextEvictMemoryRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 192;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_context_handle_t hContext = {};
        ze_device_handle_t hDevice = {};
        void* ptr = {};
        size_t size = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hContext == rhs.hContext;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->ptr == rhs.ptr;
            equal &= this->size == rhs.size;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeContextEvictMemoryRpcM() = default;

    ZeContextEvictMemoryRpcM(ze_context_handle_t hContext, ze_device_handle_t hDevice, void* ptr, size_t size) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hContext = hContext;
        args.hDevice = hDevice;
        args.ptr = ptr;
        args.size = size;
    }
    
    static void fillWithoutCapture(ZeContextEvictMemoryRpcM &message, ze_context_handle_t hContext, ze_device_handle_t hDevice, void* ptr, size_t size) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hContext = hContext;
        message.args.hDevice = hDevice;
        message.args.ptr = ptr;
        message.args.size = size;
    }
    
};
static_assert(std::is_standard_layout_v<ZeContextEvictMemoryRpcM>);
struct ZeVirtualMemReserveRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 193;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_context_handle_t hContext = {};
        const void* pStart = {};
        size_t size = {};
        void** pptr = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hContext == rhs.hContext;
            equal &= this->pStart == rhs.pStart;
            equal &= this->size == rhs.size;
            equal &= this->pptr == rhs.pptr;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        void* pptr;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeVirtualMemReserveRpcM() = default;

    ZeVirtualMemReserveRpcM(ze_context_handle_t hContext, const void* pStart, size_t size, void** pptr) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hContext = hContext;
        args.pStart = pStart;
        args.size = size;
        args.pptr = pptr;
    }
    
    static void fillWithoutCapture(ZeVirtualMemReserveRpcM &message, ze_context_handle_t hContext, const void* pStart, size_t size, void** pptr) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hContext = hContext;
        message.args.pStart = pStart;
        message.args.size = size;
        message.args.pptr = pptr;
    }
    

    void copyToCaller(){
        if(args.pptr){
            *args.pptr = captures.pptr;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeVirtualMemReserveRpcM>);
struct ZeVirtualMemFreeRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 194;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_context_handle_t hContext = {};
        const void* ptr = {};
        size_t size = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hContext == rhs.hContext;
            equal &= this->ptr == rhs.ptr;
            equal &= this->size == rhs.size;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeVirtualMemFreeRpcM() = default;

    ZeVirtualMemFreeRpcM(ze_context_handle_t hContext, const void* ptr, size_t size) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hContext = hContext;
        args.ptr = ptr;
        args.size = size;
    }
    
    static void fillWithoutCapture(ZeVirtualMemFreeRpcM &message, ze_context_handle_t hContext, const void* ptr, size_t size) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hContext = hContext;
        message.args.ptr = ptr;
        message.args.size = size;
    }
    
};
static_assert(std::is_standard_layout_v<ZeVirtualMemFreeRpcM>);
struct ZeVirtualMemQueryPageSizeRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 195;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_context_handle_t hContext = {};
        ze_device_handle_t hDevice = {};
        size_t size = {};
        size_t* pagesize = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hContext == rhs.hContext;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->size == rhs.size;
            equal &= this->pagesize == rhs.pagesize;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        size_t pagesize;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeVirtualMemQueryPageSizeRpcM() = default;

    ZeVirtualMemQueryPageSizeRpcM(ze_context_handle_t hContext, ze_device_handle_t hDevice, size_t size, size_t* pagesize) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hContext = hContext;
        args.hDevice = hDevice;
        args.size = size;
        args.pagesize = pagesize;
    }
    
    static void fillWithoutCapture(ZeVirtualMemQueryPageSizeRpcM &message, ze_context_handle_t hContext, ze_device_handle_t hDevice, size_t size, size_t* pagesize) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hContext = hContext;
        message.args.hDevice = hDevice;
        message.args.size = size;
        message.args.pagesize = pagesize;
    }
    

    void copyFromCaller(){
        if(args.pagesize){
            captures.pagesize = *args.pagesize;
        }
    }

    void copyToCaller(){
        if(args.pagesize){
            *args.pagesize = captures.pagesize;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeVirtualMemQueryPageSizeRpcM>);
struct ZePhysicalMemCreateRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 196;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_context_handle_t hContext = {};
        ze_device_handle_t hDevice = {};
        ze_physical_mem_desc_t* desc = {};
        ze_physical_mem_handle_t* phPhysicalMemory = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hContext == rhs.hContext;
            equal &= this->hDevice == rhs.hDevice;
            equal &= this->desc == rhs.desc;
            equal &= this->phPhysicalMemory == rhs.phPhysicalMemory;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_physical_mem_desc_t desc;
        ze_physical_mem_handle_t phPhysicalMemory;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZePhysicalMemCreateRpcM() = default;

    ZePhysicalMemCreateRpcM(ze_context_handle_t hContext, ze_device_handle_t hDevice, ze_physical_mem_desc_t* desc, ze_physical_mem_handle_t* phPhysicalMemory) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hContext = hContext;
        args.hDevice = hDevice;
        args.desc = desc;
        args.phPhysicalMemory = phPhysicalMemory;
    }
    
    static void fillWithoutCapture(ZePhysicalMemCreateRpcM &message, ze_context_handle_t hContext, ze_device_handle_t hDevice, ze_physical_mem_desc_t* desc, ze_physical_mem_handle_t* phPhysicalMemory) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hContext = hContext;
        message.args.hDevice = hDevice;
        message.args.desc = desc;
        message.args.phPhysicalMemory = phPhysicalMemory;
    }
    

    void copyFromCaller(){
        if(args.desc){
            captures.desc = *args.desc;
        }
        if(args.phPhysicalMemory){
            captures.phPhysicalMemory = *args.phPhysicalMemory;
        }
    }

    void copyToCaller(){
        if(args.phPhysicalMemory){
            *args.phPhysicalMemory = captures.phPhysicalMemory;
        }
    }
};
static_assert(std::is_standard_layout_v<ZePhysicalMemCreateRpcM>);
struct ZePhysicalMemDestroyRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 197;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_context_handle_t hContext = {};
        ze_physical_mem_handle_t hPhysicalMemory = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hContext == rhs.hContext;
            equal &= this->hPhysicalMemory == rhs.hPhysicalMemory;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZePhysicalMemDestroyRpcM() = default;

    ZePhysicalMemDestroyRpcM(ze_context_handle_t hContext, ze_physical_mem_handle_t hPhysicalMemory) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hContext = hContext;
        args.hPhysicalMemory = hPhysicalMemory;
    }
    
    static void fillWithoutCapture(ZePhysicalMemDestroyRpcM &message, ze_context_handle_t hContext, ze_physical_mem_handle_t hPhysicalMemory) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hContext = hContext;
        message.args.hPhysicalMemory = hPhysicalMemory;
    }
    
};
static_assert(std::is_standard_layout_v<ZePhysicalMemDestroyRpcM>);
struct ZeVirtualMemMapRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 198;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_context_handle_t hContext = {};
        const void* ptr = {};
        size_t size = {};
        ze_physical_mem_handle_t hPhysicalMemory = {};
        size_t offset = {};
        ze_memory_access_attribute_t access = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hContext == rhs.hContext;
            equal &= this->ptr == rhs.ptr;
            equal &= this->size == rhs.size;
            equal &= this->hPhysicalMemory == rhs.hPhysicalMemory;
            equal &= this->offset == rhs.offset;
            equal &= this->access == rhs.access;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeVirtualMemMapRpcM() = default;

    ZeVirtualMemMapRpcM(ze_context_handle_t hContext, const void* ptr, size_t size, ze_physical_mem_handle_t hPhysicalMemory, size_t offset, ze_memory_access_attribute_t access) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hContext = hContext;
        args.ptr = ptr;
        args.size = size;
        args.hPhysicalMemory = hPhysicalMemory;
        args.offset = offset;
        args.access = access;
    }
    
    static void fillWithoutCapture(ZeVirtualMemMapRpcM &message, ze_context_handle_t hContext, const void* ptr, size_t size, ze_physical_mem_handle_t hPhysicalMemory, size_t offset, ze_memory_access_attribute_t access) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hContext = hContext;
        message.args.ptr = ptr;
        message.args.size = size;
        message.args.hPhysicalMemory = hPhysicalMemory;
        message.args.offset = offset;
        message.args.access = access;
    }
    
};
static_assert(std::is_standard_layout_v<ZeVirtualMemMapRpcM>);
struct ZeVirtualMemUnmapRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 199;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_context_handle_t hContext = {};
        const void* ptr = {};
        size_t size = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hContext == rhs.hContext;
            equal &= this->ptr == rhs.ptr;
            equal &= this->size == rhs.size;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeVirtualMemUnmapRpcM() = default;

    ZeVirtualMemUnmapRpcM(ze_context_handle_t hContext, const void* ptr, size_t size) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hContext = hContext;
        args.ptr = ptr;
        args.size = size;
    }
    
    static void fillWithoutCapture(ZeVirtualMemUnmapRpcM &message, ze_context_handle_t hContext, const void* ptr, size_t size) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hContext = hContext;
        message.args.ptr = ptr;
        message.args.size = size;
    }
    
};
static_assert(std::is_standard_layout_v<ZeVirtualMemUnmapRpcM>);
struct ZeVirtualMemSetAccessAttributeRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 200;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_context_handle_t hContext = {};
        const void* ptr = {};
        size_t size = {};
        ze_memory_access_attribute_t access = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hContext == rhs.hContext;
            equal &= this->ptr == rhs.ptr;
            equal &= this->size == rhs.size;
            equal &= this->access == rhs.access;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeVirtualMemSetAccessAttributeRpcM() = default;

    ZeVirtualMemSetAccessAttributeRpcM(ze_context_handle_t hContext, const void* ptr, size_t size, ze_memory_access_attribute_t access) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hContext = hContext;
        args.ptr = ptr;
        args.size = size;
        args.access = access;
    }
    
    static void fillWithoutCapture(ZeVirtualMemSetAccessAttributeRpcM &message, ze_context_handle_t hContext, const void* ptr, size_t size, ze_memory_access_attribute_t access) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hContext = hContext;
        message.args.ptr = ptr;
        message.args.size = size;
        message.args.access = access;
    }
    
};
static_assert(std::is_standard_layout_v<ZeVirtualMemSetAccessAttributeRpcM>);
struct ZeVirtualMemGetAccessAttributeRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 201;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_context_handle_t hContext = {};
        const void* ptr = {};
        size_t size = {};
        ze_memory_access_attribute_t* access = {};
        size_t* outSize = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hContext == rhs.hContext;
            equal &= this->ptr == rhs.ptr;
            equal &= this->size == rhs.size;
            equal &= this->access == rhs.access;
            equal &= this->outSize == rhs.outSize;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        ze_memory_access_attribute_t access;
        size_t outSize;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeVirtualMemGetAccessAttributeRpcM() = default;

    ZeVirtualMemGetAccessAttributeRpcM(ze_context_handle_t hContext, const void* ptr, size_t size, ze_memory_access_attribute_t* access, size_t* outSize) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hContext = hContext;
        args.ptr = ptr;
        args.size = size;
        args.access = access;
        args.outSize = outSize;
    }
    
    static void fillWithoutCapture(ZeVirtualMemGetAccessAttributeRpcM &message, ze_context_handle_t hContext, const void* ptr, size_t size, ze_memory_access_attribute_t* access, size_t* outSize) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hContext = hContext;
        message.args.ptr = ptr;
        message.args.size = size;
        message.args.access = access;
        message.args.outSize = outSize;
    }
    

    void copyFromCaller(){
        if(args.outSize){
            captures.outSize = *args.outSize;
        }
    }

    void copyToCaller(){
        if(args.access){
            *args.access = captures.access;
        }
        if(args.outSize){
            *args.outSize = captures.outSize;
        }
    }
};
static_assert(std::is_standard_layout_v<ZeVirtualMemGetAccessAttributeRpcM>);
struct ZexDriverImportExternalPointerRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 202;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_driver_handle_t hDriver = {};
        void* ptr = {};
        size_t size = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDriver == rhs.hDriver;
            equal &= this->ptr == rhs.ptr;
            equal &= this->size == rhs.size;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZexDriverImportExternalPointerRpcM() = default;

    ZexDriverImportExternalPointerRpcM(ze_driver_handle_t hDriver, void* ptr, size_t size) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDriver = hDriver;
        args.ptr = ptr;
        args.size = size;
    }
    
    static void fillWithoutCapture(ZexDriverImportExternalPointerRpcM &message, ze_driver_handle_t hDriver, void* ptr, size_t size) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDriver = hDriver;
        message.args.ptr = ptr;
        message.args.size = size;
    }
    
};
static_assert(std::is_standard_layout_v<ZexDriverImportExternalPointerRpcM>);
struct ZexDriverReleaseImportedPointerRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 203;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_driver_handle_t hDriver = {};
        void* ptr = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDriver == rhs.hDriver;
            equal &= this->ptr == rhs.ptr;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZexDriverReleaseImportedPointerRpcM() = default;

    ZexDriverReleaseImportedPointerRpcM(ze_driver_handle_t hDriver, void* ptr) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDriver = hDriver;
        args.ptr = ptr;
    }
    
    static void fillWithoutCapture(ZexDriverReleaseImportedPointerRpcM &message, ze_driver_handle_t hDriver, void* ptr) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDriver = hDriver;
        message.args.ptr = ptr;
    }
    
};
static_assert(std::is_standard_layout_v<ZexDriverReleaseImportedPointerRpcM>);
struct ZexDriverGetHostPointerBaseAddressRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 204;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_driver_handle_t hDriver = {};
        void* ptr = {};
        void** baseAddress = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hDriver == rhs.hDriver;
            equal &= this->ptr == rhs.ptr;
            equal &= this->baseAddress == rhs.baseAddress;
            return equal;
        }
    }args;

    struct Captures {

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        void* baseAddress;

        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZexDriverGetHostPointerBaseAddressRpcM() = default;

    ZexDriverGetHostPointerBaseAddressRpcM(ze_driver_handle_t hDriver, void* ptr, void** baseAddress) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hDriver = hDriver;
        args.ptr = ptr;
        args.baseAddress = baseAddress;
    }
    
    static void fillWithoutCapture(ZexDriverGetHostPointerBaseAddressRpcM &message, ze_driver_handle_t hDriver, void* ptr, void** baseAddress) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hDriver = hDriver;
        message.args.ptr = ptr;
        message.args.baseAddress = baseAddress;
    }
    

    void copyFromCaller(){
        captures.baseAddress = *args.baseAddress;
    }

    void copyToCaller(){
            *args.baseAddress = captures.baseAddress;
    }
};
static_assert(std::is_standard_layout_v<ZexDriverGetHostPointerBaseAddressRpcM>);
struct ZeCommandListAppendMemoryCopyDeferred_Usm_UsmRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 205;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyDeferred_Usm_UsmRpcM() = default;

    ZeCommandListAppendMemoryCopyDeferred_Usm_UsmRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyDeferred_Usm_UsmRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyDeferred_Usm_UsmRpcM>);
struct ZeCommandListAppendMemoryCopyDeferred_Usm_SharedRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 206;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyDeferred_Usm_SharedRpcM() = default;

    ZeCommandListAppendMemoryCopyDeferred_Usm_SharedRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyDeferred_Usm_SharedRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyDeferred_Usm_SharedRpcM>);
struct ZeCommandListAppendMemoryCopyDeferred_Usm_RemappedRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 207;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyDeferred_Usm_RemappedRpcM() = default;

    ZeCommandListAppendMemoryCopyDeferred_Usm_RemappedRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyDeferred_Usm_RemappedRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyDeferred_Usm_RemappedRpcM>);
struct ZeCommandListAppendMemoryCopyDeferred_Shared_UsmRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 208;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyDeferred_Shared_UsmRpcM() = default;

    ZeCommandListAppendMemoryCopyDeferred_Shared_UsmRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyDeferred_Shared_UsmRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyDeferred_Shared_UsmRpcM>);
struct ZeCommandListAppendMemoryCopyDeferred_Shared_SharedRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 209;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyDeferred_Shared_SharedRpcM() = default;

    ZeCommandListAppendMemoryCopyDeferred_Shared_SharedRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyDeferred_Shared_SharedRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyDeferred_Shared_SharedRpcM>);
struct ZeCommandListAppendMemoryCopyDeferred_Shared_RemappedRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 210;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyDeferred_Shared_RemappedRpcM() = default;

    ZeCommandListAppendMemoryCopyDeferred_Shared_RemappedRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyDeferred_Shared_RemappedRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyDeferred_Shared_RemappedRpcM>);
struct ZeCommandListAppendMemoryCopyDeferred_Remapped_UsmRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 211;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyDeferred_Remapped_UsmRpcM() = default;

    ZeCommandListAppendMemoryCopyDeferred_Remapped_UsmRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyDeferred_Remapped_UsmRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyDeferred_Remapped_UsmRpcM>);
struct ZeCommandListAppendMemoryCopyDeferred_Remapped_SharedRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 212;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyDeferred_Remapped_SharedRpcM() = default;

    ZeCommandListAppendMemoryCopyDeferred_Remapped_SharedRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyDeferred_Remapped_SharedRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyDeferred_Remapped_SharedRpcM>);
struct ZeCommandListAppendMemoryCopyDeferred_Remapped_RemappedRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 213;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyDeferred_Remapped_RemappedRpcM() = default;

    ZeCommandListAppendMemoryCopyDeferred_Remapped_RemappedRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyDeferred_Remapped_RemappedRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyDeferred_Remapped_RemappedRpcM>);
struct ZeCommandListAppendMemoryCopyImmediate_Local_LocalRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 214;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyImmediate_Local_LocalRpcM() = default;

    ZeCommandListAppendMemoryCopyImmediate_Local_LocalRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyImmediate_Local_LocalRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyImmediate_Local_LocalRpcM>);
struct ZeCommandListAppendMemoryCopyImmediate_Local_UsmRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 215;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyImmediate_Local_UsmRpcM() = default;

    ZeCommandListAppendMemoryCopyImmediate_Local_UsmRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyImmediate_Local_UsmRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyImmediate_Local_UsmRpcM>);
struct ZeCommandListAppendMemoryCopyImmediate_Local_SharedRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 216;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyImmediate_Local_SharedRpcM() = default;

    ZeCommandListAppendMemoryCopyImmediate_Local_SharedRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyImmediate_Local_SharedRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyImmediate_Local_SharedRpcM>);
struct ZeCommandListAppendMemoryCopyImmediate_Usm_LocalRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 217;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyImmediate_Usm_LocalRpcM() = default;

    ZeCommandListAppendMemoryCopyImmediate_Usm_LocalRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyImmediate_Usm_LocalRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyImmediate_Usm_LocalRpcM>);
struct ZeCommandListAppendMemoryCopyImmediate_Usm_UsmRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 218;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyImmediate_Usm_UsmRpcM() = default;

    ZeCommandListAppendMemoryCopyImmediate_Usm_UsmRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyImmediate_Usm_UsmRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyImmediate_Usm_UsmRpcM>);
struct ZeCommandListAppendMemoryCopyImmediate_Usm_SharedRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 219;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyImmediate_Usm_SharedRpcM() = default;

    ZeCommandListAppendMemoryCopyImmediate_Usm_SharedRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyImmediate_Usm_SharedRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyImmediate_Usm_SharedRpcM>);
struct ZeCommandListAppendMemoryCopyImmediate_Shared_LocalRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 220;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyImmediate_Shared_LocalRpcM() = default;

    ZeCommandListAppendMemoryCopyImmediate_Shared_LocalRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyImmediate_Shared_LocalRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyImmediate_Shared_LocalRpcM>);
struct ZeCommandListAppendMemoryCopyImmediate_Shared_UsmRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 221;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyImmediate_Shared_UsmRpcM() = default;

    ZeCommandListAppendMemoryCopyImmediate_Shared_UsmRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyImmediate_Shared_UsmRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyImmediate_Shared_UsmRpcM>);
struct ZeCommandListAppendMemoryCopyImmediate_Shared_SharedRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 222;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyImmediate_Shared_SharedRpcM() = default;

    ZeCommandListAppendMemoryCopyImmediate_Shared_SharedRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyImmediate_Shared_SharedRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyImmediate_Shared_SharedRpcM>);
struct ZeCommandListAppendMemoryCopyImmediateSynchronous_Local_LocalRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 223;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits dstptr = {};          
            DynamicArgTraits srcptr = {};          
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t offsetSrcptr = 0;
        uint32_t offsetPhWaitEvents = 0;
        uint32_t countDstptr = 0;
        uint32_t countSrcptr = 0;
        uint32_t countPhWaitEvents = 0;
        void* getDstptr() {
            auto offset = 0;
            return reinterpret_cast<void*>(dynMem + offset);
        }

        const void* getSrcptr() {
            auto offset = offsetSrcptr;
            return reinterpret_cast<const void*>(dynMem + offset);
        }

        ze_event_handle_t* getPhWaitEvents() {
            auto offset = offsetPhWaitEvents;
            return reinterpret_cast<ze_event_handle_t*>(dynMem + offset);
        }


        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        offsetSrcptr = dynamicTraits.srcptr.offset;
        offsetPhWaitEvents = dynamicTraits.phWaitEvents.offset;
        countDstptr = dynamicTraits.dstptr.count;
        countSrcptr = dynamicTraits.srcptr.count;
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        alignas(8) char dynMem[];
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyImmediateSynchronous_Local_LocalRpcM() = default;

    ZeCommandListAppendMemoryCopyImmediateSynchronous_Local_LocalRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyImmediateSynchronous_Local_LocalRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.srcptr){
            memcpy(asMemcpyDstT(captures.getSrcptr()), args.srcptr, dynMemTraits.srcptr.size);
        }
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.getPhWaitEvents()), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.dstptr){
            memcpy(args.dstptr, captures.getDstptr(), dynMemTraits.dstptr.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyImmediateSynchronous_Local_LocalRpcM>);
struct ZeCommandListAppendMemoryCopyImmediateSynchronous_Local_UsmRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 224;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits dstptr = {};          
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t offsetPhWaitEvents = 0;
        uint32_t countDstptr = 0;
        uint32_t countPhWaitEvents = 0;
        void* getDstptr() {
            auto offset = 0;
            return reinterpret_cast<void*>(dynMem + offset);
        }

        ze_event_handle_t* getPhWaitEvents() {
            auto offset = offsetPhWaitEvents;
            return reinterpret_cast<ze_event_handle_t*>(dynMem + offset);
        }


        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        offsetPhWaitEvents = dynamicTraits.phWaitEvents.offset;
        countDstptr = dynamicTraits.dstptr.count;
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        alignas(8) char dynMem[];
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyImmediateSynchronous_Local_UsmRpcM() = default;

    ZeCommandListAppendMemoryCopyImmediateSynchronous_Local_UsmRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyImmediateSynchronous_Local_UsmRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.getPhWaitEvents()), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.dstptr){
            memcpy(args.dstptr, captures.getDstptr(), dynMemTraits.dstptr.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyImmediateSynchronous_Local_UsmRpcM>);
struct ZeCommandListAppendMemoryCopyImmediateSynchronous_Local_SharedRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 225;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits dstptr = {};          
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t offsetPhWaitEvents = 0;
        uint32_t countDstptr = 0;
        uint32_t countPhWaitEvents = 0;
        void* getDstptr() {
            auto offset = 0;
            return reinterpret_cast<void*>(dynMem + offset);
        }

        ze_event_handle_t* getPhWaitEvents() {
            auto offset = offsetPhWaitEvents;
            return reinterpret_cast<ze_event_handle_t*>(dynMem + offset);
        }


        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        offsetPhWaitEvents = dynamicTraits.phWaitEvents.offset;
        countDstptr = dynamicTraits.dstptr.count;
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        alignas(8) char dynMem[];
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyImmediateSynchronous_Local_SharedRpcM() = default;

    ZeCommandListAppendMemoryCopyImmediateSynchronous_Local_SharedRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyImmediateSynchronous_Local_SharedRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.getPhWaitEvents()), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.dstptr){
            memcpy(args.dstptr, captures.getDstptr(), dynMemTraits.dstptr.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyImmediateSynchronous_Local_SharedRpcM>);
struct ZeCommandListAppendMemoryCopyImmediateSynchronous_Usm_LocalRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 226;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits srcptr = {};          
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t offsetPhWaitEvents = 0;
        uint32_t countSrcptr = 0;
        uint32_t countPhWaitEvents = 0;
        const void* getSrcptr() {
            auto offset = 0;
            return reinterpret_cast<const void*>(dynMem + offset);
        }

        ze_event_handle_t* getPhWaitEvents() {
            auto offset = offsetPhWaitEvents;
            return reinterpret_cast<ze_event_handle_t*>(dynMem + offset);
        }


        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        offsetPhWaitEvents = dynamicTraits.phWaitEvents.offset;
        countSrcptr = dynamicTraits.srcptr.count;
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        alignas(8) char dynMem[];
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyImmediateSynchronous_Usm_LocalRpcM() = default;

    ZeCommandListAppendMemoryCopyImmediateSynchronous_Usm_LocalRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyImmediateSynchronous_Usm_LocalRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.srcptr){
            memcpy(asMemcpyDstT(captures.getSrcptr()), args.srcptr, dynMemTraits.srcptr.size);
        }
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.getPhWaitEvents()), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyImmediateSynchronous_Usm_LocalRpcM>);
struct ZeCommandListAppendMemoryCopyImmediateSynchronous_Usm_UsmRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 227;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyImmediateSynchronous_Usm_UsmRpcM() = default;

    ZeCommandListAppendMemoryCopyImmediateSynchronous_Usm_UsmRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyImmediateSynchronous_Usm_UsmRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyImmediateSynchronous_Usm_UsmRpcM>);
struct ZeCommandListAppendMemoryCopyImmediateSynchronous_Usm_SharedRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 228;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyImmediateSynchronous_Usm_SharedRpcM() = default;

    ZeCommandListAppendMemoryCopyImmediateSynchronous_Usm_SharedRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyImmediateSynchronous_Usm_SharedRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyImmediateSynchronous_Usm_SharedRpcM>);
struct ZeCommandListAppendMemoryCopyImmediateSynchronous_Shared_LocalRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 229;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits srcptr = {};          
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t offsetPhWaitEvents = 0;
        uint32_t countSrcptr = 0;
        uint32_t countPhWaitEvents = 0;
        const void* getSrcptr() {
            auto offset = 0;
            return reinterpret_cast<const void*>(dynMem + offset);
        }

        ze_event_handle_t* getPhWaitEvents() {
            auto offset = offsetPhWaitEvents;
            return reinterpret_cast<ze_event_handle_t*>(dynMem + offset);
        }


        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        offsetPhWaitEvents = dynamicTraits.phWaitEvents.offset;
        countSrcptr = dynamicTraits.srcptr.count;
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        alignas(8) char dynMem[];
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyImmediateSynchronous_Shared_LocalRpcM() = default;

    ZeCommandListAppendMemoryCopyImmediateSynchronous_Shared_LocalRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyImmediateSynchronous_Shared_LocalRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.srcptr){
            memcpy(asMemcpyDstT(captures.getSrcptr()), args.srcptr, dynMemTraits.srcptr.size);
        }
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.getPhWaitEvents()), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyImmediateSynchronous_Shared_LocalRpcM>);
struct ZeCommandListAppendMemoryCopyImmediateSynchronous_Shared_UsmRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 230;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyImmediateSynchronous_Shared_UsmRpcM() = default;

    ZeCommandListAppendMemoryCopyImmediateSynchronous_Shared_UsmRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyImmediateSynchronous_Shared_UsmRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyImmediateSynchronous_Shared_UsmRpcM>);
struct ZeCommandListAppendMemoryCopyImmediateSynchronous_Shared_SharedRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 231;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyImmediateSynchronous_Shared_SharedRpcM() = default;

    ZeCommandListAppendMemoryCopyImmediateSynchronous_Shared_SharedRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyImmediateSynchronous_Shared_SharedRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyImmediateSynchronous_Shared_SharedRpcM>);
struct ZeCommandListAppendMemoryCopyFromContextDeferred_Usm_UsmRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 232;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        ze_context_handle_t hContextSrc = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->hContextSrc == rhs.hContextSrc;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, ze_context_handle_t hContextSrc, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyFromContextDeferred_Usm_UsmRpcM() = default;

    ZeCommandListAppendMemoryCopyFromContextDeferred_Usm_UsmRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, ze_context_handle_t hContextSrc, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.hContextSrc = hContextSrc;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyFromContextDeferred_Usm_UsmRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, ze_context_handle_t hContextSrc, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.hContextSrc = hContextSrc;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyFromContextDeferred_Usm_UsmRpcM>);
struct ZeCommandListAppendMemoryCopyFromContextDeferred_Shared_UsmRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 233;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        ze_context_handle_t hContextSrc = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->hContextSrc == rhs.hContextSrc;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, ze_context_handle_t hContextSrc, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyFromContextDeferred_Shared_UsmRpcM() = default;

    ZeCommandListAppendMemoryCopyFromContextDeferred_Shared_UsmRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, ze_context_handle_t hContextSrc, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.hContextSrc = hContextSrc;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyFromContextDeferred_Shared_UsmRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, ze_context_handle_t hContextSrc, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.hContextSrc = hContextSrc;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyFromContextDeferred_Shared_UsmRpcM>);
struct ZeCommandListAppendMemoryCopyFromContextDeferred_Remapped_UsmRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 234;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        ze_context_handle_t hContextSrc = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->hContextSrc == rhs.hContextSrc;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, ze_context_handle_t hContextSrc, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyFromContextDeferred_Remapped_UsmRpcM() = default;

    ZeCommandListAppendMemoryCopyFromContextDeferred_Remapped_UsmRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, ze_context_handle_t hContextSrc, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.hContextSrc = hContextSrc;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyFromContextDeferred_Remapped_UsmRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, ze_context_handle_t hContextSrc, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.hContextSrc = hContextSrc;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyFromContextDeferred_Remapped_UsmRpcM>);
struct ZeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Local_UsmRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 235;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        ze_context_handle_t hContextSrc = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->hContextSrc == rhs.hContextSrc;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, ze_context_handle_t hContextSrc, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits dstptr = {};          
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t offsetPhWaitEvents = 0;
        uint32_t countDstptr = 0;
        uint32_t countPhWaitEvents = 0;
        void* getDstptr() {
            auto offset = 0;
            return reinterpret_cast<void*>(dynMem + offset);
        }

        ze_event_handle_t* getPhWaitEvents() {
            auto offset = offsetPhWaitEvents;
            return reinterpret_cast<ze_event_handle_t*>(dynMem + offset);
        }


        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        offsetPhWaitEvents = dynamicTraits.phWaitEvents.offset;
        countDstptr = dynamicTraits.dstptr.count;
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        alignas(8) char dynMem[];
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Local_UsmRpcM() = default;

    ZeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Local_UsmRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, ze_context_handle_t hContextSrc, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.hContextSrc = hContextSrc;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Local_UsmRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, ze_context_handle_t hContextSrc, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.hContextSrc = hContextSrc;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.getPhWaitEvents()), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }

    void copyToCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.dstptr){
            memcpy(args.dstptr, captures.getDstptr(), dynMemTraits.dstptr.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Local_UsmRpcM>);
struct ZeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Usm_UsmRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 236;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        ze_context_handle_t hContextSrc = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->hContextSrc == rhs.hContextSrc;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, ze_context_handle_t hContextSrc, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Usm_UsmRpcM() = default;

    ZeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Usm_UsmRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, ze_context_handle_t hContextSrc, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.hContextSrc = hContextSrc;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Usm_UsmRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, ze_context_handle_t hContextSrc, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.hContextSrc = hContextSrc;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Usm_UsmRpcM>);
struct ZeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Shared_UsmRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 237;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        ze_context_handle_t hContextSrc = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->hContextSrc == rhs.hContextSrc;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, ze_context_handle_t hContextSrc, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Shared_UsmRpcM() = default;

    ZeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Shared_UsmRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, ze_context_handle_t hContextSrc, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.hContextSrc = hContextSrc;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Shared_UsmRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, ze_context_handle_t hContextSrc, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.hContextSrc = hContextSrc;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Shared_UsmRpcM>);
struct ZeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Local_UsmRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 238;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        ze_context_handle_t hContextSrc = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->hContextSrc == rhs.hContextSrc;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, ze_context_handle_t hContextSrc, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Local_UsmRpcM() = default;

    ZeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Local_UsmRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, ze_context_handle_t hContextSrc, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.hContextSrc = hContextSrc;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Local_UsmRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, ze_context_handle_t hContextSrc, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.hContextSrc = hContextSrc;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Local_UsmRpcM>);
struct ZeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Usm_UsmRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 239;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        ze_context_handle_t hContextSrc = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->hContextSrc == rhs.hContextSrc;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, ze_context_handle_t hContextSrc, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Usm_UsmRpcM() = default;

    ZeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Usm_UsmRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, ze_context_handle_t hContextSrc, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.hContextSrc = hContextSrc;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Usm_UsmRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, ze_context_handle_t hContextSrc, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.hContextSrc = hContextSrc;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Usm_UsmRpcM>);
struct ZeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Shared_UsmRpcM {
    Cal::Rpc::RpcMessageHeader header;
    static constexpr uint16_t messageSubtype = 240;
    static constexpr float latency = 0.0;
    static constexpr CallCategory category = CallCategory::Other;


    using ReturnValueT = ze_result_t;

    struct Args {
        ze_command_list_handle_t hCommandList = {};
        void* dstptr = {};
        ze_context_handle_t hContextSrc = {};
        const void* srcptr = {};
        size_t size = {};
        ze_event_handle_t hSignalEvent = {};
        uint32_t numWaitEvents = {};
        ze_event_handle_t* phWaitEvents = {};

        bool shallowCompareEquals(const Args &rhs) const {
            bool equal = true;
            equal &= this->hCommandList == rhs.hCommandList;
            equal &= this->dstptr == rhs.dstptr;
            equal &= this->hContextSrc == rhs.hContextSrc;
            equal &= this->srcptr == rhs.srcptr;
            equal &= this->size == rhs.size;
            equal &= this->hSignalEvent == rhs.hSignalEvent;
            equal &= this->numWaitEvents == rhs.numWaitEvents;
            equal &= this->phWaitEvents == rhs.phWaitEvents;
            return equal;
        }
    }args;

    struct Captures {

        struct DynamicTraits {
            static DynamicTraits calculate(ze_command_list_handle_t hCommandList, void* dstptr, ze_context_handle_t hContextSrc, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents);
            uint32_t totalDynamicSize = 0;
            DynamicArgTraits phWaitEvents = {};          
        };

        ze_result_t ret = ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY;
        uint32_t countPhWaitEvents = 0;
        ze_event_handle_t phWaitEvents[];

        void adjustCaptureLayout(const DynamicTraits &dynamicTraits){
        countPhWaitEvents = dynamicTraits.phWaitEvents.count;
        }
        
        Captures() = default;
        Captures(const Captures &) = delete;
        Captures& operator=(const Captures& rhs) = delete;
        size_t getCaptureTotalSize() const;
        size_t getCaptureDynMemSize() const;

    }captures;
    

    ze_result_t returnValue(){
        return captures.ret;
    }

    ZeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Shared_UsmRpcM() = default;

    ZeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Shared_UsmRpcM(const Captures::DynamicTraits &dynamicTraits, ze_command_list_handle_t hCommandList, void* dstptr, ze_context_handle_t hContextSrc, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        header.subtype = messageSubtype;
        args.hCommandList = hCommandList;
        args.dstptr = dstptr;
        args.hContextSrc = hContextSrc;
        args.srcptr = srcptr;
        args.size = size;
        args.hSignalEvent = hSignalEvent;
        args.numWaitEvents = numWaitEvents;
        args.phWaitEvents = phWaitEvents;
        captures.adjustCaptureLayout(dynamicTraits);
    }
    
    static void fillWithoutCapture(ZeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Shared_UsmRpcM &message, ze_command_list_handle_t hCommandList, void* dstptr, ze_context_handle_t hContextSrc, const void* srcptr, size_t size, ze_event_handle_t hSignalEvent, uint32_t numWaitEvents, ze_event_handle_t* phWaitEvents) {
        message.header.type = Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero;
        message.header.subtype = messageSubtype;
        message.args.hCommandList = hCommandList;
        message.args.dstptr = dstptr;
        message.args.hContextSrc = hContextSrc;
        message.args.srcptr = srcptr;
        message.args.size = size;
        message.args.hSignalEvent = hSignalEvent;
        message.args.numWaitEvents = numWaitEvents;
        message.args.phWaitEvents = phWaitEvents;
    }
    

    void copyFromCaller(const Captures::DynamicTraits &dynMemTraits){
        if(args.phWaitEvents){
            memcpy(asMemcpyDstT(captures.phWaitEvents), args.phWaitEvents, dynMemTraits.phWaitEvents.size);
        }
    }
};
static_assert(std::is_standard_layout_v<ZeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Shared_UsmRpcM>);

inline const char *getRpcCallFname(const RpcCallId callId) {
    static const std::unordered_map<RpcMessageHeader::MessageUniqueIdT, std::string> options = {
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceResetRpcM::messageSubtype).id, "zesDeviceReset"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceResetExtRpcM::messageSubtype).id, "zesDeviceResetExt"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceEnumPowerDomainsRpcM::messageSubtype).id, "zesDeviceEnumPowerDomains"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceGetCardPowerDomainRpcM::messageSubtype).id, "zesDeviceGetCardPowerDomain"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesPowerGetPropertiesRpcM::messageSubtype).id, "zesPowerGetProperties"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesPowerGetEnergyCounterRpcM::messageSubtype).id, "zesPowerGetEnergyCounter"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesPowerGetLimitsRpcM::messageSubtype).id, "zesPowerGetLimits"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesPowerSetLimitsRpcM::messageSubtype).id, "zesPowerSetLimits"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesPowerGetLimitsExtRpcM::messageSubtype).id, "zesPowerGetLimitsExt"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesPowerSetLimitsExtRpcM::messageSubtype).id, "zesPowerSetLimitsExt"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesPowerGetEnergyThresholdRpcM::messageSubtype).id, "zesPowerGetEnergyThreshold"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesPowerSetEnergyThresholdRpcM::messageSubtype).id, "zesPowerSetEnergyThreshold"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceEventRegisterRpcM::messageSubtype).id, "zesDeviceEventRegister"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDriverEventListenRpcM::messageSubtype).id, "zesDriverEventListen"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDriverEventListenExRpcM::messageSubtype).id, "zesDriverEventListenEx"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceEnumTemperatureSensorsRpcM::messageSubtype).id, "zesDeviceEnumTemperatureSensors"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesTemperatureGetPropertiesRpcM::messageSubtype).id, "zesTemperatureGetProperties"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesTemperatureGetConfigRpcM::messageSubtype).id, "zesTemperatureGetConfig"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesTemperatureSetConfigRpcM::messageSubtype).id, "zesTemperatureSetConfig"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesTemperatureGetStateRpcM::messageSubtype).id, "zesTemperatureGetState"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceEnumRasErrorSetsRpcM::messageSubtype).id, "zesDeviceEnumRasErrorSets"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesRasGetPropertiesRpcM::messageSubtype).id, "zesRasGetProperties"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesRasGetConfigRpcM::messageSubtype).id, "zesRasGetConfig"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesRasSetConfigRpcM::messageSubtype).id, "zesRasSetConfig"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesRasGetStateRpcM::messageSubtype).id, "zesRasGetState"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceEnumFrequencyDomainsRpcM::messageSubtype).id, "zesDeviceEnumFrequencyDomains"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyGetPropertiesRpcM::messageSubtype).id, "zesFrequencyGetProperties"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyGetAvailableClocksRpcM::messageSubtype).id, "zesFrequencyGetAvailableClocks"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyGetRangeRpcM::messageSubtype).id, "zesFrequencyGetRange"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencySetRangeRpcM::messageSubtype).id, "zesFrequencySetRange"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyGetStateRpcM::messageSubtype).id, "zesFrequencyGetState"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyGetThrottleTimeRpcM::messageSubtype).id, "zesFrequencyGetThrottleTime"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyOcGetCapabilitiesRpcM::messageSubtype).id, "zesFrequencyOcGetCapabilities"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyOcGetVoltageTargetRpcM::messageSubtype).id, "zesFrequencyOcGetVoltageTarget"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyOcSetVoltageTargetRpcM::messageSubtype).id, "zesFrequencyOcSetVoltageTarget"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyOcSetModeRpcM::messageSubtype).id, "zesFrequencyOcSetMode"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyOcGetModeRpcM::messageSubtype).id, "zesFrequencyOcGetMode"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyOcGetIccMaxRpcM::messageSubtype).id, "zesFrequencyOcGetIccMax"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyOcSetIccMaxRpcM::messageSubtype).id, "zesFrequencyOcSetIccMax"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyOcGetTjMaxRpcM::messageSubtype).id, "zesFrequencyOcGetTjMax"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyOcSetTjMaxRpcM::messageSubtype).id, "zesFrequencyOcSetTjMax"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceEnumEngineGroupsRpcM::messageSubtype).id, "zesDeviceEnumEngineGroups"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceEnumSchedulersRpcM::messageSubtype).id, "zesDeviceEnumSchedulers"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesSchedulerGetPropertiesRpcM::messageSubtype).id, "zesSchedulerGetProperties"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesSchedulerGetCurrentModeRpcM::messageSubtype).id, "zesSchedulerGetCurrentMode"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesSchedulerGetTimeoutModePropertiesRpcM::messageSubtype).id, "zesSchedulerGetTimeoutModeProperties"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesSchedulerGetTimesliceModePropertiesRpcM::messageSubtype).id, "zesSchedulerGetTimesliceModeProperties"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesSchedulerSetTimeoutModeRpcM::messageSubtype).id, "zesSchedulerSetTimeoutMode"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesSchedulerSetTimesliceModeRpcM::messageSubtype).id, "zesSchedulerSetTimesliceMode"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesSchedulerSetExclusiveModeRpcM::messageSubtype).id, "zesSchedulerSetExclusiveMode"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesSchedulerSetComputeUnitDebugModeRpcM::messageSubtype).id, "zesSchedulerSetComputeUnitDebugMode"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesEngineGetPropertiesRpcM::messageSubtype).id, "zesEngineGetProperties"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesEngineGetActivityRpcM::messageSubtype).id, "zesEngineGetActivity"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceGetStateRpcM::messageSubtype).id, "zesDeviceGetState"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceProcessesGetStateRpcM::messageSubtype).id, "zesDeviceProcessesGetState"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDevicePciGetPropertiesRpcM::messageSubtype).id, "zesDevicePciGetProperties"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDevicePciGetStateRpcM::messageSubtype).id, "zesDevicePciGetState"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDevicePciGetBarsRpcM::messageSubtype).id, "zesDevicePciGetBars"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDevicePciGetStatsRpcM::messageSubtype).id, "zesDevicePciGetStats"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceGetPropertiesRpcM::messageSubtype).id, "zesDeviceGetProperties"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceEnumMemoryModulesRpcM::messageSubtype).id, "zesDeviceEnumMemoryModules"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceEnumPerformanceFactorDomainsRpcM::messageSubtype).id, "zesDeviceEnumPerformanceFactorDomains"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesPerformanceFactorGetPropertiesRpcM::messageSubtype).id, "zesPerformanceFactorGetProperties"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesPerformanceFactorGetConfigRpcM::messageSubtype).id, "zesPerformanceFactorGetConfig"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesPerformanceFactorSetConfigRpcM::messageSubtype).id, "zesPerformanceFactorSetConfig"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceEnumStandbyDomainsRpcM::messageSubtype).id, "zesDeviceEnumStandbyDomains"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesStandbyGetPropertiesRpcM::messageSubtype).id, "zesStandbyGetProperties"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesStandbyGetModeRpcM::messageSubtype).id, "zesStandbyGetMode"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesStandbySetModeRpcM::messageSubtype).id, "zesStandbySetMode"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeInitRpcM::messageSubtype).id, "zeInit"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryRangesBarrierRpcM::messageSubtype).id, "zeCommandListAppendMemoryRangesBarrier"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeContextSystemBarrierRpcM::messageSubtype).id, "zeContextSystemBarrier"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListCreateRpcM::messageSubtype).id, "zeCommandListCreate"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListCreateImmediateRpcM::messageSubtype).id, "zeCommandListCreateImmediate"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListDestroyRpcM::messageSubtype).id, "zeCommandListDestroy"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListCloseRpcM::messageSubtype).id, "zeCommandListClose"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListResetRpcM::messageSubtype).id, "zeCommandListReset"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendWriteGlobalTimestampRpcM::messageSubtype).id, "zeCommandListAppendWriteGlobalTimestamp"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandQueueCreateRpcM::messageSubtype).id, "zeCommandQueueCreate"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandQueueDestroyRpcM::messageSubtype).id, "zeCommandQueueDestroy"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandQueueExecuteCommandListsRpcM::messageSubtype).id, "zeCommandQueueExecuteCommandLists"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandQueueExecuteCommandListsCopyMemoryRpcHelperRpcM::messageSubtype).id, "zeCommandQueueExecuteCommandListsCopyMemoryRpcHelper"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandQueueSynchronizeRpcM::messageSubtype).id, "zeCommandQueueSynchronize"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeContextCreateRpcM::messageSubtype).id, "zeContextCreate"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeContextCreateExRpcM::messageSubtype).id, "zeContextCreateEx"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeContextDestroyRpcM::messageSubtype).id, "zeContextDestroy"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeContextGetStatusRpcM::messageSubtype).id, "zeContextGetStatus"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryFillRpcHelperUsm2UsmRpcM::messageSubtype).id, "zeCommandListAppendMemoryFillRpcHelperUsm2Usm"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryFillRpcHelperUsm2MallocRpcM::messageSubtype).id, "zeCommandListAppendMemoryFillRpcHelperUsm2Malloc"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryFillRpcHelperMalloc2UsmRpcM::messageSubtype).id, "zeCommandListAppendMemoryFillRpcHelperMalloc2Usm"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryFillRpcHelperMalloc2MallocRpcM::messageSubtype).id, "zeCommandListAppendMemoryFillRpcHelperMalloc2Malloc"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryPrefetchRpcM::messageSubtype).id, "zeCommandListAppendMemoryPrefetch"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetRpcM::messageSubtype).id, "zeDeviceGet"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetSubDevicesRpcM::messageSubtype).id, "zeDeviceGetSubDevices"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetPropertiesRpcM::messageSubtype).id, "zeDeviceGetProperties"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetComputePropertiesRpcM::messageSubtype).id, "zeDeviceGetComputeProperties"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetModulePropertiesRpcM::messageSubtype).id, "zeDeviceGetModuleProperties"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetCommandQueueGroupPropertiesRpcM::messageSubtype).id, "zeDeviceGetCommandQueueGroupProperties"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetMemoryPropertiesRpcM::messageSubtype).id, "zeDeviceGetMemoryProperties"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetMemoryAccessPropertiesRpcM::messageSubtype).id, "zeDeviceGetMemoryAccessProperties"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetCachePropertiesRpcM::messageSubtype).id, "zeDeviceGetCacheProperties"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetImagePropertiesRpcM::messageSubtype).id, "zeDeviceGetImageProperties"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetExternalMemoryPropertiesRpcM::messageSubtype).id, "zeDeviceGetExternalMemoryProperties"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetP2PPropertiesRpcM::messageSubtype).id, "zeDeviceGetP2PProperties"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceCanAccessPeerRpcM::messageSubtype).id, "zeDeviceCanAccessPeer"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetStatusRpcM::messageSubtype).id, "zeDeviceGetStatus"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetGlobalTimestampsRpcM::messageSubtype).id, "zeDeviceGetGlobalTimestamps"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceReserveCacheExtRpcM::messageSubtype).id, "zeDeviceReserveCacheExt"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceSetCacheAdviceExtRpcM::messageSubtype).id, "zeDeviceSetCacheAdviceExt"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDriverGetRpcM::messageSubtype).id, "zeDriverGet"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDriverGetApiVersionRpcM::messageSubtype).id, "zeDriverGetApiVersion"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDriverGetPropertiesRpcM::messageSubtype).id, "zeDriverGetProperties"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDriverGetIpcPropertiesRpcM::messageSubtype).id, "zeDriverGetIpcProperties"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDriverGetExtensionPropertiesRpcM::messageSubtype).id, "zeDriverGetExtensionProperties"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventPoolCreateRpcM::messageSubtype).id, "zeEventPoolCreate"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventPoolDestroyRpcM::messageSubtype).id, "zeEventPoolDestroy"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventCreateRpcM::messageSubtype).id, "zeEventCreate"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventDestroyRpcM::messageSubtype).id, "zeEventDestroy"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventPoolGetIpcHandleRpcM::messageSubtype).id, "zeEventPoolGetIpcHandle"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventPoolOpenIpcHandleRpcM::messageSubtype).id, "zeEventPoolOpenIpcHandle"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventPoolCloseIpcHandleRpcM::messageSubtype).id, "zeEventPoolCloseIpcHandle"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendBarrierRpcM::messageSubtype).id, "zeCommandListAppendBarrier"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendSignalEventRpcM::messageSubtype).id, "zeCommandListAppendSignalEvent"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendWaitOnEventsRpcM::messageSubtype).id, "zeCommandListAppendWaitOnEvents"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventHostSignalRpcM::messageSubtype).id, "zeEventHostSignal"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventHostSynchronizeRpcM::messageSubtype).id, "zeEventHostSynchronize"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventQueryStatusRpcM::messageSubtype).id, "zeEventQueryStatus"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendEventResetRpcM::messageSubtype).id, "zeCommandListAppendEventReset"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventHostResetRpcM::messageSubtype).id, "zeEventHostReset"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventQueryKernelTimestampRpcM::messageSubtype).id, "zeEventQueryKernelTimestamp"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendQueryKernelTimestampsRpcM::messageSubtype).id, "zeCommandListAppendQueryKernelTimestamps"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventQueryTimestampsExpRpcM::messageSubtype).id, "zeEventQueryTimestampsExp"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventQueryKernelTimestampsExtRpcHelperRpcM::messageSubtype).id, "zeEventQueryKernelTimestampsExtRpcHelper"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFabricVertexGetExpRpcM::messageSubtype).id, "zeFabricVertexGetExp"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFabricVertexGetSubVerticesExpRpcM::messageSubtype).id, "zeFabricVertexGetSubVerticesExp"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFabricVertexGetPropertiesExpRpcM::messageSubtype).id, "zeFabricVertexGetPropertiesExp"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFabricVertexGetDeviceExpRpcM::messageSubtype).id, "zeFabricVertexGetDeviceExp"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetFabricVertexExpRpcM::messageSubtype).id, "zeDeviceGetFabricVertexExp"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFabricEdgeGetExpRpcM::messageSubtype).id, "zeFabricEdgeGetExp"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFabricEdgeGetVerticesExpRpcM::messageSubtype).id, "zeFabricEdgeGetVerticesExp"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFabricEdgeGetPropertiesExpRpcM::messageSubtype).id, "zeFabricEdgeGetPropertiesExp"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFenceCreateRpcM::messageSubtype).id, "zeFenceCreate"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFenceDestroyRpcM::messageSubtype).id, "zeFenceDestroy"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFenceHostSynchronizeRpcM::messageSubtype).id, "zeFenceHostSynchronize"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFenceQueryStatusRpcM::messageSubtype).id, "zeFenceQueryStatus"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFenceResetRpcM::messageSubtype).id, "zeFenceReset"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelSetGlobalOffsetExpRpcM::messageSubtype).id, "zeKernelSetGlobalOffsetExp"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeImageGetPropertiesRpcM::messageSubtype).id, "zeImageGetProperties"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeImageCreateRpcM::messageSubtype).id, "zeImageCreate"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeImageDestroyRpcM::messageSubtype).id, "zeImageDestroy"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelSchedulingHintExpRpcM::messageSubtype).id, "zeKernelSchedulingHintExp"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeModuleInspectLinkageExtRpcM::messageSubtype).id, "zeModuleInspectLinkageExt"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeMemAllocSharedRpcM::messageSubtype).id, "zeMemAllocShared"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeMemAllocDeviceRpcM::messageSubtype).id, "zeMemAllocDevice"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeMemAllocHostRpcM::messageSubtype).id, "zeMemAllocHost"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeMemFreeRpcM::messageSubtype).id, "zeMemFree"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeMemGetAllocPropertiesRpcM::messageSubtype).id, "zeMemGetAllocProperties"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeMemGetAddressRangeRpcM::messageSubtype).id, "zeMemGetAddressRange"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeMemGetIpcHandleRpcM::messageSubtype).id, "zeMemGetIpcHandle"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeMemOpenIpcHandleRpcM::messageSubtype).id, "zeMemOpenIpcHandle"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeMemCloseIpcHandleRpcM::messageSubtype).id, "zeMemCloseIpcHandle"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZexMemGetIpcHandlesRpcM::messageSubtype).id, "zexMemGetIpcHandles"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZexMemOpenIpcHandlesRpcM::messageSubtype).id, "zexMemOpenIpcHandles"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeMemFreeExtRpcM::messageSubtype).id, "zeMemFreeExt"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeModuleCreateRpcM::messageSubtype).id, "zeModuleCreate"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeModuleDestroyRpcM::messageSubtype).id, "zeModuleDestroy"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeModuleDynamicLinkRpcM::messageSubtype).id, "zeModuleDynamicLink"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeModuleBuildLogDestroyRpcM::messageSubtype).id, "zeModuleBuildLogDestroy"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeModuleBuildLogGetStringRpcM::messageSubtype).id, "zeModuleBuildLogGetString"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeModuleGetNativeBinaryRpcM::messageSubtype).id, "zeModuleGetNativeBinary"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeModuleGetGlobalPointerRpcM::messageSubtype).id, "zeModuleGetGlobalPointer"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeModuleGetKernelNamesRpcHelperRpcM::messageSubtype).id, "zeModuleGetKernelNamesRpcHelper"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeModuleGetPropertiesRpcM::messageSubtype).id, "zeModuleGetProperties"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelCreateRpcM::messageSubtype).id, "zeKernelCreate"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelDestroyRpcM::messageSubtype).id, "zeKernelDestroy"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeModuleGetFunctionPointerRpcM::messageSubtype).id, "zeModuleGetFunctionPointer"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelSetGroupSizeRpcM::messageSubtype).id, "zeKernelSetGroupSize"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelSuggestGroupSizeRpcM::messageSubtype).id, "zeKernelSuggestGroupSize"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelSuggestMaxCooperativeGroupCountRpcM::messageSubtype).id, "zeKernelSuggestMaxCooperativeGroupCount"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelSetArgumentValueRpcM::messageSubtype).id, "zeKernelSetArgumentValue"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelSetIndirectAccessRpcM::messageSubtype).id, "zeKernelSetIndirectAccess"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelGetIndirectAccessRpcM::messageSubtype).id, "zeKernelGetIndirectAccess"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelSetCacheConfigRpcM::messageSubtype).id, "zeKernelSetCacheConfig"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelGetPropertiesRpcM::messageSubtype).id, "zeKernelGetProperties"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelGetNameRpcM::messageSubtype).id, "zeKernelGetName"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendLaunchKernelRpcM::messageSubtype).id, "zeCommandListAppendLaunchKernel"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendLaunchCooperativeKernelRpcM::messageSubtype).id, "zeCommandListAppendLaunchCooperativeKernel"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendLaunchKernelIndirectRpcM::messageSubtype).id, "zeCommandListAppendLaunchKernelIndirect"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendLaunchMultipleKernelsIndirectRpcM::messageSubtype).id, "zeCommandListAppendLaunchMultipleKernelsIndirect"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListHostSynchronizeRpcM::messageSubtype).id, "zeCommandListHostSynchronize"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDevicePciGetPropertiesExtRpcM::messageSubtype).id, "zeDevicePciGetPropertiesExt"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeContextMakeMemoryResidentRpcM::messageSubtype).id, "zeContextMakeMemoryResident"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeContextEvictMemoryRpcM::messageSubtype).id, "zeContextEvictMemory"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeVirtualMemReserveRpcM::messageSubtype).id, "zeVirtualMemReserve"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeVirtualMemFreeRpcM::messageSubtype).id, "zeVirtualMemFree"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeVirtualMemQueryPageSizeRpcM::messageSubtype).id, "zeVirtualMemQueryPageSize"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZePhysicalMemCreateRpcM::messageSubtype).id, "zePhysicalMemCreate"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZePhysicalMemDestroyRpcM::messageSubtype).id, "zePhysicalMemDestroy"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeVirtualMemMapRpcM::messageSubtype).id, "zeVirtualMemMap"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeVirtualMemUnmapRpcM::messageSubtype).id, "zeVirtualMemUnmap"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeVirtualMemSetAccessAttributeRpcM::messageSubtype).id, "zeVirtualMemSetAccessAttribute"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeVirtualMemGetAccessAttributeRpcM::messageSubtype).id, "zeVirtualMemGetAccessAttribute"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZexDriverImportExternalPointerRpcM::messageSubtype).id, "zexDriverImportExternalPointer"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZexDriverReleaseImportedPointerRpcM::messageSubtype).id, "zexDriverReleaseImportedPointer"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZexDriverGetHostPointerBaseAddressRpcM::messageSubtype).id, "zexDriverGetHostPointerBaseAddress"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyDeferred_Usm_UsmRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyDeferred_Usm_Usm"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyDeferred_Usm_SharedRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyDeferred_Usm_Shared"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyDeferred_Usm_RemappedRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyDeferred_Usm_Remapped"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyDeferred_Shared_UsmRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyDeferred_Shared_Usm"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyDeferred_Shared_SharedRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyDeferred_Shared_Shared"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyDeferred_Shared_RemappedRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyDeferred_Shared_Remapped"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyDeferred_Remapped_UsmRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyDeferred_Remapped_Usm"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyDeferred_Remapped_SharedRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyDeferred_Remapped_Shared"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyDeferred_Remapped_RemappedRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyDeferred_Remapped_Remapped"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediate_Local_LocalRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyImmediate_Local_Local"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediate_Local_UsmRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyImmediate_Local_Usm"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediate_Local_SharedRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyImmediate_Local_Shared"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediate_Usm_LocalRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyImmediate_Usm_Local"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediate_Usm_UsmRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyImmediate_Usm_Usm"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediate_Usm_SharedRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyImmediate_Usm_Shared"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediate_Shared_LocalRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyImmediate_Shared_Local"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediate_Shared_UsmRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyImmediate_Shared_Usm"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediate_Shared_SharedRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyImmediate_Shared_Shared"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediateSynchronous_Local_LocalRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyImmediateSynchronous_Local_Local"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediateSynchronous_Local_UsmRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyImmediateSynchronous_Local_Usm"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediateSynchronous_Local_SharedRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyImmediateSynchronous_Local_Shared"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediateSynchronous_Usm_LocalRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyImmediateSynchronous_Usm_Local"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediateSynchronous_Usm_UsmRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyImmediateSynchronous_Usm_Usm"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediateSynchronous_Usm_SharedRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyImmediateSynchronous_Usm_Shared"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediateSynchronous_Shared_LocalRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyImmediateSynchronous_Shared_Local"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediateSynchronous_Shared_UsmRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyImmediateSynchronous_Shared_Usm"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediateSynchronous_Shared_SharedRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyImmediateSynchronous_Shared_Shared"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyFromContextDeferred_Usm_UsmRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyFromContextDeferred_Usm_Usm"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyFromContextDeferred_Shared_UsmRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyFromContextDeferred_Shared_Usm"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyFromContextDeferred_Remapped_UsmRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyFromContextDeferred_Remapped_Usm"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Local_UsmRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Local_Usm"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Usm_UsmRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Usm_Usm"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Shared_UsmRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Shared_Usm"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Local_UsmRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Local_Usm"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Usm_UsmRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Usm_Usm"),
        std::pair<RpcMessageHeader::MessageUniqueIdT, std::string>(RpcCallId(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Shared_UsmRpcM::messageSubtype).id, "zeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Shared_Usm"),
    };

    auto it = options.find(callId.id);
    if(it == options.end()) {
        return "UNKNOWN";
    }
    return it->second.c_str();
}

inline auto getRpcCallId(const std::string &funcName) {
    using RetT = RpcCallId;
    static const std::unordered_map<std::string, RetT> options = {
        std::pair<std::string, RetT>("zesDeviceReset", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceResetRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesDeviceResetExt", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceResetExtRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesDeviceEnumPowerDomains", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceEnumPowerDomainsRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesDeviceGetCardPowerDomain", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceGetCardPowerDomainRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesPowerGetProperties", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesPowerGetPropertiesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesPowerGetEnergyCounter", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesPowerGetEnergyCounterRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesPowerGetLimits", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesPowerGetLimitsRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesPowerSetLimits", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesPowerSetLimitsRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesPowerGetLimitsExt", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesPowerGetLimitsExtRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesPowerSetLimitsExt", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesPowerSetLimitsExtRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesPowerGetEnergyThreshold", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesPowerGetEnergyThresholdRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesPowerSetEnergyThreshold", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesPowerSetEnergyThresholdRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesDeviceEventRegister", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceEventRegisterRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesDriverEventListen", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDriverEventListenRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesDriverEventListenEx", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDriverEventListenExRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesDeviceEnumTemperatureSensors", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceEnumTemperatureSensorsRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesTemperatureGetProperties", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesTemperatureGetPropertiesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesTemperatureGetConfig", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesTemperatureGetConfigRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesTemperatureSetConfig", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesTemperatureSetConfigRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesTemperatureGetState", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesTemperatureGetStateRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesDeviceEnumRasErrorSets", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceEnumRasErrorSetsRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesRasGetProperties", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesRasGetPropertiesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesRasGetConfig", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesRasGetConfigRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesRasSetConfig", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesRasSetConfigRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesRasGetState", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesRasGetStateRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesDeviceEnumFrequencyDomains", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceEnumFrequencyDomainsRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesFrequencyGetProperties", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyGetPropertiesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesFrequencyGetAvailableClocks", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyGetAvailableClocksRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesFrequencyGetRange", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyGetRangeRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesFrequencySetRange", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencySetRangeRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesFrequencyGetState", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyGetStateRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesFrequencyGetThrottleTime", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyGetThrottleTimeRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesFrequencyOcGetCapabilities", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyOcGetCapabilitiesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesFrequencyOcGetVoltageTarget", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyOcGetVoltageTargetRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesFrequencyOcSetVoltageTarget", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyOcSetVoltageTargetRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesFrequencyOcSetMode", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyOcSetModeRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesFrequencyOcGetMode", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyOcGetModeRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesFrequencyOcGetIccMax", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyOcGetIccMaxRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesFrequencyOcSetIccMax", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyOcSetIccMaxRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesFrequencyOcGetTjMax", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyOcGetTjMaxRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesFrequencyOcSetTjMax", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyOcSetTjMaxRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesDeviceEnumEngineGroups", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceEnumEngineGroupsRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesDeviceEnumSchedulers", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceEnumSchedulersRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesSchedulerGetProperties", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesSchedulerGetPropertiesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesSchedulerGetCurrentMode", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesSchedulerGetCurrentModeRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesSchedulerGetTimeoutModeProperties", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesSchedulerGetTimeoutModePropertiesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesSchedulerGetTimesliceModeProperties", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesSchedulerGetTimesliceModePropertiesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesSchedulerSetTimeoutMode", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesSchedulerSetTimeoutModeRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesSchedulerSetTimesliceMode", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesSchedulerSetTimesliceModeRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesSchedulerSetExclusiveMode", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesSchedulerSetExclusiveModeRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesSchedulerSetComputeUnitDebugMode", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesSchedulerSetComputeUnitDebugModeRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesEngineGetProperties", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesEngineGetPropertiesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesEngineGetActivity", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesEngineGetActivityRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesDeviceGetState", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceGetStateRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesDeviceProcessesGetState", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceProcessesGetStateRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesDevicePciGetProperties", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDevicePciGetPropertiesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesDevicePciGetState", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDevicePciGetStateRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesDevicePciGetBars", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDevicePciGetBarsRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesDevicePciGetStats", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDevicePciGetStatsRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesDeviceGetProperties", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceGetPropertiesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesDeviceEnumMemoryModules", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceEnumMemoryModulesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesDeviceEnumPerformanceFactorDomains", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceEnumPerformanceFactorDomainsRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesPerformanceFactorGetProperties", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesPerformanceFactorGetPropertiesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesPerformanceFactorGetConfig", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesPerformanceFactorGetConfigRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesPerformanceFactorSetConfig", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesPerformanceFactorSetConfigRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesDeviceEnumStandbyDomains", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceEnumStandbyDomainsRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesStandbyGetProperties", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesStandbyGetPropertiesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesStandbyGetMode", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesStandbyGetModeRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zesStandbySetMode", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesStandbySetModeRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeInit", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeInitRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryRangesBarrier", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryRangesBarrierRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeContextSystemBarrier", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeContextSystemBarrierRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListCreate", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListCreateRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListCreateImmediate", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListCreateImmediateRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListDestroy", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListDestroyRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListClose", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListCloseRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListReset", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListResetRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendWriteGlobalTimestamp", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendWriteGlobalTimestampRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandQueueCreate", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandQueueCreateRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandQueueDestroy", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandQueueDestroyRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandQueueExecuteCommandLists", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandQueueExecuteCommandListsRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandQueueExecuteCommandListsCopyMemoryRpcHelper", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandQueueExecuteCommandListsCopyMemoryRpcHelperRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandQueueSynchronize", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandQueueSynchronizeRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeContextCreate", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeContextCreateRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeContextCreateEx", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeContextCreateExRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeContextDestroy", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeContextDestroyRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeContextGetStatus", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeContextGetStatusRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryFillRpcHelperUsm2Usm", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryFillRpcHelperUsm2UsmRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryFillRpcHelperUsm2Malloc", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryFillRpcHelperUsm2MallocRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryFillRpcHelperMalloc2Usm", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryFillRpcHelperMalloc2UsmRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryFillRpcHelperMalloc2Malloc", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryFillRpcHelperMalloc2MallocRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryPrefetch", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryPrefetchRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeDeviceGet", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeDeviceGetSubDevices", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetSubDevicesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeDeviceGetProperties", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetPropertiesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeDeviceGetComputeProperties", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetComputePropertiesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeDeviceGetModuleProperties", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetModulePropertiesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeDeviceGetCommandQueueGroupProperties", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetCommandQueueGroupPropertiesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeDeviceGetMemoryProperties", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetMemoryPropertiesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeDeviceGetMemoryAccessProperties", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetMemoryAccessPropertiesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeDeviceGetCacheProperties", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetCachePropertiesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeDeviceGetImageProperties", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetImagePropertiesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeDeviceGetExternalMemoryProperties", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetExternalMemoryPropertiesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeDeviceGetP2PProperties", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetP2PPropertiesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeDeviceCanAccessPeer", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceCanAccessPeerRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeDeviceGetStatus", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetStatusRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeDeviceGetGlobalTimestamps", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetGlobalTimestampsRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeDeviceReserveCacheExt", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceReserveCacheExtRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeDeviceSetCacheAdviceExt", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceSetCacheAdviceExtRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeDriverGet", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDriverGetRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeDriverGetApiVersion", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDriverGetApiVersionRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeDriverGetProperties", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDriverGetPropertiesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeDriverGetIpcProperties", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDriverGetIpcPropertiesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeDriverGetExtensionProperties", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDriverGetExtensionPropertiesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeEventPoolCreate", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventPoolCreateRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeEventPoolDestroy", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventPoolDestroyRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeEventCreate", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventCreateRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeEventDestroy", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventDestroyRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeEventPoolGetIpcHandle", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventPoolGetIpcHandleRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeEventPoolOpenIpcHandle", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventPoolOpenIpcHandleRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeEventPoolCloseIpcHandle", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventPoolCloseIpcHandleRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendBarrier", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendBarrierRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendSignalEvent", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendSignalEventRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendWaitOnEvents", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendWaitOnEventsRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeEventHostSignal", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventHostSignalRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeEventHostSynchronize", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventHostSynchronizeRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeEventQueryStatus", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventQueryStatusRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendEventReset", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendEventResetRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeEventHostReset", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventHostResetRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeEventQueryKernelTimestamp", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventQueryKernelTimestampRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendQueryKernelTimestamps", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendQueryKernelTimestampsRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeEventQueryTimestampsExp", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventQueryTimestampsExpRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeEventQueryKernelTimestampsExtRpcHelper", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventQueryKernelTimestampsExtRpcHelperRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeFabricVertexGetExp", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFabricVertexGetExpRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeFabricVertexGetSubVerticesExp", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFabricVertexGetSubVerticesExpRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeFabricVertexGetPropertiesExp", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFabricVertexGetPropertiesExpRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeFabricVertexGetDeviceExp", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFabricVertexGetDeviceExpRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeDeviceGetFabricVertexExp", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetFabricVertexExpRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeFabricEdgeGetExp", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFabricEdgeGetExpRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeFabricEdgeGetVerticesExp", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFabricEdgeGetVerticesExpRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeFabricEdgeGetPropertiesExp", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFabricEdgeGetPropertiesExpRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeFenceCreate", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFenceCreateRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeFenceDestroy", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFenceDestroyRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeFenceHostSynchronize", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFenceHostSynchronizeRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeFenceQueryStatus", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFenceQueryStatusRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeFenceReset", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFenceResetRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeKernelSetGlobalOffsetExp", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelSetGlobalOffsetExpRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeImageGetProperties", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeImageGetPropertiesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeImageCreate", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeImageCreateRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeImageDestroy", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeImageDestroyRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeKernelSchedulingHintExp", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelSchedulingHintExpRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeModuleInspectLinkageExt", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeModuleInspectLinkageExtRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeMemAllocShared", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeMemAllocSharedRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeMemAllocDevice", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeMemAllocDeviceRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeMemAllocHost", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeMemAllocHostRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeMemFree", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeMemFreeRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeMemGetAllocProperties", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeMemGetAllocPropertiesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeMemGetAddressRange", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeMemGetAddressRangeRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeMemGetIpcHandle", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeMemGetIpcHandleRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeMemOpenIpcHandle", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeMemOpenIpcHandleRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeMemCloseIpcHandle", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeMemCloseIpcHandleRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zexMemGetIpcHandles", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZexMemGetIpcHandlesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zexMemOpenIpcHandles", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZexMemOpenIpcHandlesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeMemFreeExt", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeMemFreeExtRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeModuleCreate", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeModuleCreateRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeModuleDestroy", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeModuleDestroyRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeModuleDynamicLink", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeModuleDynamicLinkRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeModuleBuildLogDestroy", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeModuleBuildLogDestroyRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeModuleBuildLogGetString", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeModuleBuildLogGetStringRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeModuleGetNativeBinary", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeModuleGetNativeBinaryRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeModuleGetGlobalPointer", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeModuleGetGlobalPointerRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeModuleGetKernelNamesRpcHelper", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeModuleGetKernelNamesRpcHelperRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeModuleGetProperties", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeModuleGetPropertiesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeKernelCreate", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelCreateRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeKernelDestroy", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelDestroyRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeModuleGetFunctionPointer", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeModuleGetFunctionPointerRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeKernelSetGroupSize", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelSetGroupSizeRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeKernelSuggestGroupSize", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelSuggestGroupSizeRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeKernelSuggestMaxCooperativeGroupCount", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelSuggestMaxCooperativeGroupCountRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeKernelSetArgumentValue", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelSetArgumentValueRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeKernelSetIndirectAccess", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelSetIndirectAccessRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeKernelGetIndirectAccess", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelGetIndirectAccessRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeKernelSetCacheConfig", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelSetCacheConfigRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeKernelGetProperties", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelGetPropertiesRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeKernelGetName", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelGetNameRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendLaunchKernel", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendLaunchKernelRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendLaunchCooperativeKernel", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendLaunchCooperativeKernelRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendLaunchKernelIndirect", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendLaunchKernelIndirectRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendLaunchMultipleKernelsIndirect", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendLaunchMultipleKernelsIndirectRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListHostSynchronize", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListHostSynchronizeRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeDevicePciGetPropertiesExt", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDevicePciGetPropertiesExtRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeContextMakeMemoryResident", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeContextMakeMemoryResidentRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeContextEvictMemory", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeContextEvictMemoryRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeVirtualMemReserve", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeVirtualMemReserveRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeVirtualMemFree", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeVirtualMemFreeRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeVirtualMemQueryPageSize", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeVirtualMemQueryPageSizeRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zePhysicalMemCreate", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZePhysicalMemCreateRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zePhysicalMemDestroy", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZePhysicalMemDestroyRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeVirtualMemMap", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeVirtualMemMapRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeVirtualMemUnmap", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeVirtualMemUnmapRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeVirtualMemSetAccessAttribute", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeVirtualMemSetAccessAttributeRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeVirtualMemGetAccessAttribute", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeVirtualMemGetAccessAttributeRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zexDriverImportExternalPointer", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZexDriverImportExternalPointerRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zexDriverReleaseImportedPointer", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZexDriverReleaseImportedPointerRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zexDriverGetHostPointerBaseAddress", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZexDriverGetHostPointerBaseAddressRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyDeferred_Usm_Usm", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyDeferred_Usm_UsmRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyDeferred_Usm_Shared", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyDeferred_Usm_SharedRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyDeferred_Usm_Remapped", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyDeferred_Usm_RemappedRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyDeferred_Shared_Usm", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyDeferred_Shared_UsmRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyDeferred_Shared_Shared", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyDeferred_Shared_SharedRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyDeferred_Shared_Remapped", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyDeferred_Shared_RemappedRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyDeferred_Remapped_Usm", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyDeferred_Remapped_UsmRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyDeferred_Remapped_Shared", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyDeferred_Remapped_SharedRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyDeferred_Remapped_Remapped", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyDeferred_Remapped_RemappedRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyImmediate_Local_Local", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediate_Local_LocalRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyImmediate_Local_Usm", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediate_Local_UsmRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyImmediate_Local_Shared", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediate_Local_SharedRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyImmediate_Usm_Local", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediate_Usm_LocalRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyImmediate_Usm_Usm", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediate_Usm_UsmRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyImmediate_Usm_Shared", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediate_Usm_SharedRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyImmediate_Shared_Local", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediate_Shared_LocalRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyImmediate_Shared_Usm", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediate_Shared_UsmRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyImmediate_Shared_Shared", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediate_Shared_SharedRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyImmediateSynchronous_Local_Local", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediateSynchronous_Local_LocalRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyImmediateSynchronous_Local_Usm", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediateSynchronous_Local_UsmRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyImmediateSynchronous_Local_Shared", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediateSynchronous_Local_SharedRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyImmediateSynchronous_Usm_Local", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediateSynchronous_Usm_LocalRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyImmediateSynchronous_Usm_Usm", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediateSynchronous_Usm_UsmRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyImmediateSynchronous_Usm_Shared", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediateSynchronous_Usm_SharedRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyImmediateSynchronous_Shared_Local", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediateSynchronous_Shared_LocalRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyImmediateSynchronous_Shared_Usm", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediateSynchronous_Shared_UsmRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyImmediateSynchronous_Shared_Shared", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediateSynchronous_Shared_SharedRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyFromContextDeferred_Usm_Usm", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyFromContextDeferred_Usm_UsmRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyFromContextDeferred_Shared_Usm", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyFromContextDeferred_Shared_UsmRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyFromContextDeferred_Remapped_Usm", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyFromContextDeferred_Remapped_UsmRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Local_Usm", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Local_UsmRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Usm_Usm", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Usm_UsmRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Shared_Usm", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Shared_UsmRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Local_Usm", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Local_UsmRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Usm_Usm", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Usm_UsmRpcM::messageSubtype)),
        std::pair<std::string, RetT>("zeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Shared_Usm", RetT(Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Shared_UsmRpcM::messageSubtype)),
    };

    auto it = options.find(funcName);
    if(it == options.end()) {
        return std::optional<RetT>(std::nullopt);
    }
    return std::optional<RetT>(it->second);
}

namespace RpcCallIds {
static constexpr RpcCallId zesDeviceReset = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceResetRpcM::messageSubtype};
static constexpr RpcCallId zesDeviceResetExt = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceResetExtRpcM::messageSubtype};
static constexpr RpcCallId zesDeviceEnumPowerDomains = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceEnumPowerDomainsRpcM::messageSubtype};
static constexpr RpcCallId zesDeviceGetCardPowerDomain = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceGetCardPowerDomainRpcM::messageSubtype};
static constexpr RpcCallId zesPowerGetProperties = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesPowerGetPropertiesRpcM::messageSubtype};
static constexpr RpcCallId zesPowerGetEnergyCounter = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesPowerGetEnergyCounterRpcM::messageSubtype};
static constexpr RpcCallId zesPowerGetLimits = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesPowerGetLimitsRpcM::messageSubtype};
static constexpr RpcCallId zesPowerSetLimits = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesPowerSetLimitsRpcM::messageSubtype};
static constexpr RpcCallId zesPowerGetLimitsExt = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesPowerGetLimitsExtRpcM::messageSubtype};
static constexpr RpcCallId zesPowerSetLimitsExt = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesPowerSetLimitsExtRpcM::messageSubtype};
static constexpr RpcCallId zesPowerGetEnergyThreshold = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesPowerGetEnergyThresholdRpcM::messageSubtype};
static constexpr RpcCallId zesPowerSetEnergyThreshold = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesPowerSetEnergyThresholdRpcM::messageSubtype};
static constexpr RpcCallId zesDeviceEventRegister = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceEventRegisterRpcM::messageSubtype};
static constexpr RpcCallId zesDriverEventListen = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDriverEventListenRpcM::messageSubtype};
static constexpr RpcCallId zesDriverEventListenEx = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDriverEventListenExRpcM::messageSubtype};
static constexpr RpcCallId zesDeviceEnumTemperatureSensors = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceEnumTemperatureSensorsRpcM::messageSubtype};
static constexpr RpcCallId zesTemperatureGetProperties = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesTemperatureGetPropertiesRpcM::messageSubtype};
static constexpr RpcCallId zesTemperatureGetConfig = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesTemperatureGetConfigRpcM::messageSubtype};
static constexpr RpcCallId zesTemperatureSetConfig = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesTemperatureSetConfigRpcM::messageSubtype};
static constexpr RpcCallId zesTemperatureGetState = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesTemperatureGetStateRpcM::messageSubtype};
static constexpr RpcCallId zesDeviceEnumRasErrorSets = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceEnumRasErrorSetsRpcM::messageSubtype};
static constexpr RpcCallId zesRasGetProperties = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesRasGetPropertiesRpcM::messageSubtype};
static constexpr RpcCallId zesRasGetConfig = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesRasGetConfigRpcM::messageSubtype};
static constexpr RpcCallId zesRasSetConfig = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesRasSetConfigRpcM::messageSubtype};
static constexpr RpcCallId zesRasGetState = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesRasGetStateRpcM::messageSubtype};
static constexpr RpcCallId zesDeviceEnumFrequencyDomains = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceEnumFrequencyDomainsRpcM::messageSubtype};
static constexpr RpcCallId zesFrequencyGetProperties = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyGetPropertiesRpcM::messageSubtype};
static constexpr RpcCallId zesFrequencyGetAvailableClocks = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyGetAvailableClocksRpcM::messageSubtype};
static constexpr RpcCallId zesFrequencyGetRange = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyGetRangeRpcM::messageSubtype};
static constexpr RpcCallId zesFrequencySetRange = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencySetRangeRpcM::messageSubtype};
static constexpr RpcCallId zesFrequencyGetState = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyGetStateRpcM::messageSubtype};
static constexpr RpcCallId zesFrequencyGetThrottleTime = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyGetThrottleTimeRpcM::messageSubtype};
static constexpr RpcCallId zesFrequencyOcGetCapabilities = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyOcGetCapabilitiesRpcM::messageSubtype};
static constexpr RpcCallId zesFrequencyOcGetVoltageTarget = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyOcGetVoltageTargetRpcM::messageSubtype};
static constexpr RpcCallId zesFrequencyOcSetVoltageTarget = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyOcSetVoltageTargetRpcM::messageSubtype};
static constexpr RpcCallId zesFrequencyOcSetMode = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyOcSetModeRpcM::messageSubtype};
static constexpr RpcCallId zesFrequencyOcGetMode = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyOcGetModeRpcM::messageSubtype};
static constexpr RpcCallId zesFrequencyOcGetIccMax = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyOcGetIccMaxRpcM::messageSubtype};
static constexpr RpcCallId zesFrequencyOcSetIccMax = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyOcSetIccMaxRpcM::messageSubtype};
static constexpr RpcCallId zesFrequencyOcGetTjMax = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyOcGetTjMaxRpcM::messageSubtype};
static constexpr RpcCallId zesFrequencyOcSetTjMax = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesFrequencyOcSetTjMaxRpcM::messageSubtype};
static constexpr RpcCallId zesDeviceEnumEngineGroups = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceEnumEngineGroupsRpcM::messageSubtype};
static constexpr RpcCallId zesDeviceEnumSchedulers = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceEnumSchedulersRpcM::messageSubtype};
static constexpr RpcCallId zesSchedulerGetProperties = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesSchedulerGetPropertiesRpcM::messageSubtype};
static constexpr RpcCallId zesSchedulerGetCurrentMode = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesSchedulerGetCurrentModeRpcM::messageSubtype};
static constexpr RpcCallId zesSchedulerGetTimeoutModeProperties = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesSchedulerGetTimeoutModePropertiesRpcM::messageSubtype};
static constexpr RpcCallId zesSchedulerGetTimesliceModeProperties = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesSchedulerGetTimesliceModePropertiesRpcM::messageSubtype};
static constexpr RpcCallId zesSchedulerSetTimeoutMode = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesSchedulerSetTimeoutModeRpcM::messageSubtype};
static constexpr RpcCallId zesSchedulerSetTimesliceMode = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesSchedulerSetTimesliceModeRpcM::messageSubtype};
static constexpr RpcCallId zesSchedulerSetExclusiveMode = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesSchedulerSetExclusiveModeRpcM::messageSubtype};
static constexpr RpcCallId zesSchedulerSetComputeUnitDebugMode = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesSchedulerSetComputeUnitDebugModeRpcM::messageSubtype};
static constexpr RpcCallId zesEngineGetProperties = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesEngineGetPropertiesRpcM::messageSubtype};
static constexpr RpcCallId zesEngineGetActivity = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesEngineGetActivityRpcM::messageSubtype};
static constexpr RpcCallId zesDeviceGetState = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceGetStateRpcM::messageSubtype};
static constexpr RpcCallId zesDeviceProcessesGetState = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceProcessesGetStateRpcM::messageSubtype};
static constexpr RpcCallId zesDevicePciGetProperties = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDevicePciGetPropertiesRpcM::messageSubtype};
static constexpr RpcCallId zesDevicePciGetState = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDevicePciGetStateRpcM::messageSubtype};
static constexpr RpcCallId zesDevicePciGetBars = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDevicePciGetBarsRpcM::messageSubtype};
static constexpr RpcCallId zesDevicePciGetStats = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDevicePciGetStatsRpcM::messageSubtype};
static constexpr RpcCallId zesDeviceGetProperties = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceGetPropertiesRpcM::messageSubtype};
static constexpr RpcCallId zesDeviceEnumMemoryModules = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceEnumMemoryModulesRpcM::messageSubtype};
static constexpr RpcCallId zesDeviceEnumPerformanceFactorDomains = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceEnumPerformanceFactorDomainsRpcM::messageSubtype};
static constexpr RpcCallId zesPerformanceFactorGetProperties = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesPerformanceFactorGetPropertiesRpcM::messageSubtype};
static constexpr RpcCallId zesPerformanceFactorGetConfig = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesPerformanceFactorGetConfigRpcM::messageSubtype};
static constexpr RpcCallId zesPerformanceFactorSetConfig = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesPerformanceFactorSetConfigRpcM::messageSubtype};
static constexpr RpcCallId zesDeviceEnumStandbyDomains = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesDeviceEnumStandbyDomainsRpcM::messageSubtype};
static constexpr RpcCallId zesStandbyGetProperties = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesStandbyGetPropertiesRpcM::messageSubtype};
static constexpr RpcCallId zesStandbyGetMode = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesStandbyGetModeRpcM::messageSubtype};
static constexpr RpcCallId zesStandbySetMode = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZesStandbySetModeRpcM::messageSubtype};
static constexpr RpcCallId zeInit = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeInitRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryRangesBarrier = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryRangesBarrierRpcM::messageSubtype};
static constexpr RpcCallId zeContextSystemBarrier = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeContextSystemBarrierRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListCreate = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListCreateRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListCreateImmediate = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListCreateImmediateRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListDestroy = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListDestroyRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListClose = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListCloseRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListReset = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListResetRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendWriteGlobalTimestamp = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendWriteGlobalTimestampRpcM::messageSubtype};
static constexpr RpcCallId zeCommandQueueCreate = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandQueueCreateRpcM::messageSubtype};
static constexpr RpcCallId zeCommandQueueDestroy = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandQueueDestroyRpcM::messageSubtype};
static constexpr RpcCallId zeCommandQueueExecuteCommandLists = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandQueueExecuteCommandListsRpcM::messageSubtype};
static constexpr RpcCallId zeCommandQueueExecuteCommandListsCopyMemoryRpcHelper = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandQueueExecuteCommandListsCopyMemoryRpcHelperRpcM::messageSubtype};
static constexpr RpcCallId zeCommandQueueSynchronize = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandQueueSynchronizeRpcM::messageSubtype};
static constexpr RpcCallId zeContextCreate = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeContextCreateRpcM::messageSubtype};
static constexpr RpcCallId zeContextCreateEx = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeContextCreateExRpcM::messageSubtype};
static constexpr RpcCallId zeContextDestroy = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeContextDestroyRpcM::messageSubtype};
static constexpr RpcCallId zeContextGetStatus = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeContextGetStatusRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryFillRpcHelperUsm2Usm = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryFillRpcHelperUsm2UsmRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryFillRpcHelperUsm2Malloc = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryFillRpcHelperUsm2MallocRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryFillRpcHelperMalloc2Usm = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryFillRpcHelperMalloc2UsmRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryFillRpcHelperMalloc2Malloc = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryFillRpcHelperMalloc2MallocRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryPrefetch = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryPrefetchRpcM::messageSubtype};
static constexpr RpcCallId zeDeviceGet = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetRpcM::messageSubtype};
static constexpr RpcCallId zeDeviceGetSubDevices = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetSubDevicesRpcM::messageSubtype};
static constexpr RpcCallId zeDeviceGetProperties = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetPropertiesRpcM::messageSubtype};
static constexpr RpcCallId zeDeviceGetComputeProperties = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetComputePropertiesRpcM::messageSubtype};
static constexpr RpcCallId zeDeviceGetModuleProperties = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetModulePropertiesRpcM::messageSubtype};
static constexpr RpcCallId zeDeviceGetCommandQueueGroupProperties = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetCommandQueueGroupPropertiesRpcM::messageSubtype};
static constexpr RpcCallId zeDeviceGetMemoryProperties = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetMemoryPropertiesRpcM::messageSubtype};
static constexpr RpcCallId zeDeviceGetMemoryAccessProperties = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetMemoryAccessPropertiesRpcM::messageSubtype};
static constexpr RpcCallId zeDeviceGetCacheProperties = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetCachePropertiesRpcM::messageSubtype};
static constexpr RpcCallId zeDeviceGetImageProperties = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetImagePropertiesRpcM::messageSubtype};
static constexpr RpcCallId zeDeviceGetExternalMemoryProperties = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetExternalMemoryPropertiesRpcM::messageSubtype};
static constexpr RpcCallId zeDeviceGetP2PProperties = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetP2PPropertiesRpcM::messageSubtype};
static constexpr RpcCallId zeDeviceCanAccessPeer = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceCanAccessPeerRpcM::messageSubtype};
static constexpr RpcCallId zeDeviceGetStatus = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetStatusRpcM::messageSubtype};
static constexpr RpcCallId zeDeviceGetGlobalTimestamps = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetGlobalTimestampsRpcM::messageSubtype};
static constexpr RpcCallId zeDeviceReserveCacheExt = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceReserveCacheExtRpcM::messageSubtype};
static constexpr RpcCallId zeDeviceSetCacheAdviceExt = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceSetCacheAdviceExtRpcM::messageSubtype};
static constexpr RpcCallId zeDriverGet = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDriverGetRpcM::messageSubtype};
static constexpr RpcCallId zeDriverGetApiVersion = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDriverGetApiVersionRpcM::messageSubtype};
static constexpr RpcCallId zeDriverGetProperties = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDriverGetPropertiesRpcM::messageSubtype};
static constexpr RpcCallId zeDriverGetIpcProperties = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDriverGetIpcPropertiesRpcM::messageSubtype};
static constexpr RpcCallId zeDriverGetExtensionProperties = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDriverGetExtensionPropertiesRpcM::messageSubtype};
static constexpr RpcCallId zeEventPoolCreate = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventPoolCreateRpcM::messageSubtype};
static constexpr RpcCallId zeEventPoolDestroy = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventPoolDestroyRpcM::messageSubtype};
static constexpr RpcCallId zeEventCreate = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventCreateRpcM::messageSubtype};
static constexpr RpcCallId zeEventDestroy = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventDestroyRpcM::messageSubtype};
static constexpr RpcCallId zeEventPoolGetIpcHandle = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventPoolGetIpcHandleRpcM::messageSubtype};
static constexpr RpcCallId zeEventPoolOpenIpcHandle = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventPoolOpenIpcHandleRpcM::messageSubtype};
static constexpr RpcCallId zeEventPoolCloseIpcHandle = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventPoolCloseIpcHandleRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendBarrier = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendBarrierRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendSignalEvent = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendSignalEventRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendWaitOnEvents = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendWaitOnEventsRpcM::messageSubtype};
static constexpr RpcCallId zeEventHostSignal = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventHostSignalRpcM::messageSubtype};
static constexpr RpcCallId zeEventHostSynchronize = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventHostSynchronizeRpcM::messageSubtype};
static constexpr RpcCallId zeEventQueryStatus = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventQueryStatusRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendEventReset = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendEventResetRpcM::messageSubtype};
static constexpr RpcCallId zeEventHostReset = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventHostResetRpcM::messageSubtype};
static constexpr RpcCallId zeEventQueryKernelTimestamp = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventQueryKernelTimestampRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendQueryKernelTimestamps = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendQueryKernelTimestampsRpcM::messageSubtype};
static constexpr RpcCallId zeEventQueryTimestampsExp = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventQueryTimestampsExpRpcM::messageSubtype};
static constexpr RpcCallId zeEventQueryKernelTimestampsExtRpcHelper = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeEventQueryKernelTimestampsExtRpcHelperRpcM::messageSubtype};
static constexpr RpcCallId zeFabricVertexGetExp = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFabricVertexGetExpRpcM::messageSubtype};
static constexpr RpcCallId zeFabricVertexGetSubVerticesExp = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFabricVertexGetSubVerticesExpRpcM::messageSubtype};
static constexpr RpcCallId zeFabricVertexGetPropertiesExp = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFabricVertexGetPropertiesExpRpcM::messageSubtype};
static constexpr RpcCallId zeFabricVertexGetDeviceExp = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFabricVertexGetDeviceExpRpcM::messageSubtype};
static constexpr RpcCallId zeDeviceGetFabricVertexExp = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDeviceGetFabricVertexExpRpcM::messageSubtype};
static constexpr RpcCallId zeFabricEdgeGetExp = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFabricEdgeGetExpRpcM::messageSubtype};
static constexpr RpcCallId zeFabricEdgeGetVerticesExp = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFabricEdgeGetVerticesExpRpcM::messageSubtype};
static constexpr RpcCallId zeFabricEdgeGetPropertiesExp = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFabricEdgeGetPropertiesExpRpcM::messageSubtype};
static constexpr RpcCallId zeFenceCreate = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFenceCreateRpcM::messageSubtype};
static constexpr RpcCallId zeFenceDestroy = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFenceDestroyRpcM::messageSubtype};
static constexpr RpcCallId zeFenceHostSynchronize = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFenceHostSynchronizeRpcM::messageSubtype};
static constexpr RpcCallId zeFenceQueryStatus = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFenceQueryStatusRpcM::messageSubtype};
static constexpr RpcCallId zeFenceReset = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeFenceResetRpcM::messageSubtype};
static constexpr RpcCallId zeKernelSetGlobalOffsetExp = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelSetGlobalOffsetExpRpcM::messageSubtype};
static constexpr RpcCallId zeImageGetProperties = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeImageGetPropertiesRpcM::messageSubtype};
static constexpr RpcCallId zeImageCreate = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeImageCreateRpcM::messageSubtype};
static constexpr RpcCallId zeImageDestroy = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeImageDestroyRpcM::messageSubtype};
static constexpr RpcCallId zeKernelSchedulingHintExp = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelSchedulingHintExpRpcM::messageSubtype};
static constexpr RpcCallId zeModuleInspectLinkageExt = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeModuleInspectLinkageExtRpcM::messageSubtype};
static constexpr RpcCallId zeMemAllocShared = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeMemAllocSharedRpcM::messageSubtype};
static constexpr RpcCallId zeMemAllocDevice = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeMemAllocDeviceRpcM::messageSubtype};
static constexpr RpcCallId zeMemAllocHost = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeMemAllocHostRpcM::messageSubtype};
static constexpr RpcCallId zeMemFree = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeMemFreeRpcM::messageSubtype};
static constexpr RpcCallId zeMemGetAllocProperties = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeMemGetAllocPropertiesRpcM::messageSubtype};
static constexpr RpcCallId zeMemGetAddressRange = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeMemGetAddressRangeRpcM::messageSubtype};
static constexpr RpcCallId zeMemGetIpcHandle = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeMemGetIpcHandleRpcM::messageSubtype};
static constexpr RpcCallId zeMemOpenIpcHandle = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeMemOpenIpcHandleRpcM::messageSubtype};
static constexpr RpcCallId zeMemCloseIpcHandle = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeMemCloseIpcHandleRpcM::messageSubtype};
static constexpr RpcCallId zexMemGetIpcHandles = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZexMemGetIpcHandlesRpcM::messageSubtype};
static constexpr RpcCallId zexMemOpenIpcHandles = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZexMemOpenIpcHandlesRpcM::messageSubtype};
static constexpr RpcCallId zeMemFreeExt = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeMemFreeExtRpcM::messageSubtype};
static constexpr RpcCallId zeModuleCreate = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeModuleCreateRpcM::messageSubtype};
static constexpr RpcCallId zeModuleDestroy = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeModuleDestroyRpcM::messageSubtype};
static constexpr RpcCallId zeModuleDynamicLink = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeModuleDynamicLinkRpcM::messageSubtype};
static constexpr RpcCallId zeModuleBuildLogDestroy = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeModuleBuildLogDestroyRpcM::messageSubtype};
static constexpr RpcCallId zeModuleBuildLogGetString = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeModuleBuildLogGetStringRpcM::messageSubtype};
static constexpr RpcCallId zeModuleGetNativeBinary = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeModuleGetNativeBinaryRpcM::messageSubtype};
static constexpr RpcCallId zeModuleGetGlobalPointer = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeModuleGetGlobalPointerRpcM::messageSubtype};
static constexpr RpcCallId zeModuleGetKernelNamesRpcHelper = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeModuleGetKernelNamesRpcHelperRpcM::messageSubtype};
static constexpr RpcCallId zeModuleGetProperties = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeModuleGetPropertiesRpcM::messageSubtype};
static constexpr RpcCallId zeKernelCreate = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelCreateRpcM::messageSubtype};
static constexpr RpcCallId zeKernelDestroy = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelDestroyRpcM::messageSubtype};
static constexpr RpcCallId zeModuleGetFunctionPointer = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeModuleGetFunctionPointerRpcM::messageSubtype};
static constexpr RpcCallId zeKernelSetGroupSize = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelSetGroupSizeRpcM::messageSubtype};
static constexpr RpcCallId zeKernelSuggestGroupSize = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelSuggestGroupSizeRpcM::messageSubtype};
static constexpr RpcCallId zeKernelSuggestMaxCooperativeGroupCount = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelSuggestMaxCooperativeGroupCountRpcM::messageSubtype};
static constexpr RpcCallId zeKernelSetArgumentValue = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelSetArgumentValueRpcM::messageSubtype};
static constexpr RpcCallId zeKernelSetIndirectAccess = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelSetIndirectAccessRpcM::messageSubtype};
static constexpr RpcCallId zeKernelGetIndirectAccess = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelGetIndirectAccessRpcM::messageSubtype};
static constexpr RpcCallId zeKernelSetCacheConfig = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelSetCacheConfigRpcM::messageSubtype};
static constexpr RpcCallId zeKernelGetProperties = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelGetPropertiesRpcM::messageSubtype};
static constexpr RpcCallId zeKernelGetName = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeKernelGetNameRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendLaunchKernel = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendLaunchKernelRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendLaunchCooperativeKernel = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendLaunchCooperativeKernelRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendLaunchKernelIndirect = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendLaunchKernelIndirectRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendLaunchMultipleKernelsIndirect = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendLaunchMultipleKernelsIndirectRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListHostSynchronize = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListHostSynchronizeRpcM::messageSubtype};
static constexpr RpcCallId zeDevicePciGetPropertiesExt = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeDevicePciGetPropertiesExtRpcM::messageSubtype};
static constexpr RpcCallId zeContextMakeMemoryResident = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeContextMakeMemoryResidentRpcM::messageSubtype};
static constexpr RpcCallId zeContextEvictMemory = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeContextEvictMemoryRpcM::messageSubtype};
static constexpr RpcCallId zeVirtualMemReserve = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeVirtualMemReserveRpcM::messageSubtype};
static constexpr RpcCallId zeVirtualMemFree = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeVirtualMemFreeRpcM::messageSubtype};
static constexpr RpcCallId zeVirtualMemQueryPageSize = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeVirtualMemQueryPageSizeRpcM::messageSubtype};
static constexpr RpcCallId zePhysicalMemCreate = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZePhysicalMemCreateRpcM::messageSubtype};
static constexpr RpcCallId zePhysicalMemDestroy = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZePhysicalMemDestroyRpcM::messageSubtype};
static constexpr RpcCallId zeVirtualMemMap = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeVirtualMemMapRpcM::messageSubtype};
static constexpr RpcCallId zeVirtualMemUnmap = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeVirtualMemUnmapRpcM::messageSubtype};
static constexpr RpcCallId zeVirtualMemSetAccessAttribute = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeVirtualMemSetAccessAttributeRpcM::messageSubtype};
static constexpr RpcCallId zeVirtualMemGetAccessAttribute = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeVirtualMemGetAccessAttributeRpcM::messageSubtype};
static constexpr RpcCallId zexDriverImportExternalPointer = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZexDriverImportExternalPointerRpcM::messageSubtype};
static constexpr RpcCallId zexDriverReleaseImportedPointer = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZexDriverReleaseImportedPointerRpcM::messageSubtype};
static constexpr RpcCallId zexDriverGetHostPointerBaseAddress = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZexDriverGetHostPointerBaseAddressRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyDeferred_Usm_Usm = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyDeferred_Usm_UsmRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyDeferred_Usm_Shared = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyDeferred_Usm_SharedRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyDeferred_Usm_Remapped = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyDeferred_Usm_RemappedRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyDeferred_Shared_Usm = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyDeferred_Shared_UsmRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyDeferred_Shared_Shared = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyDeferred_Shared_SharedRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyDeferred_Shared_Remapped = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyDeferred_Shared_RemappedRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyDeferred_Remapped_Usm = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyDeferred_Remapped_UsmRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyDeferred_Remapped_Shared = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyDeferred_Remapped_SharedRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyDeferred_Remapped_Remapped = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyDeferred_Remapped_RemappedRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyImmediate_Local_Local = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediate_Local_LocalRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyImmediate_Local_Usm = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediate_Local_UsmRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyImmediate_Local_Shared = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediate_Local_SharedRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyImmediate_Usm_Local = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediate_Usm_LocalRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyImmediate_Usm_Usm = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediate_Usm_UsmRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyImmediate_Usm_Shared = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediate_Usm_SharedRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyImmediate_Shared_Local = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediate_Shared_LocalRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyImmediate_Shared_Usm = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediate_Shared_UsmRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyImmediate_Shared_Shared = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediate_Shared_SharedRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyImmediateSynchronous_Local_Local = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediateSynchronous_Local_LocalRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyImmediateSynchronous_Local_Usm = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediateSynchronous_Local_UsmRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyImmediateSynchronous_Local_Shared = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediateSynchronous_Local_SharedRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyImmediateSynchronous_Usm_Local = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediateSynchronous_Usm_LocalRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyImmediateSynchronous_Usm_Usm = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediateSynchronous_Usm_UsmRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyImmediateSynchronous_Usm_Shared = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediateSynchronous_Usm_SharedRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyImmediateSynchronous_Shared_Local = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediateSynchronous_Shared_LocalRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyImmediateSynchronous_Shared_Usm = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediateSynchronous_Shared_UsmRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyImmediateSynchronous_Shared_Shared = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyImmediateSynchronous_Shared_SharedRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyFromContextDeferred_Usm_Usm = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyFromContextDeferred_Usm_UsmRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyFromContextDeferred_Shared_Usm = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyFromContextDeferred_Shared_UsmRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyFromContextDeferred_Remapped_Usm = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyFromContextDeferred_Remapped_UsmRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Local_Usm = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Local_UsmRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Usm_Usm = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Usm_UsmRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Shared_Usm = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Shared_UsmRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Local_Usm = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Local_UsmRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Usm_Usm = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Usm_UsmRpcM::messageSubtype};
static constexpr RpcCallId zeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Shared_Usm = {Cal::Rpc::RpcMessageHeader::messageTypeRpcLevelZero, ZeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Shared_UsmRpcM::messageSubtype};
} // namespace RpcCallIds

namespace RpcCallMessageTypes {
using zesDeviceReset = ZesDeviceResetRpcM;
using zesDeviceResetExt = ZesDeviceResetExtRpcM;
using zesDeviceEnumPowerDomains = ZesDeviceEnumPowerDomainsRpcM;
using zesDeviceGetCardPowerDomain = ZesDeviceGetCardPowerDomainRpcM;
using zesPowerGetProperties = ZesPowerGetPropertiesRpcM;
using zesPowerGetEnergyCounter = ZesPowerGetEnergyCounterRpcM;
using zesPowerGetLimits = ZesPowerGetLimitsRpcM;
using zesPowerSetLimits = ZesPowerSetLimitsRpcM;
using zesPowerGetLimitsExt = ZesPowerGetLimitsExtRpcM;
using zesPowerSetLimitsExt = ZesPowerSetLimitsExtRpcM;
using zesPowerGetEnergyThreshold = ZesPowerGetEnergyThresholdRpcM;
using zesPowerSetEnergyThreshold = ZesPowerSetEnergyThresholdRpcM;
using zesDeviceEventRegister = ZesDeviceEventRegisterRpcM;
using zesDriverEventListen = ZesDriverEventListenRpcM;
using zesDriverEventListenEx = ZesDriverEventListenExRpcM;
using zesDeviceEnumTemperatureSensors = ZesDeviceEnumTemperatureSensorsRpcM;
using zesTemperatureGetProperties = ZesTemperatureGetPropertiesRpcM;
using zesTemperatureGetConfig = ZesTemperatureGetConfigRpcM;
using zesTemperatureSetConfig = ZesTemperatureSetConfigRpcM;
using zesTemperatureGetState = ZesTemperatureGetStateRpcM;
using zesDeviceEnumRasErrorSets = ZesDeviceEnumRasErrorSetsRpcM;
using zesRasGetProperties = ZesRasGetPropertiesRpcM;
using zesRasGetConfig = ZesRasGetConfigRpcM;
using zesRasSetConfig = ZesRasSetConfigRpcM;
using zesRasGetState = ZesRasGetStateRpcM;
using zesDeviceEnumFrequencyDomains = ZesDeviceEnumFrequencyDomainsRpcM;
using zesFrequencyGetProperties = ZesFrequencyGetPropertiesRpcM;
using zesFrequencyGetAvailableClocks = ZesFrequencyGetAvailableClocksRpcM;
using zesFrequencyGetRange = ZesFrequencyGetRangeRpcM;
using zesFrequencySetRange = ZesFrequencySetRangeRpcM;
using zesFrequencyGetState = ZesFrequencyGetStateRpcM;
using zesFrequencyGetThrottleTime = ZesFrequencyGetThrottleTimeRpcM;
using zesFrequencyOcGetCapabilities = ZesFrequencyOcGetCapabilitiesRpcM;
using zesFrequencyOcGetVoltageTarget = ZesFrequencyOcGetVoltageTargetRpcM;
using zesFrequencyOcSetVoltageTarget = ZesFrequencyOcSetVoltageTargetRpcM;
using zesFrequencyOcSetMode = ZesFrequencyOcSetModeRpcM;
using zesFrequencyOcGetMode = ZesFrequencyOcGetModeRpcM;
using zesFrequencyOcGetIccMax = ZesFrequencyOcGetIccMaxRpcM;
using zesFrequencyOcSetIccMax = ZesFrequencyOcSetIccMaxRpcM;
using zesFrequencyOcGetTjMax = ZesFrequencyOcGetTjMaxRpcM;
using zesFrequencyOcSetTjMax = ZesFrequencyOcSetTjMaxRpcM;
using zesDeviceEnumEngineGroups = ZesDeviceEnumEngineGroupsRpcM;
using zesDeviceEnumSchedulers = ZesDeviceEnumSchedulersRpcM;
using zesSchedulerGetProperties = ZesSchedulerGetPropertiesRpcM;
using zesSchedulerGetCurrentMode = ZesSchedulerGetCurrentModeRpcM;
using zesSchedulerGetTimeoutModeProperties = ZesSchedulerGetTimeoutModePropertiesRpcM;
using zesSchedulerGetTimesliceModeProperties = ZesSchedulerGetTimesliceModePropertiesRpcM;
using zesSchedulerSetTimeoutMode = ZesSchedulerSetTimeoutModeRpcM;
using zesSchedulerSetTimesliceMode = ZesSchedulerSetTimesliceModeRpcM;
using zesSchedulerSetExclusiveMode = ZesSchedulerSetExclusiveModeRpcM;
using zesSchedulerSetComputeUnitDebugMode = ZesSchedulerSetComputeUnitDebugModeRpcM;
using zesEngineGetProperties = ZesEngineGetPropertiesRpcM;
using zesEngineGetActivity = ZesEngineGetActivityRpcM;
using zesDeviceGetState = ZesDeviceGetStateRpcM;
using zesDeviceProcessesGetState = ZesDeviceProcessesGetStateRpcM;
using zesDevicePciGetProperties = ZesDevicePciGetPropertiesRpcM;
using zesDevicePciGetState = ZesDevicePciGetStateRpcM;
using zesDevicePciGetBars = ZesDevicePciGetBarsRpcM;
using zesDevicePciGetStats = ZesDevicePciGetStatsRpcM;
using zesDeviceGetProperties = ZesDeviceGetPropertiesRpcM;
using zesDeviceEnumMemoryModules = ZesDeviceEnumMemoryModulesRpcM;
using zesDeviceEnumPerformanceFactorDomains = ZesDeviceEnumPerformanceFactorDomainsRpcM;
using zesPerformanceFactorGetProperties = ZesPerformanceFactorGetPropertiesRpcM;
using zesPerformanceFactorGetConfig = ZesPerformanceFactorGetConfigRpcM;
using zesPerformanceFactorSetConfig = ZesPerformanceFactorSetConfigRpcM;
using zesDeviceEnumStandbyDomains = ZesDeviceEnumStandbyDomainsRpcM;
using zesStandbyGetProperties = ZesStandbyGetPropertiesRpcM;
using zesStandbyGetMode = ZesStandbyGetModeRpcM;
using zesStandbySetMode = ZesStandbySetModeRpcM;
using zeInit = ZeInitRpcM;
using zeCommandListAppendMemoryRangesBarrier = ZeCommandListAppendMemoryRangesBarrierRpcM;
using zeContextSystemBarrier = ZeContextSystemBarrierRpcM;
using zeCommandListCreate = ZeCommandListCreateRpcM;
using zeCommandListCreateImmediate = ZeCommandListCreateImmediateRpcM;
using zeCommandListDestroy = ZeCommandListDestroyRpcM;
using zeCommandListClose = ZeCommandListCloseRpcM;
using zeCommandListReset = ZeCommandListResetRpcM;
using zeCommandListAppendWriteGlobalTimestamp = ZeCommandListAppendWriteGlobalTimestampRpcM;
using zeCommandQueueCreate = ZeCommandQueueCreateRpcM;
using zeCommandQueueDestroy = ZeCommandQueueDestroyRpcM;
using zeCommandQueueExecuteCommandLists = ZeCommandQueueExecuteCommandListsRpcM;
using zeCommandQueueExecuteCommandListsCopyMemoryRpcHelper = ZeCommandQueueExecuteCommandListsCopyMemoryRpcHelperRpcM;
using zeCommandQueueSynchronize = ZeCommandQueueSynchronizeRpcM;
using zeContextCreate = ZeContextCreateRpcM;
using zeContextCreateEx = ZeContextCreateExRpcM;
using zeContextDestroy = ZeContextDestroyRpcM;
using zeContextGetStatus = ZeContextGetStatusRpcM;
using zeCommandListAppendMemoryFillRpcHelperUsm2Usm = ZeCommandListAppendMemoryFillRpcHelperUsm2UsmRpcM;
using zeCommandListAppendMemoryFillRpcHelperUsm2Malloc = ZeCommandListAppendMemoryFillRpcHelperUsm2MallocRpcM;
using zeCommandListAppendMemoryFillRpcHelperMalloc2Usm = ZeCommandListAppendMemoryFillRpcHelperMalloc2UsmRpcM;
using zeCommandListAppendMemoryFillRpcHelperMalloc2Malloc = ZeCommandListAppendMemoryFillRpcHelperMalloc2MallocRpcM;
using zeCommandListAppendMemoryPrefetch = ZeCommandListAppendMemoryPrefetchRpcM;
using zeDeviceGet = ZeDeviceGetRpcM;
using zeDeviceGetSubDevices = ZeDeviceGetSubDevicesRpcM;
using zeDeviceGetProperties = ZeDeviceGetPropertiesRpcM;
using zeDeviceGetComputeProperties = ZeDeviceGetComputePropertiesRpcM;
using zeDeviceGetModuleProperties = ZeDeviceGetModulePropertiesRpcM;
using zeDeviceGetCommandQueueGroupProperties = ZeDeviceGetCommandQueueGroupPropertiesRpcM;
using zeDeviceGetMemoryProperties = ZeDeviceGetMemoryPropertiesRpcM;
using zeDeviceGetMemoryAccessProperties = ZeDeviceGetMemoryAccessPropertiesRpcM;
using zeDeviceGetCacheProperties = ZeDeviceGetCachePropertiesRpcM;
using zeDeviceGetImageProperties = ZeDeviceGetImagePropertiesRpcM;
using zeDeviceGetExternalMemoryProperties = ZeDeviceGetExternalMemoryPropertiesRpcM;
using zeDeviceGetP2PProperties = ZeDeviceGetP2PPropertiesRpcM;
using zeDeviceCanAccessPeer = ZeDeviceCanAccessPeerRpcM;
using zeDeviceGetStatus = ZeDeviceGetStatusRpcM;
using zeDeviceGetGlobalTimestamps = ZeDeviceGetGlobalTimestampsRpcM;
using zeDeviceReserveCacheExt = ZeDeviceReserveCacheExtRpcM;
using zeDeviceSetCacheAdviceExt = ZeDeviceSetCacheAdviceExtRpcM;
using zeDriverGet = ZeDriverGetRpcM;
using zeDriverGetApiVersion = ZeDriverGetApiVersionRpcM;
using zeDriverGetProperties = ZeDriverGetPropertiesRpcM;
using zeDriverGetIpcProperties = ZeDriverGetIpcPropertiesRpcM;
using zeDriverGetExtensionProperties = ZeDriverGetExtensionPropertiesRpcM;
using zeEventPoolCreate = ZeEventPoolCreateRpcM;
using zeEventPoolDestroy = ZeEventPoolDestroyRpcM;
using zeEventCreate = ZeEventCreateRpcM;
using zeEventDestroy = ZeEventDestroyRpcM;
using zeEventPoolGetIpcHandle = ZeEventPoolGetIpcHandleRpcM;
using zeEventPoolOpenIpcHandle = ZeEventPoolOpenIpcHandleRpcM;
using zeEventPoolCloseIpcHandle = ZeEventPoolCloseIpcHandleRpcM;
using zeCommandListAppendBarrier = ZeCommandListAppendBarrierRpcM;
using zeCommandListAppendSignalEvent = ZeCommandListAppendSignalEventRpcM;
using zeCommandListAppendWaitOnEvents = ZeCommandListAppendWaitOnEventsRpcM;
using zeEventHostSignal = ZeEventHostSignalRpcM;
using zeEventHostSynchronize = ZeEventHostSynchronizeRpcM;
using zeEventQueryStatus = ZeEventQueryStatusRpcM;
using zeCommandListAppendEventReset = ZeCommandListAppendEventResetRpcM;
using zeEventHostReset = ZeEventHostResetRpcM;
using zeEventQueryKernelTimestamp = ZeEventQueryKernelTimestampRpcM;
using zeCommandListAppendQueryKernelTimestamps = ZeCommandListAppendQueryKernelTimestampsRpcM;
using zeEventQueryTimestampsExp = ZeEventQueryTimestampsExpRpcM;
using zeEventQueryKernelTimestampsExtRpcHelper = ZeEventQueryKernelTimestampsExtRpcHelperRpcM;
using zeFabricVertexGetExp = ZeFabricVertexGetExpRpcM;
using zeFabricVertexGetSubVerticesExp = ZeFabricVertexGetSubVerticesExpRpcM;
using zeFabricVertexGetPropertiesExp = ZeFabricVertexGetPropertiesExpRpcM;
using zeFabricVertexGetDeviceExp = ZeFabricVertexGetDeviceExpRpcM;
using zeDeviceGetFabricVertexExp = ZeDeviceGetFabricVertexExpRpcM;
using zeFabricEdgeGetExp = ZeFabricEdgeGetExpRpcM;
using zeFabricEdgeGetVerticesExp = ZeFabricEdgeGetVerticesExpRpcM;
using zeFabricEdgeGetPropertiesExp = ZeFabricEdgeGetPropertiesExpRpcM;
using zeFenceCreate = ZeFenceCreateRpcM;
using zeFenceDestroy = ZeFenceDestroyRpcM;
using zeFenceHostSynchronize = ZeFenceHostSynchronizeRpcM;
using zeFenceQueryStatus = ZeFenceQueryStatusRpcM;
using zeFenceReset = ZeFenceResetRpcM;
using zeKernelSetGlobalOffsetExp = ZeKernelSetGlobalOffsetExpRpcM;
using zeImageGetProperties = ZeImageGetPropertiesRpcM;
using zeImageCreate = ZeImageCreateRpcM;
using zeImageDestroy = ZeImageDestroyRpcM;
using zeKernelSchedulingHintExp = ZeKernelSchedulingHintExpRpcM;
using zeModuleInspectLinkageExt = ZeModuleInspectLinkageExtRpcM;
using zeMemAllocShared = ZeMemAllocSharedRpcM;
using zeMemAllocDevice = ZeMemAllocDeviceRpcM;
using zeMemAllocHost = ZeMemAllocHostRpcM;
using zeMemFree = ZeMemFreeRpcM;
using zeMemGetAllocProperties = ZeMemGetAllocPropertiesRpcM;
using zeMemGetAddressRange = ZeMemGetAddressRangeRpcM;
using zeMemGetIpcHandle = ZeMemGetIpcHandleRpcM;
using zeMemOpenIpcHandle = ZeMemOpenIpcHandleRpcM;
using zeMemCloseIpcHandle = ZeMemCloseIpcHandleRpcM;
using zexMemGetIpcHandles = ZexMemGetIpcHandlesRpcM;
using zexMemOpenIpcHandles = ZexMemOpenIpcHandlesRpcM;
using zeMemFreeExt = ZeMemFreeExtRpcM;
using zeModuleCreate = ZeModuleCreateRpcM;
using zeModuleDestroy = ZeModuleDestroyRpcM;
using zeModuleDynamicLink = ZeModuleDynamicLinkRpcM;
using zeModuleBuildLogDestroy = ZeModuleBuildLogDestroyRpcM;
using zeModuleBuildLogGetString = ZeModuleBuildLogGetStringRpcM;
using zeModuleGetNativeBinary = ZeModuleGetNativeBinaryRpcM;
using zeModuleGetGlobalPointer = ZeModuleGetGlobalPointerRpcM;
using zeModuleGetKernelNamesRpcHelper = ZeModuleGetKernelNamesRpcHelperRpcM;
using zeModuleGetProperties = ZeModuleGetPropertiesRpcM;
using zeKernelCreate = ZeKernelCreateRpcM;
using zeKernelDestroy = ZeKernelDestroyRpcM;
using zeModuleGetFunctionPointer = ZeModuleGetFunctionPointerRpcM;
using zeKernelSetGroupSize = ZeKernelSetGroupSizeRpcM;
using zeKernelSuggestGroupSize = ZeKernelSuggestGroupSizeRpcM;
using zeKernelSuggestMaxCooperativeGroupCount = ZeKernelSuggestMaxCooperativeGroupCountRpcM;
using zeKernelSetArgumentValue = ZeKernelSetArgumentValueRpcM;
using zeKernelSetIndirectAccess = ZeKernelSetIndirectAccessRpcM;
using zeKernelGetIndirectAccess = ZeKernelGetIndirectAccessRpcM;
using zeKernelSetCacheConfig = ZeKernelSetCacheConfigRpcM;
using zeKernelGetProperties = ZeKernelGetPropertiesRpcM;
using zeKernelGetName = ZeKernelGetNameRpcM;
using zeCommandListAppendLaunchKernel = ZeCommandListAppendLaunchKernelRpcM;
using zeCommandListAppendLaunchCooperativeKernel = ZeCommandListAppendLaunchCooperativeKernelRpcM;
using zeCommandListAppendLaunchKernelIndirect = ZeCommandListAppendLaunchKernelIndirectRpcM;
using zeCommandListAppendLaunchMultipleKernelsIndirect = ZeCommandListAppendLaunchMultipleKernelsIndirectRpcM;
using zeCommandListHostSynchronize = ZeCommandListHostSynchronizeRpcM;
using zeDevicePciGetPropertiesExt = ZeDevicePciGetPropertiesExtRpcM;
using zeContextMakeMemoryResident = ZeContextMakeMemoryResidentRpcM;
using zeContextEvictMemory = ZeContextEvictMemoryRpcM;
using zeVirtualMemReserve = ZeVirtualMemReserveRpcM;
using zeVirtualMemFree = ZeVirtualMemFreeRpcM;
using zeVirtualMemQueryPageSize = ZeVirtualMemQueryPageSizeRpcM;
using zePhysicalMemCreate = ZePhysicalMemCreateRpcM;
using zePhysicalMemDestroy = ZePhysicalMemDestroyRpcM;
using zeVirtualMemMap = ZeVirtualMemMapRpcM;
using zeVirtualMemUnmap = ZeVirtualMemUnmapRpcM;
using zeVirtualMemSetAccessAttribute = ZeVirtualMemSetAccessAttributeRpcM;
using zeVirtualMemGetAccessAttribute = ZeVirtualMemGetAccessAttributeRpcM;
using zexDriverImportExternalPointer = ZexDriverImportExternalPointerRpcM;
using zexDriverReleaseImportedPointer = ZexDriverReleaseImportedPointerRpcM;
using zexDriverGetHostPointerBaseAddress = ZexDriverGetHostPointerBaseAddressRpcM;
using zeCommandListAppendMemoryCopyDeferred_Usm_Usm = ZeCommandListAppendMemoryCopyDeferred_Usm_UsmRpcM;
using zeCommandListAppendMemoryCopyDeferred_Usm_Shared = ZeCommandListAppendMemoryCopyDeferred_Usm_SharedRpcM;
using zeCommandListAppendMemoryCopyDeferred_Usm_Remapped = ZeCommandListAppendMemoryCopyDeferred_Usm_RemappedRpcM;
using zeCommandListAppendMemoryCopyDeferred_Shared_Usm = ZeCommandListAppendMemoryCopyDeferred_Shared_UsmRpcM;
using zeCommandListAppendMemoryCopyDeferred_Shared_Shared = ZeCommandListAppendMemoryCopyDeferred_Shared_SharedRpcM;
using zeCommandListAppendMemoryCopyDeferred_Shared_Remapped = ZeCommandListAppendMemoryCopyDeferred_Shared_RemappedRpcM;
using zeCommandListAppendMemoryCopyDeferred_Remapped_Usm = ZeCommandListAppendMemoryCopyDeferred_Remapped_UsmRpcM;
using zeCommandListAppendMemoryCopyDeferred_Remapped_Shared = ZeCommandListAppendMemoryCopyDeferred_Remapped_SharedRpcM;
using zeCommandListAppendMemoryCopyDeferred_Remapped_Remapped = ZeCommandListAppendMemoryCopyDeferred_Remapped_RemappedRpcM;
using zeCommandListAppendMemoryCopyImmediate_Local_Local = ZeCommandListAppendMemoryCopyImmediate_Local_LocalRpcM;
using zeCommandListAppendMemoryCopyImmediate_Local_Usm = ZeCommandListAppendMemoryCopyImmediate_Local_UsmRpcM;
using zeCommandListAppendMemoryCopyImmediate_Local_Shared = ZeCommandListAppendMemoryCopyImmediate_Local_SharedRpcM;
using zeCommandListAppendMemoryCopyImmediate_Usm_Local = ZeCommandListAppendMemoryCopyImmediate_Usm_LocalRpcM;
using zeCommandListAppendMemoryCopyImmediate_Usm_Usm = ZeCommandListAppendMemoryCopyImmediate_Usm_UsmRpcM;
using zeCommandListAppendMemoryCopyImmediate_Usm_Shared = ZeCommandListAppendMemoryCopyImmediate_Usm_SharedRpcM;
using zeCommandListAppendMemoryCopyImmediate_Shared_Local = ZeCommandListAppendMemoryCopyImmediate_Shared_LocalRpcM;
using zeCommandListAppendMemoryCopyImmediate_Shared_Usm = ZeCommandListAppendMemoryCopyImmediate_Shared_UsmRpcM;
using zeCommandListAppendMemoryCopyImmediate_Shared_Shared = ZeCommandListAppendMemoryCopyImmediate_Shared_SharedRpcM;
using zeCommandListAppendMemoryCopyImmediateSynchronous_Local_Local = ZeCommandListAppendMemoryCopyImmediateSynchronous_Local_LocalRpcM;
using zeCommandListAppendMemoryCopyImmediateSynchronous_Local_Usm = ZeCommandListAppendMemoryCopyImmediateSynchronous_Local_UsmRpcM;
using zeCommandListAppendMemoryCopyImmediateSynchronous_Local_Shared = ZeCommandListAppendMemoryCopyImmediateSynchronous_Local_SharedRpcM;
using zeCommandListAppendMemoryCopyImmediateSynchronous_Usm_Local = ZeCommandListAppendMemoryCopyImmediateSynchronous_Usm_LocalRpcM;
using zeCommandListAppendMemoryCopyImmediateSynchronous_Usm_Usm = ZeCommandListAppendMemoryCopyImmediateSynchronous_Usm_UsmRpcM;
using zeCommandListAppendMemoryCopyImmediateSynchronous_Usm_Shared = ZeCommandListAppendMemoryCopyImmediateSynchronous_Usm_SharedRpcM;
using zeCommandListAppendMemoryCopyImmediateSynchronous_Shared_Local = ZeCommandListAppendMemoryCopyImmediateSynchronous_Shared_LocalRpcM;
using zeCommandListAppendMemoryCopyImmediateSynchronous_Shared_Usm = ZeCommandListAppendMemoryCopyImmediateSynchronous_Shared_UsmRpcM;
using zeCommandListAppendMemoryCopyImmediateSynchronous_Shared_Shared = ZeCommandListAppendMemoryCopyImmediateSynchronous_Shared_SharedRpcM;
using zeCommandListAppendMemoryCopyFromContextDeferred_Usm_Usm = ZeCommandListAppendMemoryCopyFromContextDeferred_Usm_UsmRpcM;
using zeCommandListAppendMemoryCopyFromContextDeferred_Shared_Usm = ZeCommandListAppendMemoryCopyFromContextDeferred_Shared_UsmRpcM;
using zeCommandListAppendMemoryCopyFromContextDeferred_Remapped_Usm = ZeCommandListAppendMemoryCopyFromContextDeferred_Remapped_UsmRpcM;
using zeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Local_Usm = ZeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Local_UsmRpcM;
using zeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Usm_Usm = ZeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Usm_UsmRpcM;
using zeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Shared_Usm = ZeCommandListAppendMemoryCopyFromContextImmediateSynchronous_Shared_UsmRpcM;
using zeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Local_Usm = ZeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Local_UsmRpcM;
using zeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Usm_Usm = ZeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Usm_UsmRpcM;
using zeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Shared_Usm = ZeCommandListAppendMemoryCopyFromContextImmediateAsynchronous_Shared_UsmRpcM;
}

} // namespace LevelZero
} // namespace Rpc
} // namespace Cal
// #### Generated code -- end ####
